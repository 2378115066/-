# 1.线性表的合并
求解一般集合的并集问题
### 【问题描述】
已知两个集合A和B，现要求一个新的集合A=AUB。例如，设A=(7，5，3，11)B=(2，6，3)合并后A=(7，5，3，11，2，6)
### 【问题分析】
可以利用两个线性表LA和LB分别表示集合A和B（即线性表中的数据元素为集合中的成员），这样只需扩大线性表LA，将存在于LB中而不存在于LA中的数据元素插入到LA中去。只要从LB中依次取得每个数据元素，并依值在LA中进行查访，若不存在，则插入之。上述操作过程可用算法2.15来描述。具体实现时既可采用顺序形式，也可采用链表形式。
### 【算法步骤】
```
1).取LA表长m和LB表长n
2).中第1个数据元素开始，循环n次执行以下操作：
		从LB中查找第i（1≤i≤n）个数据元素赋给e
		在LA中查找元素e，如果不存在，则将e插在表LA的最后
```
### 【算法描述】
```c
void MergeList(List &LA,List LB)
{//将所有在线性表LB中但不在LA中的数据元素插入到LA中
   m=ListLength(LA); n=ListLength(LB);           //求线性表的长度
   for(i=1;i<=n;i++)
   {
      GetElem(LB,i,e);                           //取LB中第i个数据元素赋给e
      if(!LocateElem(LA,e))                      //LA中不存在和e相同的数据元素
         ListInsert(LA,++m,e);                   //将e插在LA的最后
   }
}
```
### 【算法分析】
上述算法的时间复杂度取决于抽象数据类型List定义中基本操作的执行时间，假设LA和LB的表长分别为m和n，循环执行n次，则：
当采用顺序存储结构时，在每次循环中，GetElem和ListInsert这两个操作的执行时间和表长无关，LocateElem的执行时间和表长m成正比，因此，算法2.15的时间复杂度为O(m×n)。
当采用链式存储结构时，在每次循环中，GetElem的执行时间和表长n成正比，而LocateElem和ListInsert这两个操作的执行时间和表长m成正比，因此，若假设m大于n，算法2.15的时间复杂度也为O(m×n)。

# 2.有序表的合并
若线性表中的数据元素相互之间可以比较，并且数据元素在线性表中依值非递减或非递增有序排列，则称该线性表为**有序表**（Ordered List）
 求解有序集合的并集问题
### 【问题描述】
有序集合是指集合中的元素有序排列。已知两个有序集合A和B，数据元素按值非递减有序排列，现要求一个新的集合C=AUB，使集合C中的数据元素仍按值非递减有序排列
例如，设
A=(3, 5, 8, 11)
B=(2, 6, 8, 9, 11, 15, 20)
则
C=(2, 3, 5, 6, 8, 8, 9, 11, 11, 15, 20)
### 【问题分析】
与例2.1一样，可以利用两个线性表LA和LB分别表示集合A和B，不同的是，此例中的LA和LB有序，这样便没有必要从LB中依次取得每个数据元素，到LA中进行查访。如果LA和LB两个表长分别记为m和n，则合并后的新表LC的表长应该为m+n。由于LC中的数据元素或是LA中的元素，或是LB中的元素，因此只要先设LC为空表，然后将LA或LB中的元素逐个插入到LC中即可。为使LC中的元素按值非递减有序排列，可设两个指针pa和pb分别指向LA和LB中的某个元素，若设pa当前所指的元素为a，pb当前所指的元素为b，则当前应插入到LC中的元素c为
![image-20240719180511844](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240719180511844.png)
显然，指针pa和pb的初值分别指向两个有序表的第一个元素，在所指元素插入LC之后，在LA或LB中顺序后移。根据上述分析，分别给出有序表的顺序存储结构和链式存储结构相应合并算法的实现。
## 1．顺序有序表的合并
### 【算法步骤】
```
1).创建一个表长为m+n的空表LC。② 指针pc初始化，指向LC的第一个元素。③ 指针pa和pb初始化，分别指向LA和LB的第一个元素
2).当指针pa和pb均未到达相应表尾时，则依次比较pa和pb所指向的元素值，从LA或LB中“摘取”元素值较小的结点插入到LC的最后
3).如果pb已到达LB的表尾，依次将LA的剩余元素插入LC的最后
4).如果pa已到达LA的表尾，依次将LB的剩余元素插入LC的最后
```
### 【算法描述】
```c
void MergeList_Sq(SqList LA,SqList LB,SqList &LC)
{//已知顺序有序表LA和LB的元素按值非递减排列
 //归并LA和LB得到新的顺序有序表LC，LC的元素也按值非递减排列
   LC.length=LA.length+LB.length;           //新表长度为待合并两表的长度之和
   LC.elem=new ElemType[LC.length];         //为合并后的新表分配一个数组空间
   pc=LC.elem;                              //指针pc指向新表的第一个元素
   pa=LA.elem;  pb=LB.elem;                 //指针pa和pb的初值分别指向两个表的第一个元素
   pa_last=LA.elem+LA.length-1;             //指针pa_last指向LA的最后一个元素
   pb_last=LB.elem+LB.length-1;             //指针pb_last指向LB的最后一个元素
   while((pa<=pa_last)&&(pb<=pb_last))      //LA和LB均未到达表尾
   {
     if(*pa<=*pb) *pc++=*pa++;              //依次“摘取”两表中值较小的结点插入到LC的最后
     else *pc++=*pb++;
   }
   while(pa<=pa_last)  *pc++=*pa++;         //LB已到达表尾，依次将LA的剩余元素插入LC的最后
   while(pb<=pb_last)  *pc++=*pb++;         //LA已到达表尾，依次将LB的剩余元素插入LC的最后
}
```
### 【算法分析】
若对算法2.16中第一个循环语句的循环体做如下修改：分出元素比较的第三种情况，当*pa==*pb时，只将两者中之一插入LC，则该算法完成的操作和算法2.15相同，但时间复杂度却不同。在算法2.16中，由于LA和LB中元素依值非递减，则对LB中的每个元素，不需要在LA中从表头至表尾进行全程搜索。如果两个表长分别记为m和n，则算法2.16循环最多执行的总次数为m+n。所以算法的时间复杂度为O(m+n)。此算法在归并时，需要开辟新的辅助空间，所以空间复杂度也为O(m+n)，空间复杂度较高。利用链表来实现上述归并时，不需要开辟新的存储空间，可以使空间复杂度达到最低。
## 2．链式有序表的合并
假设头指针为LA和LB的单链表分别为线性表LA和LB的存储结构，现要归并LA和LB得到单链表LC。因为链表结点之间的关系是通过指针指向建立起来的，所以用链表进行合并不需要另外开辟存储空间，可以直接利用原来两个表的存储空间，合并过程中只需把LA和LB两个表中的结点重新进行链接即可。按照例2.2给出的合并思想，需设立3个指针pa、pb和pc，其中pa和pb分别指向LA和LB中当前待比较插入的结点，而pc指向LC中当前最后一个结点（LC的表头结点设为LA的表头结点）。指针的初值为：pa和pb分别指向LA和LB表中的第一个结点，pc指向空表LC中的头结点。同算法2.16一样，通过比较指针pa和pb所指向的元素的值，依次从LA或LB中“摘取”元素值较小的结点插入到LC的最后，当其中一个表变空时，只要将另一个表的剩余段链接在pc所指结点之后即可。
### 【算法步骤】
```
1).指针pa和pb初始化，分别指向LA和LB的第一个结点
2).LC的结点取值为LA的头结点
3).指针pc初始化，指向LC的头结点
4).当指针pa和pb均未到达相应表尾时，则依次比较pa和pb所指向的元素值，从LA或LB中“摘取”元素值较小的结点插入到LC的最后
5).将非空表的剩余段插入到pc所指结点之后
6).释放LB的头结点。
```
### 【算法描述】
```c
void MergeList_L(LinkList &LA,LinkList &LB,LinkList &LC)
{//已知单链表LA和LB的元素按值非递减排列
 //归并LA和LB得到新的单链表LC，LC的元素也按值非递减排列
   pa=LA->next;pb=LB->next;                       //pa和pb的初值分别指向两个表的第一个结点
   LC=LA;                                         //用LA的头结点作为LC的头结点
   pc=LC;                                         //pc的初值指向LC的头结点
   while(pa&&pb)
   {//LA和LB均未到达表尾，依次“摘取”两表中值较小的结点插入到LC的最后
      if(pa->data<=pb->data)                      //“摘取”pa所指结点
      {
         pc->next=pa;                             //将pa所指结点链接到pc所指结点之后
         pc=pa;                                   //pc指向pa
         pa=pa->next;                             //pa指向下一结点
      }
      else                                        //“摘取”pb所指结点
      {
         pc->next=pb;                             //将pb所指结点链接到pc所指结点之后
         pc=pb;                                   //pc指向pb
         pb=pb->next;                             //pb指向下一结点
      }
   }                                              //while
      pc->next=pa?pa:pb;                          //将非空表的剩余段插入到pc所指结点之后
      delete LB;                                  //释放LB的头结点
}
```
### 【算法分析】
在归并两个链表为一个链表时，不需要另建新表的结点空间，而只需将原来两个链表中结点之间的关系解除，重新按元素值非递减的关系将所有结点链接成一个链表即可，所以空间复杂度为O(1)
# 3.数制的转换
###### 【案例分析】
当将一个十进制整数N转换为八进制数时，在计算过程中，把N与8求余得到的八进制数的各位依次进栈，计算完毕后将栈中的八进制数依次出栈输出，输出结果就是待求得的八进制数
###### 【案例实现】
在具体实现时，栈可以采用顺序存储表示也可以采用链式存储表示。
###### 【算法步骤】
```
1).初始化一个空栈S
2).当十进制数N非零时，循环执行以下操作：
		把N与8求余得到的八进制数压入栈S
		N更新为N与8的商
3).当栈S非空时，循环执行以下操作：
		弹出栈顶元素e
		输出e。
```
###### 【算法描述】
```c
void conversion(int N)
{//对于任意一个非负十进制数，打印输出与其等值的八进制数
   InitStack(S);                                 //初始化空栈S
   while(N)                                     //当N非零时,循环
   {
     Push(S,N%8);                               //把N与8求余得到的八进制数压入栈S
     N=N/8;                                     //N更新为N与8的商
   }
   while(!StackEmpty(S))                       //当栈S非空时，循环
   {
     Pop(S,e);                                 //弹出栈顶元素e
     cout<<e;                                  //输出e
   }
}
```
###### 【算法分析】
显然，该算法的时间和空间复杂度均为O(log8n)。这是利用栈的后进先出特性的最简单的例子。在这个例子中，栈的操作是单调的，即先一味地入栈，然后一味地出栈。也许，有的读者会提出疑问：用数组直接实现不是更简单吗？但仔细分析上述算法不难看出，栈的引入简化了程序设计的问题，划分了不同的关注层次，使思考范围缩小了。而用数组不仅掩盖了问题的本质，还要分散精力去考虑数组下标增减等细节问题。在实际利用栈的问题中，入栈和出栈操作大都不是单调的，而是交错进行的。下面的案例3.2和3.3都属于这种情况。
# 4.括号匹配的检验
###### 【案例分析】
检验算法借助一个栈，每当读入一个左括号，则直接入栈，等待相匹配的同类右括号；每当读入一个右括号，若与当前栈顶的左括号类型相同，则二者匹配，将栈顶的左括号出栈，直到表达式扫描完毕
在处理过程中，还要考虑括号不匹配出错的情况。例如，当出现(( )[ ]))这种情况时，由于前面入栈的左括号均已和后面出现的右括号相匹配，栈已空，因此最后扫描的右括号不能得到匹配；出现[([ ])这种错误，当表达式扫描结束时，栈中还有一个左括号没有匹配；出现(( )]这种错误显然是栈顶的左括号和最后的右括号不匹配。
###### 【算法步骤】
1).初始化一个空栈S
2).设置一标记性变量flag，用来标记匹配结果以控制循环及返回结果，1表示正确匹配，0表示错误匹配，flag初值为1
3).扫描表达式，依次读入字符ch，如果表达式没有扫描完毕且flag非零，则循环执行以下操作：
	若ch是左括号“[”或“(”，则将其压入栈
	若ch是右括号“)”，则根据当前栈顶元素的值分情况考虑：若栈非空且栈顶元素是“(”，则正确匹配，否则错误匹配，flag置为0
	若ch是右括号“]”，则根据当前栈顶元素的值分情况考虑：若栈非空且栈顶元素是“[”，则正确匹配，否则错误匹配，flag置为0
4).退出循环后，如果栈空且flag值为1，则匹配成功，返回true，否则返回false。

###### 【算法描述】
```
Status Matching()
{//检验表达式中所含括号是否正确匹配，如果匹配，则返回true，否则返回false 
 //表达式以“#”结束 
   InitStack(S);                             //初始化空栈 
   flag=1;                                  //标记匹配结果以控制循环及返回结果 
   cin>>ch;                                 //读入第一个字符 
   while(ch!='#'&&flag)                     //假设表达式以“#”结尾 
   { 
      switch(ch) 
      { 
         case '['||'(':                    //若是左括号，则将其压入栈 
            Push(S,ch);  
            break;    
         case ')':                         //若是“)”，则根据当前栈顶元素的值分情况考虑 
            if(!StackEmpty(S)&&GetTop(S)=='(')  
               Pop(S,x);                   //若栈非空且栈顶元素是“(”，则正确匹配 
            else flag=0;                  //若栈空或栈顶元素不是“(”，则错误失败 
            break; 
         case ']':                        //若是“]”， 则根据当前栈顶元素的值分情况考虑
            if(!StackEmpty(S)&&GetTop(S)=='[')  
               Pop(S,x);                  //若栈非空且栈顶元素是“[”，则正确匹配 
            else flag=0;                  //若栈空或栈顶元素不是“[”，则错误匹配 
            break; 
      }                                   //switch 
      cin>>ch;                            //继续读入下一个字符 
   }                                      //while 
   if(StackEmpty(S)&&flag) return true;  //匹配成功 
   else return false;                    //匹配失败 
}
```
###### 【算法分析】
此算法从头到尾扫描表达式中每个字符，若表达式的字符串长度为n，则此算法的时间复杂度为O(n)。算法在运行时所占用的辅助空间主要取决于S栈的大小，显然，S栈的空间大小不会超过n，所以此算法的空间复杂度也同样为O(n)
# 5.表达式求值
###### 【案例分析】
任何一个表达式都是由操作数（operand）、运算符（operator）和界限符（delimiter）组成的，统称它们为单词。一般地，操作数既可以是常数，也可以是被说明为变量或常量的标识符；运算符可以分为算术运算符、关系运算符和逻辑运算符3类；基本界限符有左右括号和表达式结束符等。为了叙述的简洁，在此仅讨论简单算术表达式的求值问题，这种表达式只含加、减、乘、除4种运算符。读者不难将它推广到更一般的表达式上。
下面把运算符和界限符统称为算符
我们知道，算术四则运算遵循以下3条规则：
		（1）先乘除，后加减
		（2）从左算到右
		（3）先括号内，后括号外
根据上述3条运算规则，在运算的每一步中，任意两个相继出现的算符θ1和θ2之间的优先关系，至多是下面3种关系之一：
		θ1 < θ2 θ1的优先权低于θ2
		θ1 = θ2 θ1的优先权等于θ2
		θ1 > θ2 θ1的优先权高于θ2
![image-20240719193438498](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240719193438498.png)
							算符间的优先关系
由规则（1），先进行乘除运算，后进行加减运算，所以有“+”<“*”；“+”<“/”；“*”>“+”；“/”>“+”等
由规则（2），运算遵循左结合性，当两个运算符相同时，先出现的运算符优先级高，所以有“+”>“+”；“−”>“−”；“*”>“*”；“/”>“/”
由规则（3），括号内的优先级高，+、−、*和/为θ1时的优先性均低于“（”但高于“）”

表中的“(”=“)”表示当左右括号相遇时，括号内的运算已经完成。为了便于实现，假设每个表达式均以“#”开始，以“#”结束。所以“#”=“#”表示整个表达式求值完毕。“)”与“(”、“#”与“)”以及“(”与“#”之间无优先关系，这是因为表达式中不允许它们相继出现，一旦遇到这种情况，则可以认为出现了语法错误。
###### 【案例实现】
为实现算符优先算法，可以使用两个工作栈，一个称作OPTR，用以寄存运算符；另一个称作OPND，用以寄存操作数或运算结果
###### 【算法步骤】
```
1).初始化OPTR栈和OPND栈，将表达式起始符“#”压入OPTR栈
2).扫描表达式，读入第一个字符ch，如果表达式没有扫描完毕至“#”或OPTR的栈顶元素不为“#”时，则循环执行以下操作：
		若ch不是运算符，则压入OPND栈，读入下一字符ch
		若ch是运算符，则根据OPTR的栈顶元素和ch的优先级比较结果，做不同的处理：
			若是小于，则ch压入OPTR栈，读入下一字符ch
			若是大于，则弹出OPTR栈顶的运算符，从OPND栈弹出两个数，进行相应运算，结果压入OPND栈
			若是等于，则OPTR的栈顶元素是“(”且ch是“)”，这时弹出OPTR栈顶的“(”，相当于括号匹配成功，然后读入下一字符ch。
3).OPND栈顶元素即为表达式求值结果，返回此元素
```
###### 【算法描述】
```c
char EvaluateExpression()
{//算术表达式求值的算符优先算法，设OPTR和OPND分别为运算符栈和操作数栈 
   InitStack(OPND);                           //初始化OPND栈 
   InitStack(OPTR);                           //初始化OPTR栈 
   Push(OPTR，'#');                           //将表达式起始符“#”压入OPTR栈 
   cin>>ch; 
   while(ch!='#'||GetTop(OPTR)!='#')          //表达式没有扫描完毕或OPTR的栈顶元素不为“#”
   { 
      if(!In(ch)){Push(OPND,ch);cin>>ch;}     //ch不是运算符则进OPND栈 
      else 
         switch(Precede(GetTop(OPTR),ch))     //比较OPTR的栈顶元素和ch的优先级 
         { 
            case '<':        
               Push(OPTR,ch);cin>>ch;         //当前字符ch压入OPTR栈，读入下一字符ch 
               break; 
            case '>':       
               Pop(OPTR,theta);                //弹出OPTR栈顶的运算符 
               Pop(OPND,b);Pop(OPND,a);       //弹出OPND栈顶的两个运算数 
               Push(OPND,Operate(a,theta,b)); //将运算结果压入OPND栈 
               break; 
            case '=':                        //OPTR的栈顶元素是“(”且ch是“)”
               Pop(OPTR,x);cin>>ch;         //弹出OPTR栈顶的“(”，读入下一字符ch 
               break; 
         }                                  //switch 
   }                                        //while 
   return GetTop(OPND);                    //OPND栈顶元素即为表达式求值结果 
} 
```
算法调用的三个函数需要读者自行补充完成。其中函数In是判定读入的字符ch是否为运算符，Precede是判定运算符栈的栈顶元素与读入的运算符之间优先关系的函数，Operate为进行二元运算的函数
另外需要特别说明的是，上述算法中的操作数只能是一位数，因为这里使用的OPND栈是字符栈，如果要进行多位数的运算，则需要将OPND栈改为数栈，读入的数字字符拼成数之后再入栈。读者可以改进此算法，使之能完成多位数的运算。
###### 【算法分析】
此算法从头到尾扫描表达式中每个字符，若表达式的字符串长度为n，则此算法的时间复杂度为O(n)。算法在运行时所占用的辅助空间主要取决于OPTR栈和OPND栈的大小，显然，它们的空间大小之和不会超过n，所以此算法的空间复杂度也同样为O(n)。

在表达式两端先增加“#”，改写为
```
#3*(7−2)#
```
![image-20240719193546916](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240719193546916.png)
						算术表达式3*(7−2)的求值过程

在高级语言的编译处理过程中，实际上不只是表达式求值可以借助栈来实现，高级语言中一般语法成分的分析都可以借助栈来实现，在编译原理后续课程中会涉及栈在语法、语义等分析算法中的应用。
# 6.舞伴问题
###### 【案例分析】
对于舞伴配对问题，先入队的男士或女士先出队配成舞伴，因此设置两个队列分别存放男士和女士入队者。假设男士和女士的记录存放在一个数组中作为输入，然后依次扫描该数组的各元素，并根据性别来决定是进入男队还是女队。当这两个队列构造完成之后，依次将两队当前的队头元素出队来配成舞伴，直至某队列变空为止。此时，若某队仍有等待配对者，则输出此队列中排在队头的等待者的姓名，此人将是下一轮舞曲开始时第一个可获得舞伴的人
###### 【案例实现】
算法中有关数据结构的定义如下：
```c
//- - - - - 跳舞者个人信息- - - - -
typedef struct
{
   char name[20];                                        //姓名
   char sex;                                             //性别，'F'表示女性，'M'表示男性
}Person;
//- - - - - 队列的顺序存储结构- - - - -
#define MAXQSIZE 100                                    //队列可能达到的最大长度
typedef struct
{
   Person *base;                                       //队列中数据元素类型为Person
   int front;                                          //头指针
   int rear;                                           //尾指针
}SqQueue;
SqQueue Mdancers,Fdancers;                             //分别存放男士和女士入队者队列
```
###### 【算法步骤】
```
1).初始化Mdancers队列和Fdancers队列
2).反复循环，依次将跳舞者根据其性别插入Mdancers队列或Fdancers队列
3).当Mdancers队列和Fdancers队列均为非空时，反复循环，依次输出男女舞伴的姓名
4).如果Mdancers队列为空而Fdancers队列非空，则输出Fdancers队列的队头女士的姓名
5).如果Fdancers队列为空而Mdancers队列非空，则输出Mdancers队列的队头男士的姓名
```
###### 【算法描述】
```c
void DancePartner(Person dancer[],int num)
{//结构数组dancer中存放跳舞的男女，num是跳舞的人数。 
   InitQueue(Mdancers);                   //男士队列初始化 
   InitQueue(Fdancers);                   //女士队列初始化 
   for(i=0;i<num;i++)                     //依次将跳舞者根据其性别入队 
   { 
      p=dancer[i]; 
      if(p.sex=='F') EnQueue(Fdancers,p); //插入女队 
      else EnQueue(Mdancers,p);           //插入男队 
   } 
   cout<<"The dancing partners are:\n"; 
   while(!QueueEmpty(Fdancers)&&!QueueEmpty(Mdancers)) 
   {//依次输出男女舞伴的姓名 
      DeQueue(Fdancers,p);               //女士出队 
      cout<<p.name<<"  ";                //输出出队女士姓名 
      DeQueue(Mdancers,p);               //男士出队 
      cout<<p.name<<endl;                //输出出队男士姓名 
   } 
   if(!QueueEmpty(Fdancers))             //女士队列非空，输出队头女士的姓名 
   { 
      p=GetHead(Fdancers)                //取女士队头 
      cout<<"The first woman to get a partner is: "<< p.name<<endl; 
   } 
   else if(!QueueEmpty(Mdancers))       //男士队列非空，输出队头男士的姓名 
  { 
      p=GetHead(Mdancers)               //取男士队头 
      cout<<"The first man to get a partner is: "<< p.name<<endl; 
   } 
} 
```
###### 【算法分析】
若跳舞者人数总计为n，则此算法的时间复杂度为O(n)。空间复杂度取决于Mdancers队列和Fdancers队列的长度，二者长度之和不会超过n，因此空间复杂度也同样为O(n)
队列在程序设计中也有很多应用，凡是符合先进先出原则的数学模型，都可以用队列。最典型的例子是操作系统中用来解决主机与外设之间速度不匹配问题或多个用户引起的资源竞争问题
例如，一个局域网上有一台共享的网络打印机，网上每个用户都可以将数据发送给网络打印机进行打印。为了保证能够正常打印，操作系统为网络打印机生成一个“作业队列”，每个申请打印的“作业”应按先后的顺序排队，打印机从作业队列中逐个提取作业进行打印
这方面的例子很多，在操作系统等后续课程中会涉及大量队列这种数据结构的应用
在实际应用中，队列应用的例子更是常见，通常用以模拟排队情景。例如，拿汽车加油站来说，通常的结构基本上是：入口和出口为单行道，加油车道可能有若干条。每辆车加油都要经过三段路程，第一段是在入口处排队等候进入加油车道；第二段是在加油车道排队等候加油；第三段是在进入出口处排队等候离开。实际上，这三段都是队列结构。若用算法模拟这个过程，总共需要设置的队列个数应该为加油车道数加上2

# 7.病毒感染检测

###### 【案例分析】

因为患者的DNA和病毒DNA均是由一些字母组成的字符串序列，要检测某种病毒DNA序列是否在患者的DNA序列中出现过，实际上就是字符串的模式匹配问题。可以利用BF算法，也可以利用更高效的KMP算法。但与一般的模式匹配问题不同的是，此案例中病毒的DNA序列是环状的，这样需要对传统的BF算法或KMP算法进行改进。

###### 【案例实现】

对于每一个待检测的任务，假设病毒DNA序列的长度是m，因为病毒DNA序列是环状的，为了线性取到每个可行的长度为m的模式串，可将存储病毒DNA序列的字符串长度扩大为2m，将病毒DNA序列连续存储两次。然后循环m次，依次取得每个长度为m的环状字符串，将此字符串作为模式串，将人的DNA序列作为主串，调用BF算法进行模式匹配。只要匹配成功，即可中止循环，表明该人感染了对应的病毒；否则，循环m次结束循环时，可通过BF算法的返回值判断该人是否感染了对应的病毒。

###### 【算法步骤】

```
1). 从文件中读取待检测的任务数num。

2).根据num个数依次检测每对病毒DNA和人的DNA是否匹配，循环num次，执行以下操作：
        从文件中分别读取一对病毒DNA序列和人的DNA序列；
        设置一个标志性变量flag，用来标识是否匹配成功，初始为0，表示未匹配；
        病毒DNA序列的长度是m，将存储病毒DNA序列的字符串长度扩大为2m，将病毒DNA序列连续存储两次
        循环m次，重复执行以下操作：
​		依次取得每个长度为m的病毒DNA环状字符串；将此字符串作为模式串，将人的DNA序列作为主串，调用BF算法进行模式匹配，将匹配结果返回赋值给flag；若flag非0，表示匹配成功，中止循环，表明该人感染了对应的病毒。·退出循环时，判断flag的值，若flag非0，输出“YES”，否则，输出“NO”。
```

###### 【算法描述】

```c
void Virus_detection()
{//利用BF算法实现病毒检测 
   ifstream inFile("病毒感染检测输入数据.txt"); 
   ofstream outFile("病毒感染检测输出结果.txt"); 
   inFile>>num;                           //读取待检测的任务数 
   while(num--)                           //依次检测每对病毒DNA和人的DNA是否匹配 
   { 
      inFile>>Virus.ch+1;                 //读取病毒DNA序列，字符串从下标1开始存放 
      inFile>>Person.ch+1;                //读取人的DNA序列 
      Vir=Virus.ch;                       //将病毒DNA临时暂存在Vir中，以备输出 
      flag=0;                             //用来标识是否匹配，初始为0，匹配后为非0 
      m=Virus.length;                     //病毒DNA序列的长度是m 
      for(i=m+1,j=1;j<=m;j++)  
         Virus.ch[i++]=Virus.ch[j];       //将病毒字符串的长度扩大2倍 
      Virus.ch[2*m+1]='\0';              //添加结束符号 
      for(i=0;i<m;i++)                   //依次取得每个长度为m的病毒DNA环状字符串temp 
      { 
         for(j=1;j<=m;j++) temp.ch[j]=Virus.ch[i+j]; 
         temp.ch[m+1]='\0';             //添加结束符号 
         flag=Index_BF(Person,temp,1);  //模式匹配 
         if(flag) break;                //匹配即可退出循环 
      }                                 //for 
      if(flag) outFile<<Vir+1<<" "<<Person.ch+1<<" "<<"YES"<<endl; 
      else      outFile<<Vir+1<<" "<<Person.ch+1<<" "<<"NO"<<endl; 
   }                                    //while 
}
```
###### 【算法分析】
对于每一个待检测的任务而言，该算法都需要执行m次模式匹配，假设人的DNA序列长度为n，由于BF算法的时间复杂度为O(m*n)，因此，对于每一个待检测的任务，时间复杂度都为O(m*m*n)。如果待检测的任务个数为num，则上述算法的时间复杂度为O(num*m*m*n)，时间复杂度较高。利用KMP算法完成模式匹配将有效地提高匹配效率，读者可以模仿该算法，实现利用KMP算法完成检测的方案。

# 8.利用二叉树求解表达式的值。
###### 【案例分析】
对于任意一个算术表达式，都可用二叉树来表示。表达式对应的二叉树创建后，利用二叉树的遍历等操作，很容易实现表达式的求值运算。因此问题的关键就是如何创建表达式树，下面讨论由中缀表达式创建表达式树的方法。
假设运算符均为双目运算符，则表达式对应的表达式树中叶子结点均为操作数，分支结点均为运算符。由于创建的表达式树需要准确的表达运算次序，因此在扫描表达式创建表达式树的过程中，当遇到运算符时不能直接创建结点，而应将其与前面的运算符进行优先级比较，根据比较的结果再进行处理。这种处理方式类似于第3章的表达式求值算法中的运算符的比较，可以借助一个运算符栈，来暂存已经扫描到的还未处理的运算符。
根据表达式树与表达式对应关系的递归定义，每两个操作数和一个运算符就可以建立一棵表达式二叉树，而该二叉树又可以作为另一个运算符结点的一棵子树。可以另外借助一个表达式树栈，来暂存已建立好的表达式树的根结点，以便其作为另一个运算符结点的子树而被引用。
####### 【案例实现】
为实现表达式树的创建算法，可以使用两个工作栈，一个称做OPTR，用以暂存运算符；另一个称做EXPT，用以暂存已建立好的表达式树的根结点。为了便于实现，和第3章一样，假设每个表达式均以“#”开始，以“#”结束。
###### 【算法步骤】
```
1.初始化OPTR栈和EXPT栈，将表达式起始符“#”压入OPTR栈。
2.扫描表达式，读入第一个字符ch，如果表达式没有扫描完毕至“#”或OPTR的栈顶元素不为“#”时，则循环执行以下操作：
    若ch不是运算符，则以ch为根创建一棵只有根结点的二叉树，且将该树根结点压入EXPT栈，读入下一字符ch；
    若ch是运算符，则根据OPTR的栈顶元素和ch的优先级比较结果，做不同的处理：
```

若是小于，则ch压入OPTR栈，读入下一字符ch；

若是大于，则弹出OPTR栈顶的运算符，从EXPT栈弹出两个表达式子树的根结点，以该运算符为根结点，以EXPT栈中弹出的第二个子树作为左子树，以EXPT栈中弹出的第一个子树作为右子树，创建一棵新二叉树，并将该树根结点压入EXPT栈；

若是等于，则OPTR的栈顶元素是“(”且ch是“)”，这时弹出OPTR栈顶的“(”，相当于括号匹配成功，然后读入下一字符ch。

###### 【算法描述】

```c
void InitExpTree()
{//表达式树的创建算法 
   InitStack(EXPT);                          //初始化EXPT栈 
   InitStack(OPTR);                          //初始化OPTR栈 
   Push(OPTR，'#');                          //将表达式起始符“#”压入OPTR栈 
   cin>>ch; 
   while(ch!='#'||GetTop(OPTR)!='#')        //表达式没有扫描完毕或OPTR的栈顶元素不为“#”
   { 
      if(!In(ch))                           //ch不是运算符 
         { 
            CreateExpTree(T,NULL,NULL,ch); //以ch为根创建一棵只有根结点的二叉树 
            Push(EXPT,T);                  //将二叉树根结点T进EXPT栈 
            cin>>ch;                       //读入下一字符 
         } 
      else 
         switch(Precede(GetTop(OPTR),ch)) //比较OPTR的栈顶元素和ch的优先级 
         { 
            case '<':        
               Push(OPTR,ch);cin>>ch;     //当前字符ch压入OPTR栈，读入下一字符 
               break; 
            case '>':       
               Pop(OPTR,theta);           //弹出OPTR栈顶的运算符 
               Pop(EXPT,b);Pop(EXPT,a);   //弹出EXPT栈顶的两个运算数 
               CreateExpTree(T,a,b,theta) //以theta为根，a为左子树，b为右子树，创建一棵二叉树 
               Push(EXPT,T);              //将二叉树根结点T进EXPT栈 
               break; 
            case '=':                    //OPTR的栈顶元素是“(”且ch是“)”
               Pop(OPTR,x);cin>>ch;      //弹出OPTR栈顶的“(”，读入下一字符ch 
               break; 
         }                              //switch 
   }                                    //while 
}
```
###### 【算法分析】
此算法从头到尾扫描表达式中每个字符，若表达式的字符串长度为n，则此算法的时间复杂度为O(n)。算法在运行时所占用的辅助空间主要取决于OPTR栈和EXPT栈的大小，显然，它们的空间大小之和不会超过n，所以此算法的空间复杂度也同样为O(n)。

# 9.表达式树的求值
###### 【算法步骤】
```
1.设变量lvalue和rvalue分别用以记录表达式树中左子树和右子树的值，初始均为0。

2.如果当前结点为叶子（结点为操作数），则返回该结点的数值，否则（结点为运算符）执行以下操作：
    递归计算左子树的值记为lvalue；
    递归计算右子树的值记为rvalue；
    根据当前结点运算符的类型，将lvalue和rvalue进行相应运算并返回。
```
###### 【算法描述】
```c
int EvaluateExpTree(BiTree T)
{//遍历表达式树进行表达式求值
   lvalue=rvalue=0;                             //初始为0
   if(T->lchild==NULL && T->rchild==NULL)
     return T->data-'0';                       //如果结点为操作数，则返回该结点的数值
   else                                        //如果结点为运算符
   {
     lvalue=EvaluateExpTree(T->lchild);       //递归计算左子树的值记为lvalue
     rvalue=EvaluateExpTree(T->rchild);       //递归计算右子树的值记为rvalue
     return GetValue(T->data,lvalue,rvalue);  //根据当前结点运算符的类型进行相应运算
   }
}
```
###### 【算法分析】
遍历表达式进行求值的过程实际上是一个后序遍历二叉树的过程，因此时间和空间复杂度均为O(n)。

# 10.六度空间理论

###### 【案例分析】

在六度空间理论提出之后的30多年的时间里，社会学家试图证明（或否定）此假设的正确性，但是该理论从来没有得到过严谨的证明，虽然屡屡应验，但它只是一种假说。很多社会学家主持的验证研究，都使用了网络时代的新型通信手段——E-mail。

比较著名的实验是2001年哥伦比亚大学社会学系的登肯·瓦兹主持的一项验证工程。166个不同国家的六万多名志愿者参加了该项研究。瓦兹随机选定18名目标（比如一名美国的教授、一名澳大利亚警察和一名挪威兽医等），要求志愿者选择其中的一名作为自己的目标，并发送电子邮件给自己认为最有可能发送邮件给目标的亲友。研究取得了较好的验证成果，瓦兹在世界最顶级的科学学术期刊《科学》杂志上发表了论文，表明邮件要达到目标，平均也只要经历5～7个人左右。

但实际上，这种研究方式有很大的局限性和困难。第一，使用E-mail保持社会关系的人群是有限的；第二，要记录和跟踪所有E-mail的走向是一项巨大的工程，需要大量的人力和较长的时间；第三，验证过程与志愿者的意愿紧密相关，志愿者可能会遗漏某些相识的人。

现代人使用电话和短信进行联络的频率远远大于使用E-mail的频率。由于电话和短信的通信都有一个运营商，与E-mail的通信相比，更便于跟踪。为了排除部分广告电话和广告短信，我们可以假设任意两个人在一年内，电话或短信相互收发两次以上即定义为两人“认识”，这样便很容易根据电话或短信的通信信息确定两人是否存在“认识”的关系。但在实际操作中，由于通信数据保密的原因，我们无法获取实际的通信数据，所以我们只能从理论上介绍并分析验证的方法。

我们把六度空间理论中的人际关系网络图抽象成一个不带权值的无向图G，用图G中的一个顶点表示一个人，两个人“认识”与否，用代表这两个人的顶点之间是否有一条边来表示。这样六度空间理论问题便可描述为：在图G中，任意两个顶点之间都存在一条路径长度不超过7的路径。

在实际验证过程中，可以通过测试满足要求的数据达到一定的百分比（比如99.5%）来进行验证。这样我们便把待验证六度空间理论问题描述为：在图G中，任意一个顶点到其余99.5%以上的顶点都存在一条路径长度不超过7的路径。比较简单的一种验证方案是：利用广度优先搜索方法，对任意一个顶点，通过对图G的“7层”遍历，就可以统计出所有路径长度不超过7的顶点数，从而得到这些顶点在所有顶点中的所占比例。

###### 【案例实现】

```
六度空间理论的验证
```

###### 【算法步骤】

① 完成系列初始化工作：设变量Visit_Num用来记录路径长度不超过7的顶点个数，初值为0；数组level用来记录遍历时不同层次下入队的顶点个数；Start为指定的一个起始顶点，置visited[Start]的值为true，即将Start标记为六度顶点的始点；辅助队列Q初始化为空，然后将Start进队。

② 当队列Q非空，且循环次数小于7时，循环执行以下操作（统计路径长度不超过7的顶点个数）：

```
队头顶点u出队；

依次检查u的所有邻接点w，如果visited[w]的值为false，则将w标记为六度顶点；

路径长度不超过7的顶点个数Visit_Num加1；

将w进队。
```

③ 退出循环时输出从顶点Start出发，到其他顶点长度不超过7的路径的百分比。

###### 【算法描述】

```c
void SixDegree_BFS(Graph G,int Start)
{//通过广度优先搜索方法遍历G来验证六度空间理论，Start为指定的一个起点 
   Visit_Num=0;                    //记录路径长度不超过7的顶点个数 
   visited[Start]=true;            //置顶点Start访问标志数组相应分量值为true  
   InitQueue(Q);                   //辅助队列Q初始化，置空          
   EnQueue(Q, Start);              //Start进队  
   for(len=1;len<=7 && !QueueEmpty(Q);len++)//统计路径长度不超过7的顶点个数 
   {         
      DeQueue(Q,u);                //队头顶点u出队 
      for(w=FirstAdjVex(G,u);w>=0;w=NextAdjVex(G,u,w))  
       //依次检查u的所有邻接点w，FirstAdjVex(G,u)表示u的第一个邻接点  
       //NextAdjVex(G,u,w)表示u相对于w的下一个邻接点，w≥0表示存在邻接点  
         if(!visited[w])          //w为u的尚未访问的邻接顶点 
         {                  
            visited[w]=true;      //将w标记为六度顶点 
            Visit_Num++;          //路径长度不超过7的顶点个数加1 
            EnQueue(Q,w);         //w进队  
         }                        //if  
   }                              //结束至多7次for循环 
   cout<<100*Visit_Num/G.vexnum; 
   //输出从顶点Start出发，到其他顶点长度不超过7的路径的百分比 
}
```

###### 【算法分析】

假定人际关系网络图G中有10亿人，即图中的顶点个数n=10亿。根据“150定律”，如果平均每个人认识其他150个人，则该图中边的个数e≈150*n/2=75*109，该算法的时间复杂度为O(n+e)，约为100G，对于现代每秒万亿次的运算速度的计算机来说，每秒钟可以验证数个顶点，每天可以验证数万人。算法在空间上需要借助数组visited和队列Q，因而空间复杂度为O(n)

