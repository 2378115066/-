# 一、线性表的定义和特点

在日常生活中，线性表的例子比比皆是。例如，26个英文字母的字母表：

​		（A，B，C，…，Z）

是一个线性表，表中的数据元素是单个字母。在稍复杂的线性表中，一个数据元素可以包含若干个数据项。例如在第1章中提到的学生基本信息表，每个学生为一个数据元素，包括学号、姓名、性别、籍贯、专业等数据项。

由以上示例可以看出，它们的数据元素虽然不同，但同一线性表中的元素必定具有相同的特性，即属于同一数据对象，相邻数据元素之间存在着序偶关系。

诸如此类由n（n≥0）个数据特性相同的元素构成的有限序列称为**线性表**

线性表中元素的个数n（n≥0）定义为线性表的长度，n=0时称为**空表**

对于非空的线性表或线性结构，其特点是：

```
1）存在唯一的一个被称作“第一个”的数据元素
2）存在唯一的一个被称作“最后一个”的数据元素
3）除第一个之外，结构中的每个数据元素均只有一个前驱
4）除最后一个之外，结构中的每个数据元素均只有一个后继
```

#### a.一元多项式的运算
```
在数学上，一个一元多项式Pn(x)可按升幂写成：
				Pn(x)=p0+p1x+p2x2+…+pnxn
要求：实现两个一元多项式的相加、相减和相乘的运算

实现两个多项式相关运算的前提是如何在计算机中有效地表示一元多项式，进而在此基础上设计相关运算的算法？这个问题看似很复杂，我们通过学习本章中线性表的表示及其相关运算便可以完成。

可以看出，一元多项式可由n+1个系数唯一确定，因此，可以将一元多项式Pn(x)抽象为一个由n+1个元素组成的有序序列，可用一个线性表P来表示：
		P=(p0,p1,p2,…,pn)
这时，每一项的指数i隐含在其系数pi的序号中。

假设Qm(x)是一元m次多项式，同样可用线性表Q来表示：
		Q=(q0,q1,q2,…,qm)
不失一般性，设m ≤ n，则两个多项式相加的结果Rn(x)=Pn(x)+Qm(x)可用线性表R表示：
				R=(p0+q0,p1+q1,p2+q2,…,pm+qm,pm+1,…,pn)

在后面的叙述中将看到，对此类多项式的线性表只需要用数组表示的顺序存储结构便很容易实现上述运算。

然而，在通常的应用中，多项式的次数可能很高且变化很
大，这种所谓的稀疏多项式如果采用上述表示方法，将使得线性表中出现很多零元素。下面给出稀疏多项式的例子。
```

#### b.稀疏多项式的运算
```
例如，在处理形如:
		S(x)=1+3x10000+2x20000

的多项式时，就要用一个长度为20001的线性表来表示，而表中仅有3个非零元素，此时将会造成存储空间的很大浪费，这种对空间的浪费是应当避免的。由于线性表的元素可以包含多个数据项，由此可改变元素设定，对多项式的每一项，可用（系数，指数）唯一确定

一般情况下的一元n次多项式可写成
```

![image-20240719151105267](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240719151105267.png)

其中，pi是指数为ei的项的非零系数，且满足0 ≤ e1 < e2 < … < em=n若用一个长度为m且每个元素有两个数据项（系数项和指数项）的线性表

![image-20240719151155123](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240719151155123.png)

便可唯一确定多项式Pn(x)。在最坏情况下，n+1(=m)个系数都不为零，则比只存储每项系数的方案要多存储一倍的数据。但是，对于类似S(x)的稀疏多项式，这种表示将大大节省空间。由上述讨论可以看出，如果多项式属于非稀疏多项式，且只对多项式进行“求值”等不改变多项式的系数和指数的运算，可采用数组表示的顺序存储结构。如果多项式属于稀疏多项式，虽然可以采用数组表示法，但这种顺序存储结构的存储空间分配不够灵活。因为事先无法确定多项式的非零项数，所以需要根据预期估计可能的最大值定义数组的大小，这种分配方式可能会带来两种问题：一种是实际非零项数比较小，浪费了大量存储空间；另一种是实际非零项式超过了最大值，存储空间不够。另外在实现多项式的相加运算时，还需要开辟一个新的数组保存结果多项式，导致算法的空间复杂度较高。改进方案是利用链式存储结构表示多项式的有序序列，这样灵活性更大些

#### c.图书信息管理系统
```
出版社有一些图书数据保存在一个文本文件book.txt中，为简单起见，在此假设每种图书只包括三部分信息：ISBN（书号）、书名和价格，

现要求实现一个图书信息管理系统，包括以下6个具体功能。
        1）查找：根据指定的ISBN或书名查找相应图书的有关信息，并返回该图书在表中的位置序号
        2）插入：插入一种新的图书信息
        3）删除：删除一种图书信息
        4）修改：根据指定的ISBN，修改该图书的价格
        5）排序：将图书按照价格由低到高进行排序
        6）计数：统计图书表中的图书数量

要实现上述功能，与以上案例中的多项式一样，我们首先根据图书表的特点将其抽象成一个线性表，每本图书作为线性表中的一个元素，然后可以采用适当的存储结构来表示该线性表，在此基础上设计完成有关的功能算法。具体采取哪种存储结构，可以根据两种不同存储结构的优缺点，视实际情况而定。
可以看出，在工作和生活中的许多实际应用问题都会涉及图书信息管理中用到的这些基本操作。这些问题中都包含由n个数据特性相同的元素，即可以表示为线性表。不同的问题所涉元素的数据类型不尽相同，可以为简单数据类型（如案例2.1所示的一元多项式表示），也可以为复杂数据类型（如案例2.2所示的稀疏多项式表示和案例2.3中的图书数据），但这些问题所涉的基本操作都具有很大的相似性，如果为每个具体应用都编一个程序显然不是一种很好的方法。解决这类问题的最好方法就是从具体应用中抽象出共性的逻辑结构和基本操作（即抽象数据类型），然后采用程序设计语言实现相应的存储结构和基本操作。
```

![image-20240719093426128](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240719093426128.png)

# 二、线性表的类型定义
线性表是一个相当灵活的数据结构，其长度可根据需要增长或缩短，即对线性表的数据元素不仅可以进行访问，而且可以进行插入和删除等操作。为不失**一般性**，

##### 线性表的抽象数据类型定义：
```c
ADT List{
  数据对象：D={ai|ai∈ElemSet,i=1,2,…,n,n≥0}
  数据关系：R={<ai-1,ai>|ai-1,ai∈D,i=2,…,n}
  基本操作：
    InitList(&L)
      操作结果：构造一个空的线性表L。
    DestroyList(&L)
      初始条件：线性表L已存在。
      操作结果：销毁线性表L。
    ClearList(&L)
      初始条件：线性表L已存在。
      操作结果：将L重置为空表。
    ListEmpty(L)
      初始条件：线性表L已存在。
      操作结果：若L为空表，则返回true，否则返回false。
    ListLength(L)
      初始条件：线性表L已存在。
      操作结果：返回L中数据元素个数。
    GetElem(L,i,&e)
      初始条件：线性表L已存在，且1≤i≤ListLength(L)。
      操作结果：用e返回L中第i个数据元素的值。
    LocateElem(L,e)
      初始条件：线性表L已存在。
      操作结果：返回L中第1个值与e相同的元素在L中的位置。若这样的数据元素不存在，则返回值为0。
    PriorElem(L,cur_e,&pre_e)
      初始条件：线性表L已存在。
      操作结果：若cur_e是L的数据元素，且不是第一个，则用pre_e返回其前驱，否则操作失败，pre_e无定义。
    NextElem(L,cur_e,&next_e)
      初始条件：线性表L已存在。
      操作结果：若cur_e是L的数据元素，且不是最后一个，则用next_e返回其后继，否则操作失败，next_e无定义。
    ListInsert(&L,i,e)
      初始条件：线性表L已存在，且1≤i≤ListLength(L)+1。
      操作结果：在L中第i个位置之前插入新的数据元素e，L的长度加1。
    ListDelete(&L,i)
      初始条件：线性表L已存在且非空，且l≤i≤ListLength(L)。
      操作结果：删除L的第i个数据元素，L的长度减1。
    TraverseList(L)
      初始条件：线性表L已存在。
      操作结果：对线性表L进行遍历，在遍历过程中对L的每个结点访问一次。
}ADT List
```

**说明**
```
1）抽象数据类型仅是一个模型的定义，并不涉及模型的具体实现，因此这里描述中所涉及的参数不必考虑具体数据类型。在实际应用中，数据元素可能有多种类型，到时可根据具体需要选择使用不同的数据类型

2）上述抽象数据类型中给出的操作只是基本操作，由这些基本操作可以构成其他较复杂的操作。
例如，2.2节中的两个应用实例，不论是一元多项式的运算还是图书的管理，首先都需要将数据元素读入，生成一个包括所需数据的线性表，这属于线性表的创建。这项操作可首先调用基本操作定义中的InitList(&L)构造一个空的线性表L，然后反复调用ListInsert(&L,i,e)在表中插入元素e，就可以创建一个需要的线性表。同样，对于一元多项式的运算可以看作是线性表的合并，合并过程需要不断地进行元素的插入操作。其他如求线性表的拆分、复制等操作也都可以利用上述基本操作的组合来实现

3）对于不同的应用，基本操作的接口可能不同。例如，案例2.2的删除操作，如果要求删除图书表中ISBN为x的图书，首先需要根据x确定该图书在线性表中的位置，然后再利用ListDelete(&L,i)基本操作将该种图书记录从表中删除

4）由抽象数据类型定义的线性表，可以根据实际所采用的存储结构形式，进行具体的表示和实现
```

# 三、线性表的顺序表示和实现

## 1).线性表的顺序表示和实现

线性表的顺序表示指的是用一组地址连续的存储单元依次存储线性表的数据元素，这种表示也称作线性表的顺序存储结构或顺序映像。

通常，称这种存储结构的线性表为**顺序表**（Sequential List）。其特点是，逻辑上相邻的数据元素，其物理次序也是相邻的

假设线性表的每个元素需占用l个存储单元，并以所占的第一个单元的存储地址作为数据元素的存储起始位置。则线性表中第i+1个数据元素的存储位置LOC(ai+1)和第i个数据元素的存储位置LOC(ai)之间满足下列关系：

```
LOC(ai+1)=LOC(ai)+l
```

一般来说，线性表的第i个数据元素ai的存储位置为：

```
LOC(ai)=LOC(a1)+(i−1) × l
```

式中，LOC(a1)是线性表的第一个数据元素a1的存储位置，通常称作线性表的起始位置或基地址，表中相邻的元素ai和ai+1的存储位置LOC(ai)和LOC(ai+1)是相邻的。每一个数据元素的存储位置都和线性表的起始位置相差一个常数，这个常数和数据元素在线性表中的位序成正比。**由此，只要确定了存储线性表的起始位置，线性表中任一数据元素都可随机存取，所以线性表的顺序存储结构是一种随机存取的存储结构。**

![image-20240719093637295](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240719093637295.png)

由于高级程序设计语言中的数组类型也有随机存取的特性，因此，通常都用数组来描述数据结构中的顺序存储结构。在此，由于线性表的长度可变，且所需最大存储空间随问题不同而不同，则在C语言中可用动态分配的一维数组表示线性表，描述如下：

```c
//- - - - - 顺序表的存储结构- - - - -
#define MAXSIZE 100                     //顺序表可能达到的最大长度
typedef struct
{
   ElemType *elem;                      //存储空间的基地址
   int length;                          //当前长度
}SqList;                                //顺序表的结构类型为SqList
```

##### 说明

```
1）数组空间通过后面算法2.1初始化动态分配得到，初始化完成后，数组指针elem指示顺序表的基地址，数组空间大小为MAXSIZE

2）元素类型定义中的ElemType数据类型是为了描述统一而自定的，在实际应用中，用户可根据实际需要具体定义表中数据元素的数据类型，既可以是基本数据类型，如int、float、char等，也可以是构造数据类型，如struct结构体类型

3）length表示顺序表中当前数据元素的个数。因为C语言数组的下标是从0开始的，而位置序号是从1开始的，所以要注意区分元素的位置序号和该元素在数组中的下标位置之间的对应关系，数据元素a1、a2、…、an依次存放在数组elem[0]、elem[1]、…、elem[length-1]中。
```

用顺序表存储案例的稀疏多项式数据时，其顺序存储分配情况所示。多项式的顺序存储结构的类型定义如下：

![image-20240719093716902](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240719093716902.png)

```c
#define MAXSIZE 100                     //多项式可能达到的最大长度
typedef struct                          //多项式非零项的定义
{
   float  coef;                         //系数
   int   expn;                          //指数
}Polynomial;
typedef struct
{
   Polynomial *elem;                    //存储空间的基地址
   int length;                          //多项式中当前项的个数
}SqList;                                //多项式的顺序存储结构类型为SqList
```

用顺序表存储案例2.3的图书数据时，其顺序存储分配情况如图2.4所示。图书表的顺序存储结构的类型定义如下：

![image-20240719093744086](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240719093744086.png)

```c
#define MAXSIZE 10000                   //图书表可能达到的最大长度
typedef struct                          //图书信息定义
{
   char no[20];                         //图书ISBN
   char name[50];                       //图书名字
   float price;                         //图书价格
}Book;
typedef struct
{
   Book *elem;                          //存储空间的基地址
   int length;                          //图书表中当前图书个数
}SqList;                                //图书表的顺序存储结构类型为SqList
```

在上述定义后，可以通过变量定义语句

```c
SqList L;
```

将L定义为SqList类型的变量，便可以利用L.elem[i-1]访问表中位置序号为i的的图书记录。

## 2).顺序表中基本操作的实现

可以看出，当线性表以上述定义的顺序表表示时，某些操作很容易实现。因为表的长度是顺序表的一个“属性”，所以可以通过返回length的值实现求表长的操作，通过判断length的值是否为0判断表是否为空，这些操作算法的时间复杂度都是O(1)。下面讨论顺序表其他几个主要操作的实现。

### 1．初始化

```
顺序表的初始化操作就是构造一个空的顺序表。
```

###### 【算法步骤】

```
1).为顺序表L动态分配一个预定义大小的数组空间，使elem指向这段空间的基地址
2).将表的当前长度设为0
```

###### 【算法描述】

```c
Status InitList(SqList &L)
{//构造一个空的顺序表L
   L.elem=new ElemType[MAXSIZE];                //为顺序表分配一个大小为MAXSIZE的数组空间
   if(!L.elem) exit(OVERFLOW);                  //存储分配失败退出
   L.length=0;                                  //空表长度为0
   return OK;
}
```

动态分配线性表的存储区域可以更有效地利用系统的资源，当不需要该线性表时，可以使用销毁操作及时释放占用的存储空间

### 2．取值

取值操作是根据指定的位置序号i，获取顺序表中第i个数据元素的值。

由于顺序存储结构具有随机存取的特点，可以直接通过数组下标定位得到，elem[i-1]单元存储第i个数据元素

###### 【算法步骤】

```
1).判断指定的位置序号i值是否合理（1≤i≤L.length），若不合理，则返回ERROR

2).若i值合理，则将第i个数据元素L.elem[i-1]赋给参数e，通过e返回第i个数据元素的传值。【算法描述】
```

###### 【算法描述】

```c
Status GetElem(SqList L,int i,ElemType &e)
{
   if (i<1||i>L.length) return ERROR;          //判断i值是否合理，若不合理，返回ERROR
   e=L.elem[i-1];                            //elem[i-1]单元存储第i个数据元素
   return OK;
}
```

##### 顺序表取值: 算法的时间复杂度为O(1)

### 3．查找

查找操作是根据指定的元素值e，查找顺序表中第1个与e相等的元素。若查找成功，则返回该元素在表中的位置序号；若查找失败，则返回0

###### 【算法步骤】

```
1).从第一个元素起，依次和e相比较，若找到与e相等的元素L.elem[i]，则查找成功，返回该元素的序号i+1
2).若查遍整个顺序表都没有找到，则查找失败，返回0。
```

###### 【算法描述】

```c
int LocateElem(SqList L,ElemType e)
{//在顺序表L中查找值为e的数据元素，返回其序号
   for(i=0;i< L.length;i++)
     if(L.elem[i]==e) return i+1;               //查找成功，返回序号i+1
   return 0;                                    //查找失败，返回0
}
```

###### 【算法分析】

当在顺序表中查找一个数据元素时，其时间主要耗费在数据的比较上，而比较的次数取决于被查元素在线性表中的位置。在查找时，为确定元素在顺序表中的位置，需和给定值进行比较的数据元素个数的期望值称为查找算法在查找成功时的平均查找长度（Average Search Length，ASL）。

假设pi是查找第i个元素的概率，Ci为找到表中其关键字与给定值相等的第i个记录时，和给定值已进行过比较的关键字个数，则在长度为n的线性表中，查找成功时的平均查找长度为

![image-20240719152159770](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240719152159770.png)

从顺序表查找的过程可见，Ci取决于所查元素在表中的位置。例如，查找表中第一个记录时，仅需比较一次；而查找表中最后一个记录时，则需比较n次。一般情况下Ci等于i

假设每个元素的查找概率相等，即

​		pi=1/n

则式（2-3）可简化为式（2-4)由此可见，

![image-20240719152316862](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240719152316862.png)

##### 顺序表按值查找算法的平均时间复杂度为O(n)。

### 4．插入

线性表的插入操作是指在表的第i个位置插入一个新的数据元素e，使长度为n的线性表(a1,…,ai−1,ai,…,an)

变成长度为n+1的线性表

(a1,…,ai−1,e, ai,…,an)

数据元素ai−1和ai之间的逻辑关系发生了变化。在线性表的顺序存储结构中，由于逻辑上相邻的数据元素在物理位置上也是相邻的，因此，除非i=n+1，否则必须移动元素才能反映这个逻辑关系的变化。

例如，图2.5所示为一个线性表在插入前后数据元素在存储空间中的位置变化。为了在线性表的第5个位置上插入一个值为25的数据元素，则需将第5个至第8个数据元素依次向后移动一个位置

![image-20240719152348480](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240719152348480.png)

一般情况下，在第i（1≤i≤n）个位置插入一个元素时，需从最后一个元素即第n个元素开始，依次向后移动一个位置，直至第i个元素（共n−i+1个元素）

###### 【算法步骤】

```c
1).判断插入位置i是否合法（i值的合法范围是1≤i≤n+1），若不合法则返回ERROR
2).判断顺序表的存储空间是否已满，若满则返回ERROR
3).将第n个至第i个位置的元素依次向后移动一个位置，空出第i个位置（i=n+1时无需移动）
4).将要插入的新元素e放入第i个位置
5).表长加1。
```

###### 【算法描述】

```c
Status ListInsert(SqList &L,int i ,ElemType e)
{//在顺序表L中第i个位置插入新的元素e，i值的合法范围是1≤i≤L.length+1
   if((i<1)||(i>L.length+1)) return ERROR;                        //i值不合法
   if(L.length==MAXSIZE) return ERROR;                        //当前存储空间已满
   for(j=L.length-1;j>=i-1;j--)
     L.elem[j+1]=L.elem[j];                              //插入位置及之后的元素后移
   L.elem[i-1]=e;                                        //将新元素e放入第i个位置
   ++L.length;                                                  //表长加1
   return OK;
}
```

上述算法没有处理表的动态扩充，因此当表长已经达到预设的最大空间时，则不能再插入元素。

###### 【算法分析】

当在顺序表中某个位置上插入一个数据元素时，其时间主要耗费在移动元素上，而移动元素的个数取决于插入元素的位置。

假设pi是在第i个元素之前插入一个元素的概率，Eins为在长度为n的线性表中插入一个元素时所需移动元素次数的期望值（平均次数），则有

![image-20240719152444151](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240719152444151.png)

不失一般性，可以假定在线性表的任何位置上插入元素都是等概率的，即

![image-20240719152506155](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240719152506155.png)

则式（2-5）可简化为式（2-6）

![image-20240719152527363](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240719152527363.png)

由此可见，顺序表插入算法的平均时间复杂度为O(n)。

### 5．删除

线性表的删除操作是指将表的第i个元素删去，将长度为n的线性表

(a1,…,ai−1,ai，ai+1,…,an)

变成长度为n−1的线性表

(a1,…,ai−1,ai+1,…,an)

数据元素ai−1、ai和ai+1之间的逻辑关系发生了变化，为了在存储结构上反映这个变化，同样需要移动元素。如图所示，为了删除第4个数据元素，必须将第5个至第8个元素都依次向前移动一个位置。

![image-20240719152557168](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240719152557168.png)

注意

```
一般情况下，删除第i（1≤i≤n）个元素时需将第i+1个至第n个元素（共n−i个元素）依次向前移动一个位置（i=n时无需移动）
```

###### 【算法步骤】

```
1).判断删除位置i是否合法（合法值为1≤i≤n），若不合法则返回ERROR
2).将第i+1个至第n个的元素依次向前移动一个位置（i=n时无需移动）
3).表长减1
```

###### 【算法描述】

```c
Status ListDelete(SqList &L,int i)
{//在顺序表L中删除第i个元素，i值的合法范围是1≤i≤L.length
   if((i<1)||(i>L.length)) return ERROR; //i值不合法
   for(j=i;j<=L.length-1;j++)
     L.elem[j-1]=L.elem[j];                      //被删除元素之后的元素前移
   --L.length;                                   //表长减1
   return OK;
}
```

###### 【算法分析】

当在顺序表中某个位置上删除一个数据元素时，其时间主要耗费在移动元素上，而移动元素的个数取决于删除元素的位置。

假设pi是删除第i个元素的概率，Edel为在长度为n的线性表中删除一个元素时所需移动元素次数的期望值（平均次数），则有

![image-20240719153458181](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240719153458181.png)

不失一般性，可以假定在线性表的任何位置上删除元素都是等概率的，即

![image-20240719153520756](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240719153520756.png)

则式（2-7）简化为式（2-8）

![image-20240719153544499](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240719153544499.png)

##### 由此可见，顺序表删除算法的平均时间复杂度为O(n)

### 6.  总结

顺序表可以随机存取表中任一元素，其存储位置可用一个简单、直观的公式来表示。

然而，从另一方面来看，这个特点也造成了这种存储结构的缺点：在做插入或删除操作时，需移动大量元素。另外由于数组有长度相对固定的静态特性，当表中数据元素个数较多且变化较大时，操作过程相对复杂，必然导致存储空间的浪费

# 四、线性表的链式表示和实现

## 1).单链表的定义和表示

线性表链式存储结构的特点是：用一组任意的存储单元存储线性表的数据元素（这组存储单元可以是连续的，也可以是不连续的）。因此，为了表示每个数据元素ai与其直接后继数据元素ai+1之间的逻辑关系，对数据元素ai来说，除了存储其本身的信息之外，还需存储一个指示其直接后继的信息（即直接后继的存储位置）。这两部分信息组成数据元素ai的存储映像，称为结点（node）。它包括两个域：其中存储数据元素信息的域称为数据域；存储直接后继存储位置的域称为指针域。指针域中存储的信息称作指针或链。n个结点（ai（1≤i≤n）的存储映像）链结成一个链表，即为线性表

​				(a1, a2,…, an)

的链式存储结构。又由于此链表的每个结点中只包含一个指针域，故又称**线性链表**或**单链表**

根据链表结点所含指针个数、指针指向和指针连接方式，可将链表分为单链表、循环链表、双向链表、二叉链表、十字链表、邻接表、邻接多重表等。其中单链表、循环链表和双向链表用于实现线性表的链式存储结构，其他形式多用于实现树和图等非线性结构。

![image-20240719154525617](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240719154525617.png)

为线性表的单链表存储结构，整个链表的存取必须从头指针开始进行，头指针指示链表中第一个结点（即第一个数据元素的存储映像，也称首元结点）的存储位置。同时，由于最后一个数据元素没有直接后继，则单链表中最后一个结点的指针为空（NULL）

用单链表表示线性表时，数据元素之间的逻辑关系是由结点中的指针指示的。换句话说，指针为数据元素之间的逻辑关系的映像，则逻辑上相邻的两个数据元素其存储的物理位置不要求紧邻，由此，这种存储结构为非顺序映像或链式映像

通常将链表画成用箭头相链接的结点的序列，结点之间的箭头表示链域中的指针。图1所示的单链表可画成如图2所示的形式，这是因为在使用链表时，关心的只是它所表示的线性表中数据元素之间的逻辑顺序，而不是每个数据元素在存储器中的实际位置

![image-20240719154749414](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240719154749414.png)

由上述可见，单链表可由头指针唯一确定，在C语言中可用“结构指针”来描述：

```c
//- - - - - 单链表的存储结构- - - - -
typedef struct  LNode
{
   ElemType  data;                            //结点的数据域
   struct LNode  *next;                       //结点的指针域
}LNode,*LinkList;                             //LinkList为指向结构体LNode的指针类型
```

###### 说明：
```
1).这里定义的是单链表中每个结点的存储结构，它包括两部分：存储结点的数据域data，其类型用通用类型标识符ElemType表示（例如，用链表表示案例中的图书信息时，只需将ElemType替换为2.4.1定义的Book数据类型即可）；存储后继结点位置的指针域next，其类型为指向结点的指针类型LNode *
2).为了提高程序的可读性，在此对同一结构体指针类型起了两个名称，LinkList与LNode *，两者本质上是等价的。通常习惯上用LinkList定义单链表，强调定义的是某个单链表的头指针；用LNode *定义指向单链表中任意结点的指针变量。例如，若定义LinkList L，则L为单链表的头指针，若定义LNode *p，则p为指向单链表中某个结点的指针，用*p代表该结点。当然也可以使用定义LinkList p，这种定义形式完全等价于LNode *p
3).单链表是由表头指针唯一确定的，因此单链表可以用头指针的名字来命名。若头指针名是L，则简称该链表为表L
4)。注意区分指针变量和结点变量两个不同的概念，若定义LinkList p或LNode *p，则p为指向某结点的指针变量，表示该结点的地址；而*p为对应的结点变量，表示该结点的名称。
```
一般情况下，为了处理方便，在单链表的第一个结点之前附设一个结点，称之为头结点。图2.8所示的单链表增加头结点后如图3所示

![image-20240719154907006](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240719154907006.png)
​						增加头结点的单链表的逻辑状态

###### 说明（首元结点、头结点、头指针）：

```
1).首元结点是指链表中存储第一个数据元素a1的结点。如图2.8或图2.9所示的结点“ZHAO”

2).头结点是在首元结点之前附设的一个结点，其指针域指向首元结点。头结点的数据域可以不存储任何信息，也可存储与数据元素类型相同的其他附加信息。例如，当数据元素为整数型时，头结点的数据域中可存放该线性表的长度

3).头指针是指向链表中第一个结点的指针。若链表设有头结点，则头指针所指结点为线性表的头结点；若链表不设头结点，则头指针所指结点为该线性表的首元结点
```

##### 链表增加头结点的作用如下

###### （1）便于首元结点的处理

```
增加了头结点后，首元结点的地址保存在头结点(即其“前驱”结点)的指针域中，则对链表的第一个数据元素的操作与其他数据元素相同，无需进行特殊处理
```

###### （2）便于空表和非空表的统一处理

```
当链表不设头结点时，假设L为单链表的头指针，它应该指向首元结点，则当单链表为长度n为0的空表时，L指针为空（判定空表的条件可记为：L==NULL）
```

增加头结点后，无论链表是否为空，头指针都是指向头结点的非空指针。如图3.a所示的非空单链表，头指针指向头结点。若为空表，则头结点的指针域为空（判定空表的条件可记为：L−>next==NULL），如图3.b所示

![image-20240719155101341](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240719155101341.png)

在顺序表中，由于逻辑上相邻的两个元素在物理位置上紧邻，则每个元素的存储位置都可从线性表的起始位置计算得到。而在单链表中，各个元素的存储位置都是随意的。然而，每个元素的存储位置都包含在其直接前驱结点的信息之中。假设p是指向单链表中第i个数据元素（结点ai，即数据域为ai的结点）的指针，则p−>next是指向第i+1个数据元素（结点ai+1）的指针。换句话说，若p−>data=ai，则p−>next−>data=ai+1。由此，单链表是非随机存取的存储结构，要取得第i个数据元素必须从头指针出发顺链进行寻找，也称为顺序存取的存取结构。因此，其基本操作的实现不同于顺序表。

## 2).单链表基本操作的实现

1．初始化单链表的初始化操作就是构造一个如图3（b）所示的空表

###### 【算法步骤】

```
1).生成新结点作为头结点，用头指针L指向头结点
2).头结点的指针域置空
```

###### 【算法描述】

```c
Status InitList(LinkList &L)
{//构造一个空的单链表L
   L=new LNode;        //生成新结点作为头结点，用头指针L指向头结点
   L->next=NULL;     //头结点的指针域置空
   return OK;
}
```

### 2．取值

和顺序表不同，链表中逻辑相邻的结点并没有存储在物理相邻的单元中，这样，根据给定的结点位置序号i，在链表中获取该结点的值不能像顺序表那样随机访问，而只能从链表的首元结点出发，顺着链域next逐个结点向下访问

###### 【算法步骤】

```
1).用指针p指向首元结点，用j做计数器初值赋为1
2).从首元结点开始依次顺着链域next向下访问，只要指向当前结点的指针p不为空（NULL），并且没有到达序号为i的结点，则循环执行以下操作：
					p指向下一个结点
					计数器j相应加1
3).退出循环时，如果指针p为空，或者计数器j大于i，说明指定的序号i值不合法（i大于表长n或i小于等于0），取值失败返回ERROR；否则取值成功，此时j=i时，p所指的结点就是要找的第i个结点，用参数e保存当前结点的数据域，返回OK
```

###### 【算法描述】

```c
Status GetElem(LinkList L,int i,ElemType &e)
{//在带头结点的单链表L中根据序号i获取元素的值，用e返回L中第i个数据元素的值
   p=L->next;j=1;                       //初始化，p指向首元结点，计数器j初值赋为1
   while(p&&j<i)                         //顺链域向后扫描，直到p为空或p指向第i个元素
   {
      p=p->next;                             //p指向下一个结点
      ++j;                                   //计数器j相应加1
   }
   if(!p||j>i)return ERROR;  //i值不合法i>n或i≤0
   e=p->data;                                //取第i个结点的数据域
   return OK;
}
```

【算法分析】

该算法的基本操作是比较j和i并后移指针p，while循环体中的语句频度与位置i有关。若1≤i≤n，则频度为i−1，一定能取值成功；若i>n，则频度为n，取值失败。因此算法2.7的最坏时间复杂度为O(n)。假设每个位置上元素的取值概率相等，即

​					pi=1/n

则

![image-20240719155423320](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240719155423320.png)

由此可见，单链表取值算法的平均时间复杂度为O(n)。

### 3．查找

链表中按值查找的过程和顺序表类似，从链表的首元结点出发，依次将结点值和给定值e进行比较，返回查找结果

###### 【算法步骤】

```
						
1).用指针p指向首元结点
2).从首元结点开始依次顺着链域next向下查找，只要指向当前结点的指针p不为空，并且p所指结点的数据域不等于给定值e，则循环执行以下操作：p指向下一个结点
3).返回p。若查找成功，p此时即为结点的地址值，若查找失败，p的值即为NULL
```

###### 【算法描述】

```c
LNode *LocateElem(LinkList L，ElemType e)
{//在带头结点的单链表L中查找值为e的元素
   p=L->next;                                        //初始化，p指向首元结点
   while(p && p->data!=e)         //顺链域向后扫描，直到p为空或p所指结点的数据域等于e
      p=p->next;                                     //p指向下一个结点
   return p;                          //查找成功返回值为e的结点地址p，查找失败p为NULL
}
```

【算法分析】

```
该算法的执行时间与待查找的值e相关，其平均时间复杂度分析类似于算法2.7，也为O(n)
```

### 4．插入

假设要在单链表的两个数据元素a和b之间插入一个数据元素x，已知p为其单链表存储结构中指向结点a的指针，如图4（a）所示。

![image-20240719155548976](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240719155548976.png)

​						在单链表中插入结点时指针变化状况

为插入数据元素x，首先要生成一个数据域为x的结点，然后插入到单链表中。根据插入操作的逻辑定义，还需要修改结点a中的指针域，令其指向结点x，而结点x中的指针域应指向结点b，从而实现3个元素a、b和x之间逻辑关系的变化。插入后的单链表如图4（b）所示。假设s为指向结点x的指针，则上述指针修改用语句描述即为

```c
s->next=p->next;  p->next=s;
```

###### 【算法步骤】

```
将值为e的新结点插入到表的第i个结点的位置上，即插入到结点ai-1与ai之间，具体插入过程如图2.12所示，图中对应的5个步骤说明如下① 查找结点ai−1并由指针p指向该结点。② 生成一个新结点*s。③ 将新结点*s的数据域置为e。④ 将新结点*s的指针域指向结点ai。⑤ 将结点*p的指针域指向新结点*s。
```

###### 【算法描述】

```c
Status ListInsert(LinkList &L,int i,ElemType e)
{//在带头结点的单链表L中第i个位置插入值为e的新结点
   p=L;j=0;
   while(p && (j<i−1))
      {p=p->next;++j;}                           //查找第i−1个结点，p指向该结点
   if(!p||j>i−1) return ERROR;                  //i>n+1或者i<1
   s=new LNode;                                 //生成新结点*s
   s->data=e;                                   //将结点*s的数据域置为e
   s->next=p->next;                             //将结点*s的指针域指向结点ai
   p->next=s;                                   //将结点*p的指针域指向结点*s
   return OK;
}
```

###### 说明:

```
和顺序表一样，如果表中有n个结点，则插入操作中合法的插入位置有n+1个，即1≤i≤n+1。当i=n+1时，新结点则插在链表尾部。
```

###### 【算法分析】

单链表的插入操作虽然不需要像顺序表的插入操作那样需要移动元素，但平均时间复杂度仍为O(n)。这是因为，为了在第i个结点之前插入一个新结点，必须首先找到第i−1个结点，其时间复杂度与算法2.7相同，为O(n)

![image-20240719155659828](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240719155659828.png)

​						在单链表第i个位置上插入新结点的过程

### 5．删除

要删除单链表中指定位置的元素，同插入元素一样，首先应该找到该位置的前驱结点。如图2.13所示，在单链表中删除元素b时，应该首先找到其前驱结点a。为了在单链表中实现元素a、b和c之间逻辑关系的变化，仅需修改结点a中的指针域即可。假设p为指向结点a的指针，则修改指针的语句为

![image-20240719155733596](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240719155733596.png)

​							在单链表中删除结点时指针的变化

```
p->next=p->next->next;
```

但在删除结点b时，除了修改结点a的指针域外，还要释放结点b所占的空间，所以在修改指针前，应该引入另一指针q，临时保存结点b的地址以备释放

###### 【算法步骤】

```
删除单链表的第i个结点ai的具体过程如图所示，图中的对应的4个步骤说明如下:
1).查找结点ai−1并由指针p指向该结点
2).临时保存待删除结点ai的地址在q中，以备释放
3).将结点*p的指针域指向ai的直接后继结点
4).释放结点ai的空间。
```

![image-20240719155812528](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240719155812528.png)
​							删除单链表第i个结点的过程

###### 【算法描述】
```c

Status ListDelete(LinkList &L,int i)
{//在带头结点的单链表L中，删除第i个元素
   p=L;j=0;
   while((p->next) && (j<i-1))                       //查找第i−1个结点，p指向该结点
     {p=p->next;++j;}
   if(!(p->next)||(j>i-1)) return ERROR;            //当i>n或i<1时，删除位置不合理
   q=p->next;                                       //临时保存被删结点的地址以备释放
   p->next=q->next;                                 //改变删除结点前驱结点的指针域
   delete q;                                        //释放删除结点的空间
   return OK;
}
```

###### 说明

```
删除算法中的循环条件(p->next&&j<i-1)和插入算法中的循环条件(p&&(j<i−1))是有所区别的。因为插入操作中合法的插入位置有n+1个，而删除操作中合法的删除位置只有n个，如果使用与插入操作相同的循环条件，则会出现引用空指针的情况，使删除操作失败
```

##### 算法时间复杂度亦为O(n)

### 6．创建单链表

链表和顺序表不同，它是一种动态结构。整个可用存储空间可为多个链表共同享用，每个链表占用的空间不需预先分配划定，而是由系统按需即时生成。因此，建立线性表的链式存储结构的过程就是一个动态生成链表的过程。即从空表的初始状态起，依次建立各元素结点，并逐个插入链表

根据结点插入位置的不同，链表的创建方法可分为前插法和后插法。

#### （1）前插法

前插法是通过将新结点逐个插入链表的头部（头结点之后）来创建链表，每次申请一个新结点，读入相应的数据元素值，然后将新结点插入到头结点之后

###### 【算法步骤】

```
1).创建一个只有头结点的空链表
2).根据待创建链表包括的元素个数n，循环n次执行以下操作：
		生成一个新结点*p
		输入元素值赋给新结点*p的数据域
		将新结点*p插入到头结点之后。
```

如图所示为线性表（a,b,c,d,e）前插法的创建过程，因为每次插入在链表的头部，所以应该逆位序输入数据，依次输入e、d、c、b、a，输入顺序和线性表中的逻辑顺序是相反的。

![image-20240719155932711](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240719155932711.png)

​								前插法创建单链表

###### 【算法描述】

```c
void CreateList_H(LinkList &L,int n)
{//逆位序输入n个元素的值，建立带表头结点的单链表L
   L=new LNode;
   L->next=NULL;                                    //先建立一个带头结点的空链表
   for(i=0;i<n;++i)
   {
     p=new LNode;                                   //生成新结点*p
     cin>>p->data;                                 //输入元素值赋给新结点*p的数据域
     p->next=L->next;L->next=p;                    //将新结点*p插入到头结点之后
   }
}
```

![image-20240719174537302](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240719174537302.png)

###### 时间复杂度为O(n)

#### （2）后插法

后插法是通过将新结点逐个插入到链表的尾部来创建链表。同前插法一样，每次申请一个新结点，读入相应的数据元素值。不同的是，为了使新结点能够插入到表尾，需要增加一个尾指针r指向链表的尾结点

###### 【算法步骤】

```
1).创建一个只有头结点的空链表
2).尾指针r初始化，指向头结点
3).根据创建链表包括的元素个数n，循环n次执行以下操作：
		生成一个新结点*p
		输入元素值赋给新结点*p的数据域
		将新结点*p插入到尾结点*r之后
		尾指针r指向新的尾结点*p
```

如图所示为线性表（a,b,c,d,e）后插法的创建过程，读入数据的顺序和线性表中的逻辑顺序是相同的。

![image-20240719160027691](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240719160027691.png)

​							后插法创建单链表

###### 【算法描述】

```c
void CreateList_R(LinkList &L,int n)
{//正位序输入n个元素的值，建立带表头结点的单链表L
   L=new LNode;
   L->next=NULL;                                    //先建立一个带头结点的空链表
   r=L;                                             //尾指针r指向头结点
   for(i=0;i<n;++i)
   {
      p=new LNode;                                  //生成新结点
      cin>>p->data;                                //输入元素值赋给新结点*p的数据域
      p->next=NULL; r->next=p;                     //将新结点*p插入尾结点*r之后
      r=p;                                         //r指向新的尾结点*p
   }
}
```

![image-20240719175430814](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240719175430814.png)

##### 时间复杂度亦为O(n)

## 3).循环链表

**循环链表**（Circular Linked List）是另一种形式的链式存储结构。其特点是表中最后一个结点的指针域指向头结点，整个链表形成一个环。由此，从表中任一结点出发均可找到表中其他结点，图2.17所示为单链的循环链表。类似地，还可以有多重链的循环链表。

![image-20240719160154177](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240719160154177.png)

​									单循环链表

循环单链表的操作和单链表基本一致，差别仅在于：当链表遍历时，判别当前指针p是否指向表尾结点的终止条件不同。在单链表中，判别条件为p!=NULL或p->next!=NULL，而循环单链表的判别条件为p!=L或p->next!=L

在某些情况下，若在循环链表中设立尾指针而不设头指针（见图（a）），可使一些操作简化。例如，将两个线性表合并成一个表时，仅需将第一个表的尾指针指向第二个表的第一个结点，第二个表的尾指针指向第一个表的头结点，然后释放第二个表的头结点。当线性表以图（a）的循环链表作存储结构时，这个操作仅需改变两个指针值即可，主要语句段如下：

```c
p=B->next->next;
B->next=A->next;
A->next=p;
```

上述操作的时间复杂度为O(1)，合并后的表如图（b）所示。

![image-20240719160239776](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240719160239776.png)

​							仅设尾指针的循环链表

## 4).双向链表

以上讨论的链式存储结构的结点中只有一个指示直接后继的指针域，由此，从某个结点出发只能顺指针向后寻查其他结点。若要寻查结点的直接前驱，则必须从表头指针出发。换句话说，在单链表中，查找直接后继结点的执行时间为O(1)，而查找直接前驱的执行时间为O(n)。为克服单链表这种单向性的缺点，可利用**双向链表**（Double Linked List）

顾名思义，在双向链表的结点中有两个指针域，一个指向直接后继，另一个指向直接前驱，结点结构如图（a）所示，在C语言中可描述如下：

```c
//- - - - - 双向链表的存储结构- - - - -
typedef struct DuLNode
{
   ElemType data;                       //数据域
   struct DuLNode *prior;               //指向直接前驱
   struct DuLNode *next;                //指向直接后继
}DuLNode,*DuLinkList;
```

和单链的循环表类似，双向链表也可以有循环表，如图（c）所示，链表中存有两个环，图（b）所示为只有一个表头结点的空表。

![image-20240719160344025](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240719160344025.png)

在双向链表中，若d为指向表中某一结点的指针（即d为DuLinkList型变量），则显然有\

```c
d->next->prior=d->prior->next=d
```

这个表示方式恰当地反映了这种结构的特性

在双向链表中，有些操作（如ListLength、GetElem和LocateElem等）仅需涉及一个方向的指针，则它们的算法描述和线性链表的操作相同，但在插入、删除时有很大的不同，在双向链表中需同时修改两个方向上的指针，图2.20和图2.21分别显示了插入和删除结点时指针修改的情况。在插入结点时需要修改四个指针，在删除结点时需要修改两个指针。它们的实现分别如算法2.13和算法2.14所示，**两者的时间复杂度均为O(n)**

![image-20240719160405234](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240719160405234.png)

​						图2.20 在双向链表中插入结点时指针的变化状况

![image-20240719160425029](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240719160425029.png)

​						图2.21 在双向链表中删除结点时指针的变化状况

###### 【算法描述】

```c
//双向链表的插入
Status ListInsert_DuL(DuLinkList &L,int i,ElemType e)
{//在带头结点的双向链表L中第i个位置之前插入元素e
   if(!(p=GetElem_DuL(L,i)))              //在L中确定第i个元素的位置指针p
      return ERROR;                       //p为NULL时，第i个元素不存在
   s=new DuLNode;                         //生成新结点*s
   s->data=e;                             //将结点*s数据域置为e
   s->prior=p->prior;                     //将结点*s插入L中，此步对应图2.20①
   p->prior->next=s;                      //对应图2.20②
   s->next=p;                             //对应图2.20③
   p->prior=s;                            //对应图2.20④
   return OK;
}
```

###### 【算法描述】

```c
//双向链表的删除
Status ListDelete_DuL(DuLinkList &L,int i)
{//删除带头结点的双向链表L中的第i个元素
   if(!(p=GetElem_DuL(L,i)))            //在L中确定第i个元素的位置指针p
      return ERROR;                     //p为NULL时，第i个元素不存在
   p->prior->next=p->next;              //修改被删结点的前驱结点的后继指针，对应图2.21①
   p->next->prior=p->prior;             //修改被删结点的后继结点的前驱指针，对应图2.21②
   delete p;                            //释放被删结点的空间
   return OK;
}
```

# 五、顺序表和链表的比较

## 1.空间性能的比较
### 1).存储空间的分配
顺序表的存储空间必须预先分配，元素个数扩充受一定限制，易造成存储空间浪费或空间溢出现象；而链表不需要为其预先分配空间，只要内存空间允许，链表中的元素个数就没有限制

基于此，当线性表的长度变化较大，难以预估存储规模时，宜采用链表作为存储结构

### 2).存储密度的大小
链表的每个结点除了设置数据域用来存储数据元素外，还要额外设置指针域，用来存储指示元素之间逻辑关系的指针，从存储密度上来讲，这是不经济的。所谓**存储密度**是指数据元素本身所占用的存储量和整个结点结构所占用的存储量之比，即
![image-20240719175906835](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240719175906835.png)
存储密度越大，存储空间的利用率就越高。显然，顺序表的存储密度为1，而链表的存储密度小于1。如果每个元素数据域占据的空间较小，则指针的结构性开销就占用了整个结点的大部分空间，这样存储密度较小。例如，若单链表的结点数据均为整数，指针所占用的空间和整型量相同，则单链表的存储密度为0.5。因此，如果不考虑顺序表中的空闲区，则顺序表的存储空间利用率为100%，而单链表的存储空间利用率仅为50%
基于此，当线性表的长度变化不大，易于事先确定其大小时，为了节约存储空间，宜采用顺序表作为存储结构。

## 2.时间性能的比较
### 1).存取元素的效率
顺序表是由数组实现的，它是一种随机存取结构，指定任意一个位置序号i，都可以在O(1)时间内直接存取该位置上的元素，即取值操作的效率高；而链表是一种顺序存取结构，按位置访问链表中第i个元素时，只能从表头开始依次向后遍历链表，直到找到第i个位置上的元素，时间复杂度为O(n)，即取值操作的效率低
基于此，若线性表的主要操作是和元素位置紧密相关的这类取值操作，很少做插入或删除时，宜采用顺序表作为存储结构

### 2).插入和删除操作的效率
对于链表，在确定插入或删除的位置后，插入或删除操作无需移动数据，只需要修改指针，时间复杂度为O(1)。而对于顺序表，进行插入或删除时，平均要移动表中近一半的结点，时间复杂度为O(n)。尤其是当每个结点的信息量较大时，移动结点的时间开销就相当可观
基于此，对于频繁进行插入或删除操作的线性表，宜采用链表作为存储结构

​			顺序表和链表的比较
![image-20240719181225730](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240719181225730.png)
​			单链表、循环链表和双向链表的比较

![image-20240719181240879](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240719181240879.png)
