# 一、查找的基本概念

（1）查找表
**查找表**是由同一类型的数据元素（或记录）构成的集合。由于“集合”中的数据元素之间存在着完全松散的关系，因此查找表是一种非常灵便的数据结构，可以利用其他的数据结构来实现，比如本章将要介绍的线性表、树表及散列表等。

**（2）关键字**
**关键字**是数据元素（或记录）中某个数据项的值，用它可以标识一个数据元素（或记录）。若此关键字可以唯一地标识一个记录，则称此关键字为**主关键字**（对不同的记录，其主关键字均不同）。反之，称用以识别若干记录的关键字为**次关键字**。当数据元素只有一个数据项时，其关键字即为该数据元素的值。
**（3）查找**
查找是指根据给定的某个值，在查找表中确定一个其关键字等于给定值的记录或数据元素。若表中存在这样的一个记录，则称**查找成功**，此时查找的结果可给出整个记录的信息，或指示该记录在查找表中的位置；若表中不存在关键字等于给定值的记录，则称**查找不成功**，此时查找的结果可给出一个“空”记录或“空”指针。
**（4）动态查找表和静态查找表**
若在查找的同时对表做修改操作（如插入和删除），则相应的表称之为**动态查找表**，否则称之为**静态查找表**。换句话说，动态查找表的表结构本身是在查找过程中动态生成的，即在创建表时，对于给定值，若表中存在其关键字等于给定值的记录，则查找成功返回；否则插入关键字等于给定值的记录。
（5）平均查找长度
为确定记录在查找表中的位置，需和给定值进行比较的关键字个数的期望值，称为查找算法在查找成功时的**平均查找长度**（Average Search Length，ASL）。对于含有n个记录的表，查找成功时的平均查找长度为
![image-20240720150034762](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240720150034762.png)
其中，Pi为查找表中第i个记录的概率，且![image-20240720150307731](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240720150307731.png)
Ci为找到表中其关键字与给定值相等的第i个记录时，和给定值已进行过比较的关键字个数。显然，Ci随查找过程不同而不同。

由于查找算法的基本运算是关键字之间的比较操作，所以可用平均查找长度来衡量查找算法的性能

# 二、线性表的查找

## 1.顺序查找
**顺序查找**（Sequential Search）的查找过程为：从表的一端开始，依次将记录的关键字和给定值进行比较，若某个记录的关键字和给定值相等，则查找成功；反之，若扫描整个表后，仍未找到关键字和给定值相等的记录，则查找失败。

顺序查找方法既适用于线性表的顺序存储结构，又适用于线性表的链式存储结构。下面只介绍以顺序表作为存储结构时实现的顺序查找算法

数据元素类型定义如下：

```c
typedef struct{
    KeyType key;                                        //关键字域
    InfoType otherinfo;                                 //其他域
}ElemType;
```

顺序表的定义

```c
typedef struct{
    ElemType *R;                                        //存储空间基地址
    int length;                                         //当前长度
}SSTable;
```

在此定义下，顺序查找算法便与第2章的算法2.2一样。在此假设元素从ST.R[1]开始顺序向后存放，ST.R[0]闲置不用，查找时从表的最后开始比较

###### 【算法描述】

```c
int Search_Seq(SSTable ST,KeyType key)
{//在顺序表ST中顺序查找其关键字等于key的数据元素。若找到，则函数值为该元素在表中的位置，否则为0
   for(i=ST.length;i>=1;--i)
     if(ST.R[i].key==key) return i;             //从后往前找
   return 0;
}
```

在查找过程中每步都要检测整个表是否查找完毕，即每步都要有循环变量是否满足条件i>=1的检测。改进这个程序，可以免去这个检测过程。改进方法是查找之前先对ST.R[0]的关键字赋值key，在此，ST.R[0]起到了监视哨的作用

###### 【算法描述】

```c
//设置监视哨的顺序查找
int Search_Seq(SSTable ST,KeyType key)
{//在顺序表ST中顺序查找其关键字等于key的数据元素。若找到，则函数值为该元素在表中的位置，否则为0
   ST.R[0].key=key;                                             //“哨兵”
   for(i=ST.length;ST.R[i].key!=key;--i);                       //从后往前找
   return i;
}
```

**时间复杂度为O(n)**

###### 【算法分析】

因此，算法2仅是一个程序设计技巧上的改进，即通过设置监视哨，免去查找过程中每一步都要检测整个表是否查找完毕。然而实践证明，这个改进能使顺序查找在ST.length≥1000时，进行一次查找所需的平均时间几乎减少一半。当然，监视哨也可设在高下标处。算法2和算法1的时间复杂度一样，在第2章已经做过分析，即

![image-20240720150617132](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240720150617132.png)

顺序查找的优点是：算法简单，对表结构无任何要求，既适用于顺序结构，也适用于链式结构，无论记录是否按关键字有序均可应用。其缺点是：平均查找长度较大，查找效率较低，所以当n很大时，不宜采用顺序查找。

## 2.折半查找

**折半查找**（Binary Search）也称**二分查找**，它是一种效率较高的查找方法。但是，折半查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列。在下面及后续的讨论中，均假设有序表是递增有序的。

折半查找的查找过程为：从表的中间记录开始，如果给定值和中间记录的关键字相等，则查找成功；如果给定值大于或者小于中间记录的关键字，则在表中大于或小于中间记录的那一半中查找，这样重复操作，直到查找成功，或者在某一步中查找区间为空，则代表查找失败。

折半查找每一次查找比较都使查找范围缩小一半，与顺序查找相比，很显然会提高查找效率。

为了标记查找过程中每一次的查找区间，下面分别用low和high来表示当前查找区间的下界和上界，mid为区间的中间位置。

###### 【算法步骤】
① 置查找区间初值，low为1，high为表长
② 当low小于等于high时，循环执行以下操作：
		mid取值为low和high的中间值
		将给定值key与中间位置记录的关键字进行比较，若相等则查找成功，返回中间位置mid
		若不相等则利用中间位置记录将表对分成前、后两个子表。如果key比中间位置记录的关键字小，则high取为mid-1，否则low取为mid+1
③ 循环结束，说明查找区间为空，则查找失败，返回0

###### 【算法描述】

```c
int Search_Bin(SSTable ST,KeyType key)
{//在有序表ST中折半查找其关键字等于key的数据元素。若找到，则函数值为该元素在表中的位置，否则为0 
   low=1;high=ST.length;                       //置查找区间初值 
   while(low<=high) 
   { 
      mid=(low+high)/2; 
      if(key==ST.R[mid].key) return mid;       //找到待查元素 
      else if(key<ST.R[mid].key) high=mid-1;   //继续在前一子表进行查找 
      else low=mid+1;                          //继续在后一子表进行查找 
   }                                           //while 
   return 0;                                   //表中不存在待查元素 
}
```

本算法很容易理解，唯一需要注意的是，循环执行的条件是low<=high，而不是low<high，因为low=high时，查找区间还有最后一个结点，还要进一步比较。算法7.3很容易改写成递归程序，递归函数的参数除了ST和key之外，还需要加上low和high，请读者自行实现折半查找的递归算法。

**题目**：已知如下11个数据元素的有序表（关键字即为数据元素的值）：(5, 16, 20, 27, 30, 36, 44, 55, 60, 67, 71)

请给出查找关键字为27和65的数据元素的折半查找过程。

假设指针low和high分别指示待查元素所在范围的下界和上界，指针mid指示区间的中间位置，即<img src="D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/image-20240729182516416.png" alt="image-20240729182516416" style="zoom:25%;" />。在此例中，low和high的初值分别为1和11，即[1,11]为待查范围，mid初值为6。

查找关键字key=27的折半查找过程如图（a）所示。

首先令给定值key=27与中间位置的数据元素的关键字ST.R[mid].key相比较，因为36>27，说明待查元素若存在，必在区间[low, mid−1]的范围内，则令指针high指向第mid−1个元素，high=5，重新求得<img src="D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/image-20240729182546259.png" alt="image-20240729182546259" style="zoom:25%;" />

然后仍以key和ST.R[mid].key相比，因为20<27，说明待查待元素若存在，必在[mid+1，high]范围内，则令指针low指向第mid+1个元素，low=4求得mid的新值为4，比较key和ST.R[mid].key，因为相等，则查找成功，返回所查元素在表中的序号，即指针mid的值4。查找关键字key=65的折半

查找过程如图7.1（b）所示。

查找过程同上，只是在图7.1（b）中的最后一趟查找时，因为low>high，查找区间不存在，则说明表中没有关键字等于65的元素，查找失败，返回0。

![image-20240729181531758](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/image-20240729181531758.png)

​				折半查找示意图

###### 【算法分析】

折半查找过程可用二叉树来描述。树中每一结点对应表中一个记录，但结点值不是记录的关键字，而是记录在表中的位置序号。把当前查找区间的中间位置作为根，左子表和右子表分别作为根的左子树和右子树，由此得到的二叉树称为折半查找的判定树。

例7.1中的有序表对应的判定树如图7.2所示。从判定树上可见，成功的折半查找恰好是走了一条从判定树的根到被查结点的路径，经历比较的关键字个数恰为该结点在树中的层次。例如，查找27的过程经过一条从根到结点④的路径，需要比较3次，比较次数即为结点④所在的层次。图7.2中比较1次的只有一个根结点，比较2次的有两个结点，比较3次和4次的各有四个结点。假设每个记录的查找概率相同，根据此判定树可知，对长度为11的有序表进行折半查找的平均查找长度为

![image-20240729181631188](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/image-20240729181631188.png)

![image-20240729181642890](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/image-20240729181642890.png)

​							折半查找过程的判定树及查找27的过程

由此可见，折半查找法在查找成功时进行比较的关键字个数最多不超过树的深度。而判定树的形态只与表记录个数n相关，而与关键字的取值无关，具有n个结点的判定树的深度为<img src="D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/image-20240729182613615.png" alt="image-20240729182613615" style="zoom:25%;" />。所以，对于长度为n的有序表，折半查找法在查找成功时和给定值进行比较的关键字个数至多为<img src="D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/image-20240729182636759.png" alt="image-20240729182636759" style="zoom:33%;" />

如果在上图所示的判定树中所有结点的空指针域上加一个指向一个方形结点的指针，如图7.3所示。并且，称这些方形结点为判定树的外部结点（与之相对，称那些圆形结点为内部结点），那么折半查找时查找失败的过程就是走了一条从根结点到外部结点的路径，和给定值进行比较的关键字个数等于该路径上内部结点个数。例如，查找65的过程即为走了一条从根到结点9～10的路径。因此，折半查找在查找不成功时和给定值进行比较的关键字个数最多也不超过<img src="D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/image-20240729182700120.png" alt="image-20240729182700120" style="zoom:25%;" />

![image-20240729181924450](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/image-20240729181924450.png)

​							加上外部结点的判定树和查找65的过程

借助于判定树，很容易求得折半查找的平均查找长度。为了讨论方便起见，假定有序表的长度n=2h−1，则判定树是深度为h=log2(n+1)的满二叉树。树中层次为1的结点有1个，层次为2的结点有2个，…，层次为h的结点有2h−1个。假设表中每个记录的查找概率相等<img src="D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/image-20240729182031519.png" alt="image-20240729182031519" style="zoom: 25%;" />，则查找成功时折半查找的平均查找长度为

![image-20240729182111320](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/image-20240729182111320.png)

当n较大时，可有下列近似结果

![image-20240729182137276](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/image-20240729182137276.png)

因此，折半查找的时间复杂度为O(log2n )。可见，折半查找的效率比顺序查找高，但折半查找只适用于有序表，且限于顺序存储结构。

折半查找的优点是：比较次数少，查找效率高。其缺点是：对表结构要求高，只能用于顺序存储的有序表。查找前需要排序，而排序本身是一种费时的运算。同时为了保持顺序表的有序性，对有序表进行插入和删除时，平均比较和移动表中一半元素，这也是一种费时的运算。因此，折半查找不适用于数据元素经常变动的线性表。

## 3.分块查找

分块查找（Blocking Search）又称索引顺序查找，这是一种性能介于顺序查找和折半查找之间的一种查找方法。在此查找法中，除表本身以外，尚需建立一个“索引表”。例如，图7.4所示为一个表及其索引表，表中含有18个记录，可分成3个子表（R1，R2，…，R6）、（R7，R8，…，R12）、（R13，R14，…，R18），对每个子表（或称块）建立一个索引项，其中包括两项内容：关键字项（其值为该子表内的最大关键字）和指针项（指示该子表的第一个记录在表中位置）。索引表按关键字有序，则表或者有序或者分块有序。所谓“分块有序”指的是第二个子表中所有记录的关键字均大于第一个子表中的最大关键字，第三个子表中的所有关键字均大于第二个子表中的最大关键字，……，依次类推。

![image-20240729182239642](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/image-20240729182239642.png)

因此，分块查找过程需分两步进行。先确定待查记录所在的块（子表），然后在块中顺序查找。假设给定值key=38，则先将key依次和索引表中各最大关键字进行比较，因为22<key<48，则关键字为38的记录若存在，必定在第二个子表中，由于同一索引项中的指针指示第二个子表中的第一个记录是表中第7个记录，则自第7个记录起进行顺序查找，直到ST.elem[10].key=key为止。假如此子表中没有关键字等于key的记录（例如：key=29时自第7个记录起至第12个记录的关键字和key比较都不等），则查找不成功。

由于由索引项组成的索引表按关键字有序，则确定块的查找可以用顺序查找，亦可用折半查找，而块中记录是任意排列的，则在块中只能是顺序查找。

由此，分块查找的算法为顺序查找和折半查找两种算法的简单合成。

分块查找的平均查找长度为

![image-20240729182325793](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/image-20240729182325793.png)

其中，Lb为查找索引表确定所在块的平均查找长度，Lw为在块中查找元素的平均查找长度。

一般情况下，为进行分块查找，可以将长度为n的表均匀地分成b块，每块含有s个记录，<img src="D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/image-20240729182348515.png" alt="image-20240729182348515" style="zoom:25%;" />
又假定表中每个记录的查找概率相等，则每块查找的概率为1/b，块中每个记录的查找概率为1/s。

若用顺序查找确定所在块，则分块查找的平均查找长度为![image-20240729182821054](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/image-20240729182821054.png)

可见，此时的平均查找长度不仅和表长n有关，而且和每一块中的记录个数s有关。在给定n的前提下，s是可以选择的。容易证明，当s<img src="D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/image-20240729183009330.png" alt="image-20240729183009330" style="zoom:25%;" />。这个值比顺序查找有了很大改进，但远不及折半查找。

若用折半查找确定所在块，则分块查找的平均查找长度为

![image-20240729183046930](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/image-20240729183046930.png)

分块查找的优点是：在表中插入和删除数据元素时，只要找到该元素对应的块，就可以在该块内进行插入和删除运算。由于块内是无序的，故插入和删除比较容易，无需进行大量移动。如果线性表既要快速查找又经常动态变化，则可采用分块查找。其缺点是：要增加一个索引表的存储空间并对初始索引表进行排序运算。

# 三、树表的查找

## 1.二叉排序树

二叉排序树（Binary Sort Tree）又称二叉查找树，它是一种对排序和查找都很有用的特殊二叉树。

1)．二叉排序树的定义

二叉排序树或者是一棵空树，或者是具有下列性质的二叉树：

- （1）若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
- （2）若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
- （3）它的左、右子树也分别为二叉排序树。

二叉排序树是递归定义的。由定义可以得出二叉排序树的一个重要性质：中序遍历一棵二叉树时可以得到一个结点值递增的有序序列。

例如，下图所示为两棵二叉排序树。

![image-20240729183305205](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/image-20240729183305205.png)

​			图7.5 二叉排序树示例

若中序遍历上图（a），则可得到一个按数值大小排序的递增序列：
3, 12, 24, 37, 45, 53, 61, 78, 90, 100

若中序遍历上图(b），则可得到一个按字符大小排序的递增序列：
CAO, CHEN, DING, DU, LI, MA, WANG, XIA,ZHAO

在下面讨论二叉排序树的操作中，使用二叉链表作为存储结构。因为二叉排序树的操作要根据结点的关键字域来进行，所以下面给出了每个结点的数据域的类型定义（包括关键字项和其他数据项）。

```c
//- - - - -二叉排序树的二叉链表存储表示- - - - -
typedef struct
{
   KeyType key;                                 //关键字项
   InfoType otherinfo;                          //其他数据项
}ElemType;                                      //每个结点的数据域的类型
typedef struct BSTNode
{
   ElemType data;                               //每个结点的数据域包括关键字项和其他数据项
   struct BSTNode *lchild,*rchild;              //左右孩子指针
}BSTNode,*BSTree;
```

## 2．二叉排序树的查找

因为二叉排序树可以看成是一个有序表，所以在二叉排序树上进行查找和折半查找类似，也是一个逐步缩小查找范围的过程。

**题目：**二叉排序树的递归查找
###### 【算法步骤】
① 若二叉排序树为空，则查找失败，返回空指针。
② 若二叉排序树非空，将给定值key与根结点的关键字T->data.key进行比较：

- 若key等于T->data.key，则查找成功，返回根结点地址；
- 若key小于T->data.key，则递归查找左子树；
- 若key大于T->data.key，则递归查找右子树。
模仿折半查找算法7.3，读者很容易写出二叉排序树查找的非递归算法。
下面以递归形式给出此查找算法。
###### 【算法描述】

```c
BSTree SearchBST(BSTree T,KeyType key)
{//在根指针T所指二叉排序树中递归地查找某关键字等于key的数据元素
 //若查找成功，则返回指向该数据元素结点的指针，否则返回空指针
   if((!T)||key==T->data.key) return T;                      //查找结束
   else if(key<T->data.key) return SearchBST(T->lchild,key); //在左子树中继续查找
   else return SearchBST(T->rchild,key);                     //在右子树中继续查找
}
```

例如，在图7.5（a）所示的二叉排序树中查找关键字等于100的记录（树中结点内的数均为记录的关键字）。首先以key=100和根结点的关键字做比较，因为key>45，则查找以㊺为根的右子树，此时右子树不空，且key>53，则继续查找以结点53为根的右子树，由于key和53的右子树根的关键字100相等，则查找成功，返回指向结点[插图]的指针值。又如在图7.5（a）中查找关键字等于40的记录，和上述过程类似，在给定值key与关键字45、12及37相继比较之后，继续查找以结点㊲为根的右子树，此时右子树为空，则说明该树中没有待查记录，故查找不成功，返回指针值为“NULL”。

###### 【算法分析】

从上述的两个查找例子（key=100和key=40）可见，在二叉排序树上查找其关键字等于给定值的结点的过程，恰是走了一条从根结点到该结点的路径的过程，和给定值比较的关键字个数等于路径长度加1（或结点所在层次数）。因此，和折半查找类似，与给定值比较的关键字个数不超过树的深度。然而，折半查找长度为n的顺序表的判定树是唯一的，而含有n个结点的二叉排序树却不唯一。图7.6中（a）和（b）的两棵二叉排序树中结点的值都相同，但创建这两棵树的序列不同，分别是：(45, 24, 53, 12, 37,93)和(12, 24, 37, 45, 53, 93)。（a）树的深度为3，而（b）树的深度为6。再从平均查找长度来看，假设6个记录的查找概率相等，为1/6，则（a）树的平均查找长度为

![image-20240729183841561](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/image-20240729183841561.png)

而（b）树的平均查找长度为

![image-20240729183902025](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/image-20240729183902025.png)

![image-20240729183913450](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/image-20240729183913450.png)

​							图7.6 不同形态的二叉排序树

因此，含有n个结点的二叉排序树的平均查找长度和树的形态有关。当先后插入的关键字有序时，构成的二叉排序树蜕变为单支树。树的深度为n，其平均查找长度为[插图]（和顺序查找相同），这是最差的情况。显然，最好的情况是，二叉排序树的形态和折半查找的判定树相似，其平均查找长度和log2n成正比。若考虑把n个结点按各种可能的次序插入到二叉排序树中，则有n！棵二叉排序树（其中有的形态相同）。可以证明，综合所有可能的情况，就平均而言，二叉排序树的平均查找长度仍然和log2n是同数量级的。

可见，二叉排序树上的查找和折半查找相差不大。但就维护表的有序性而言，二叉排序树更加有效，因为无需移动记录，只需修改指针即可完成对结点的插入和删除操作。因此，对于需要经常进行插入、删除和查找运算的表，采用二叉排序树比较好。

## 3．二叉排序树的插入

二叉排序树的插入操作是以查找为基础的。要将一个关键字值为key的结点*S插入到二叉排序树中，则需要从根结点向下查找，当树中不存在关键字等于key的结点时才进行插入。新插入的结点一定是一个新添加的叶子结点，并且是查找不成功时查找路径上访问的最后一个结点的左孩子或右孩子结点。*

**题目：**二叉排序树的插入

###### 【算法步骤】

① 若二叉排序树为空，则待插入结点*S作为根结点插入到空树中。*

② 若二叉排序树非空，则将key与根结点的关键字T->data.key进行比较：

- 若key小于T->data.key，则将*S插入左子树；*
- 若key大于T->data.key，则将*S插入右子树。

###### 【算法描述】

```c
void InsertBST(BSTree &T,ElemType e)
{//当二叉排序树T中不存在关键字等于e.key的数据元素时，则插入该元素 
   if(!T) 
   {                              //找到插入位置，递归结束 
      S=new BSTNode;              //生成新结点*S 
      S->data=e;                  //新结点*S的数据域置为e    
      S->lchild=S->rchild=NULL;   //新结点*S作为叶子结点 
      T=S;                        //把新结点*S链接到已找到的插入位置 
   } 
   else if(e.key<T->data.key)  
      InsertBST(T->lchild, e );  //将*S插入左子树 
   else if (e.key> T->data.key)  
      InsertBST(T->rchild, e);   //将*S插入右子树 
}
```

例如，在图7.5（a）所示的二叉排序树上插入关键字为55的结点，由于插入前二叉排序树非空，故将55和根结点45进行比较，因55>45，则应将55插入到45的右子树上；又和45的右子树的根53比较，因55>53，则应将55插入到53的右子树上；依次类推，直至最后55<61，且61的左子树为空，将55作为61的左孩子插入到树中。结果如图7.7所示。

![image-20240729184125347](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/image-20240729184125347.png)

​							图7.7 二叉排序树的插入

###### 【算法分析】
二叉排序树插入的基本过程是查找，所以时间复杂度同查找一样，是O(log2n)。
## 4．二叉排序树的创建
二叉排序树的创建是从空的二叉排序树开始的，每输入一个结点，经过查找操作，将新结点插入到当前二叉排序树的合适位置。
**题目：**二叉排序树的创建

###### 【算法步骤】

① 将二叉排序树T初始化为空树。
② 读入一个关键字为key的结点。
③ 如果读入的关键字key不是输入结束标志，则循环执行以下操作：

- 将此结点插入二叉排序树T中；
- 读入一个关键字为key的结点。
###### 【算法描述】

```c
void CreatBST(BSTree &T)
{//依次读入一个关键字为key的结点，将此结点插入二叉排序树T中 
   T=NULL;                  //将二叉排序树T初始化为空树 
   cin>>e;  
   while(e.key!=ENDFLAG)    //ENDFLAG为自定义常量，作为输入结束标志 
   { 
      InsertBST(T,e);       //将此结点插入二叉排序树T中 
      cin>>e;  
   }      
}
```

###### 【算法分析】

假设有n个结点，则需要n次插入操作，而插入一个结点的算法时间复杂度为O(log2n)，所以创建二叉排序树算法的时间复杂度为O(nlog2n)。

例如，设关键字的输入次序为：45, 24, 53, 45, 12,24, 90，按上述算法生成的二叉排序树的过程如图7.8所示。

![image-20240729184355719](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/image-20240729184355719.png)

​							图7.8 二叉排序树的创建过程

容易看出，一个无序序列可以通过构造一棵二叉排序树而变成一个有序序列，构造树的过程即为对无序序列进行排序的过程。不仅如此，从上面的插入过程还可以看到，每次插入的新结点都是二叉排序树上新的叶子结点，则在进行插入操作时，不必移动其他结点，仅需改动某个结点的指针，由空变为非空即可。这就相当于在一个有序序列上插入一个记录而不需要移动其他记录。

## 5．二叉排序树的删除

被删除的结点可能是二叉排序树中的任何结点，删除结点后，要根据其位置不同修改其双亲结点及相关结点的指针，以保持二叉排序树的特性。

**题目：** 二叉排序树的删除

###### 【算法步骤】

首先从二叉排序树的根结点开始查找关键字为key的待删结点，如果树中不存在此结点，则不做任何操作；否则，假设被删结点为*p（指向结点的指针为p），其双亲结点为*f（指向结点的指针为f），PL和PR分别表示其左子树和右子树（见图7.9（a））。

不失一般性，可设*p是*f的左孩子（右孩子情况类似）。下面分3种情况进行讨论。

（1）若*p结点为叶子结点，即PL和PR均为空树。由于删去叶子结点不破坏整棵树的结构，则只需修改其双亲结点的指针即可。*

```c
f->lchild=NULL;
```

*（2）若***p结点只有左子树P~L~或者只有右子树P~R~，此时只要令PL或PR直接成为其双亲结点*f的左子树即可。*

```c
f->lchild=p->lchild;（或f->lchild=p->rchild;)
```

（3）若**p结点的左子树和右子树均不空。从图7.9（b）可知，在删去*p结点之前，中序遍历该二叉树得到的序列为{…CLC…QLQSLSPPRF…}，在删去*p之后，为保持其他元素之间的相对位置不变，可以有两种处理方法：*

*① 令*p的左子树为*f的左子树，而*p的右子树为*s的右子树，如图7.9（c）所示。*

```c
f->lchild=p->lchild; s->rchild=p->rchild;
```

*② 令*p的直接前驱（或直接后继）替代*p，然后再从二叉排序树中删去它的直接前驱（或直接后继）。如图7.9（d）所示，当以直接前驱*s替代*p时，由于*s只有左子树SL，则在删去*s之后，只要令SL为*s的双亲*q的右子树即可。

```c
p->data=s->data; q->rchild=s->lchild;
```

![image-20240729184451870](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/image-20240729184451870.png)

​								图7.9 在二叉排序树中删除*p

显然，前一种处理方法可能增加树的深度，而后一种方法是以被删结点左子树中关键字最大的结点替代被删结点，然后从左子树中删除这个结点。此结点一定没有右子树（否则它就不是左子树中关键字最大的结点），这样不会增加树的高度，所以常采用这种处理方案。下面的算法描述即采用这种方案。

###### 【算法描述】

```c
void DeleteBST(BSTree &T,KeyType key)
{//从二叉排序树T中删除关键字等于key的结点 
   p=T;f=NULL;                              //初始化 
   /*------------下面的while循环从根开始查找关键字等于key的结点*p---------------*/ 
   while(p) 
   {                   
      if(p->data.key==key) break;           //找到关键字等于key的结点*p，结束循环 
      f=p;                                  //*f为*p的双亲结点 
      if(p->data.key>key) p=p->lchild;      //在*p的左子树中继续查找 
      else p=p->rchild;                     //在*p的右子树中继续查找 
   }          //while 
   if(!p) return;                           //找不到被删结点则返回 
   /*----考虑3种情况实现p所指子树内部的处理：*p左右子树均不空、无右子树、无左子树---*/ 
   if((p->lchild)&&(p->rchild))            //被删结点*p左右子树均不空 
   {  
      q=p; s=p->lchild; 
      while (s->rchild)                     //在*p的左子树中继续查找其前驱结点，即最右下结点 
      { 
         q=s; s=s->rchild;                 //向右到尽头 
      }               
      p->data=s->data;                     //s指向被删结点的“前驱”
      if(q!=p) q->rchild=s->lchild;       //重接*q的右子树 
      else q->lchild=s->lchild;           //重接*q的左子树 
      delete s; 
      return; 
    }                                    //if 
   else if(!p->rchild)                   //被删结点*p无右子树，只需重接其左子树 
   { 
      q=p; p=p->lchild;  
   }//else if 
   else if(!p->lchild)                 //被删结点*p无左子树，只需重接其右子树 
   { 
      q=p; p=p->rchild; 
   }          //else if 
   /*-----------------将p所指的子树挂接到其双亲结点*f相应的位置----------------*/ 
   if(!f) T=p;                          //被删结点为根结点 
   else if(q==f->lchild) f->lchild=p;   //挂接到*f的左子树位置 
   else f->rchild=p;                    //挂接到*f的右子树位置 
   delete q; 
}
```

###### 【算法分析】

同二叉排序树插入一样，二叉排序树删除的基本过程也是查找，所以时间复杂度仍是O(log2n)。

![image-20240731094835382](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/image-20240731094835382.png)

​				二叉排序树的删除

## 6.平衡二叉树

### 1).平衡二叉树的定义

二叉排序树查找算法的性能取决于二叉树的结构，而二叉排序树的形状则取决于其数据集。如果数据呈有序排列，则二叉排序树是线性的，查找的时间复杂度为O(n)；反之，如果二叉排序树的结构合理，则查找速度较快，查找的时间复杂度为O(log2n)。事实上，树的高度越小，查找速度越快。因此，希望二叉树的高度尽可能小。本节将讨论一种特殊类型的二叉排序树，称为平衡二叉树（Balanced Binary Tree或Height-Balanced Tree），因由前苏联数学家Adelson-Velskii和Landis提出，所以又称AVL树。

平衡二叉树或者是空树，或者是具有如下特征的二叉排序树：

- （1）左子树和右子树的深度之差的绝对值不超过1；
- （2）左子树和右子树也是平衡二叉树。

若将二叉树上结点的平衡因子（Balance Factor，BF）定义为该结点左子树和右子树的深度之差，则平衡二叉树上所有结点的平衡因子只可能是−1、0和1。只要二叉树上有一个结点的平衡因子的绝对值大于1，则该二叉树就是不平衡的。下图（a）所示为两棵平衡二叉树，而下图（b）所示为两棵不平衡的二叉树，结点中的值为该结点的平衡因子。

![image-20240731095046759](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/image-20240731095046759.png)

​						平衡与不平衡的二叉树及结点的平衡因子

因为AVL树上任何结点的左右子树的深度之差都不超过1，则可以证明它的深度和log2n是同数量级的（其中n为结点个数）。由此，其查找的时间复杂度是O(log2n)。

### 2)．平衡二叉树的平衡调整方法

如何创建一棵平衡二叉树呢？插入结点时，首先按照二叉排序树处理，若插入结点后破坏了平衡二叉树的特性，需对平衡二叉树进行调整。调整方法是：找到离插入结点最近且平衡因子绝对值超过1的祖先结点，以该结点为根的子树称为最小不平衡子树，可将重新平衡的范围局限于这棵子树。

先看一个具体例子（见图7.12）。假设表中关键字序列为(13, 24, 37, 90, 53)。

![image-20240731095216311](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/image-20240731095216311.png)

​								图（7-12）平衡树的生成过程

（1）空树和1个结点⑬的树显然都是平衡的二叉树。在插入24之后仍是平衡的，只是根结点的平衡因子BF由0变为−1，如上图7.12（a）～（c）所示。

（2）在继续插入37之后，由于结点⑬的BF值由−1变成−2，由此出现了不平衡的现象。此时好比一根扁担出现一头重一头轻的现象，若能将扁担的支撑点由⑬改至㉔，扁担的两头就平衡了。由此，可以对树做一个向左逆时针“旋转”的操作，令结点㉔为根，而结点⑬为它的左子树，此时，结点⑬和㉔的平衡因子都为0，而且仍保持二叉排序树的特性，如上图7.12（d）～（e）所示。

（3）在继续插入90和53之后，结点㊲的BF值由−1变成−2，排序树中出现了新的不平衡现象，需进行调整。但此时由于是结点90插在结点[插图]的左子树上，因此不能如上做简单调整。离插入结点最近的最小不平衡子树是以结点㊲为根的子树。这时，必须以53作为根结点，而使㊲成为它的左子树的根，90成为它的右子树的根。这好比对树做了两次“旋转”操作，先向右顺时针旋转，后向左逆时针旋转（见图7.12（f）～（h）），使二叉排序树由不平衡转化为平衡。

一般情况下，假设最小不平衡子树的根结点为A，则失去平衡后进行调整的规律可归纳为下列4种情况。

1）LL型：由于在A左子树根结点的左子树上插入结点，A的平衡因子由1增至2，致使以A为根的子树失去平衡，则需进行一次向右的顺时针旋转操作，如图7.13所示。

![image-20240731095446552](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/image-20240731095446552.png)

​							（图7-13） LL型调整操作示意图

![image-20240731095521279](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/image-20240731095521279.png)

​								（图7-14）两个LL型调整的实例

2）RR型：由于在A的右子树根结点的右子树上插入结点，A的平衡因子由−1变为−2，致使以A为根结点的子树失去平衡，则需进行一次向左的逆时针旋转操作，如图7.15所示。

![image-20240731095730375](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/image-20240731095730375.png)

​								图7.15 RR型调整操作示意图

![image-20240731095802246](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/image-20240731095802246.png)

​								图7.16 RR型调整示例

3）LR型：由于在A的左子树根结点的右子树上插入结点，A的平衡因子由1增至2，致使以A为根结点的子树失去平衡，则需进行两次旋转操作。第一次对B及其右子树进行逆时针旋转，C转上去成为B的根，这时变成了LL型，所以第二次进行LL型的顺时针旋转即可恢复平衡。如果C原来有左子树，则调整C的左子树为B的右子树，如图7.17所示。

![image-20240731095829995](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/image-20240731095829995.png)

​							图7.17 LR型调整操作示意图

LR型旋转前后A、B、C三个结点平衡因子的变化分为3种情况，图7.18所示为3种LR型调整的实例。

![image-20240731095856236](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/image-20240731095856236.png)

4）RL型：由于在A的右子树根结点的左子树上插入结点，A的平衡因子由−1变为−2，致使以A为根结点的子树失去平衡，则旋转方法和LR型相对称，也需进行两次旋转，先顺时针右旋，再逆时针左旋，如图7.19所示。

![image-20240731095916443](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/image-20240731095916443.png)

同LR型旋转类似，RL型旋转前后A、B、C三个结点的平衡因子的变化也分为3种情况，图7.20所示为3种RL型调整的实例。

![image-20240731095932143](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/image-20240731095932143.png)

上述4种情况中，（1）和（2）对称，（3）和（4）对称。旋转操作的正确性容易由“保持二叉排序树的特性：中序遍历所得关键字序列自小至大有序”证明之。同时，无论哪一种情况，在经过平衡旋转处理之后，以B或C为根的新子树为平衡二叉树，而且它们的深度和插入之前以A为根的子树相同。因此，当平衡的二叉排序树因插入结点而失去平衡时，仅需对最小不平衡子树进行平衡旋转处理即可。因为经过旋转处理之后的子树深度和插入之前相同，因而不影响插入路径上所有祖先结点的平衡度。

3)．平衡二叉树的插入

在平衡的二叉排序树BBST上插入一个新的数据元素e的递归算法可描述如下。

① 若BBST为空树，则插入一个数据元素为e的新结点作为BBST的根结点，树的深度增1。

② 若e的关键字和BBST的根结点的关键字相等，则不进行插入。

③ 若e的关键字小于BBST的根结点的关键字，而且在BBST的左子树中不存在和e有相同关键字的结点，则将e插入在BBST的左子树上，并且当插入之后的左子树深度增加（+1）时，分别就下列不同情况处理之：
```
BBST的根结点的平衡因子为−1（右子树的深度大于左子树的深度）：则将根结点的平衡因子更改为0，BBST的深度不变；·BBST的根结点的平衡因子为0（左、右子树的深度相等）：则将根结点的平衡因子更改为1，BBST的深度增1；
BBST的根结点的平衡因子为1（左子树的深度大于右子树的深度）：若BBST的左子树根结点的平衡因子为1，则需进行单向右旋平衡处理，并且在右旋处理之后，将根结点和其右子树根结点的平衡因子更改为0，树的深度不变；
若BBST的左子树根结点的平衡因子为−1，则需进行先向左、后向右的双向旋转平衡处理，并且在旋转处理之后。修改根结点和其左、右子树根结点的平衡因子，树的深度不变。
```

④ 若e的关键字大于BBST的根结点的关键字，而且在BBST的右子树中不存在和e有相同关键字的结点，则将e插入在BBST的右子树上，并且当插入之后的右子树深度增加（+1）时，分别就不同情况处理之。其处理操作和③中所述相对称，读者可自行补充。

##  7.B-树

前面介绍的查找方法均适用于存储在计算机内存中较小的文件，统称为内查找法。若文件很大且存放于外存进行查找时，这些查找方法就不适用了。内查找法都以结点为单位进行查找，这样需要反复地进行内、外存的交换，是很费时的。1970年，R.Bayer和E.Mccreight提出了一种适用于外查找的平衡多叉树——B-树，磁盘管理系统中的目录管理，以及数据库系统中的索引组织多数都采用B-树这种数据结构。

### 1)．B-树的定义

一棵m阶的B-树，或为空树，或为满足下列特性的m叉树：

（1）树中每个结点至多有m棵子树；

（2）若根结点不是叶子结点，则至少有两棵子树；

（3）除根之外的所有非终端结点至少有）[插图]棵子树；

（4）所有的叶子结点都出现在同一层次上，并且不带信息，通常称为失败结点（失败结点并不存在，指向这些结点的指针为空。引入失败结点是为了便于分析B-树的查找性能）；

（5）所有的非终端结点最多有m−1个关键字，结点的结构如图7.21所示。

![image-20240731100333722](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/image-20240731100333722.png)

​									B-树的结点结构(21)

其中，Ki（i=1, …, n）为关键字，且Ki<Ki+1（i=1,…, n−1）；Pi（i=0, …, n）为指向子树根结点的指针，且指针Pi−1所指子树中所有结点的关键字均小于Ki（i=1, …, n），Pn所指子树中所有结点的关键字均大于Kn，<img src="D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/image-20240731100608486.png" alt="image-20240731100608486" style="zoom:25%;" />为关键字的个数（或n+1为子树个数)。

从上述定义可以看出，对任一关键字Ki而言，Pi−1相当于指向其“左子树”，Pi相当于指向其“右子树”。

B-树具有平衡、有序、多路的特点，下图为一棵4阶的B-树，能很好地说明其特点。

![image-20240731100844887](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/image-20240731100844887.png)

​								一棵4阶的B-树(22)

- （1）所有叶子结点均在同一层次，这体现出其平衡的特点。
- （2）树中每个结点中的关键字都是有序的，且关键字Ki“左子树”中的关键字均小于Ki，而其“右子树”中的关键字均大于Ki，这体现出其有序的特点。
- （3）除叶子结点外，有的结点中有一个关键字，两棵子树，有的结点中有两个关键字，三棵子树，这种4阶的B-树最多有三个关键字，四棵子树，这体现出其多路的特点。

在具体实现时，为记录其双亲结点，B-树结点的存储结构通常增加一个parent指针，指向其双亲结点，存储结构示意图下图所示。

![image-20240731100703830](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/image-20240731100703830.png)

​							B-树结点的存储结构(23)

### 2)．B-树的查找

由B-树的定义可知，在B-树上进行查找的过程和二叉排序树的查找类似。

例如，在图7.22所示的B-树上查找关键字47的过程如下：首先从根开始，根据根结点指针t找到*a结点，因**a结点中只有一个关键字，且47>35，若查找的记录存在，则必在指针P1所指的子树内，顺指针找到*c结点，该结点有两个关键字（43和78），而43<47<78，若查找的记录存在，则必在指针P1所指的子树中。同样，顺指针找到*g结点，在该结点中顺序查找，找到关键字47，由此，查找成功。*

查找不成功的过程也类似，例如，在同一棵树中查找23。从根开始，因为23<35，则顺该结点中指针P0找到*b结点，又因为*b结点中只有一个关键字18，且23>18，所以顺结点中第二个指针P1找到*e结点。同理，因为23<27，则顺指针往下找，此时因指针所指为叶子结点，说明此棵B-树中不存在关键字23，查找因失败而告终。

由此可见，在B-树上进行查找的过程是一个顺指针查找结点，和在结点的关键字中查找交叉进行的过程。

由于B-树主要用做文件的索引，因此它的查找涉及外存的存取，在此略去外存的读写，只做示意性的描述。假设结点类型定义如下：

```c
#define m 3                             // B-树的阶，暂设为3
typedef struct BTNode
{
   int keynum;                          //结点中关键字的个数，即结点的大小
   struct BTNode *parent;               //指向双亲结点
   KeyType K[m+1];                      //关键字向量，0号单元未用
   struct BTNode *ptr[m+1];             //子树指针向量
   Record *recptr[m+1];                 //记录指针向量，0号单元未用
}BTNode,*BTree;                         //B-树结点和B-树的类型
typedef struct
{
   BTNode *pt;                          //指向找到的结点
   int i;                               //1..m，在结点中的关键字序号
   int tag;                             //1：查找成功，0：查找失败
}Result;                                //B-树的查找结果类型
```

###### B-树的查找【算法步骤】

将给定值key与根结点的各个关键字K1, K2, …, Kj（1≤j≤m−1）进行比较，由于该关键字序列是有序的，所以查找时可采用顺序查找，也可采用折半查找。查找时：

- ① 若key=Ki（1≤i≤j），则查找成功；
- ② 若key<K1，则顺着指针P0所指向的子树继续向下查找；
- ③ 若Ki<key<Ki+1（1≤i≤j−1），则顺着指针Pi所指向的子树继续向下查找；
- ④ 若key>Kj，则顺着指针Pj所指向的子树继续向下查找。

如果在自上而下的查找过程中，找到了值为key的关键字，则查找成功；如果直到叶子结点也未找到，则查找失败。

###### 【算法描述】

```c
Result SearchBTree(BTree T,KeyType key)
{//在m阶B-树T上查找关键字key，返回结果(pt,i,tag) 
 //若查找成功，则特征值tag=1，指针pt所指结点中第i个关键字等于key 
 //否则特征值tag=0，等于key的关键字应插入在指针pt所指结点中第i和第i+1个关键字之间 
   p=T;q=NULL;found=FALSE;i=0;            //初始化，p指向待查结点，q指向p的双亲 
   while(p&&!found) 
   { 
      i=Search(p,key); 
      //在p->key[1..keynum]中查找i，使得：p->key[i]<=key<p->key[i+1] 
      if(i>0&&p->key[i]==k) found=TRUE; //找到待查关键字 
      else{q=p; p=p->ptr[i];} 
   } 
   if(found) return(p,i,l);               //查找成功 
   else return(q,i,0);                    //查找不成功，返回K的插入位置信息 
}
```

###### 【算法分析】

在B-树上进行查找包含两种基本操作：（1）在B-树中找结点；（2）在结点中找关键字。由于B-树通常存储在磁盘上，则前一查找操作是在磁盘上进行的（在算法7.8中没有体现），而后一查找操作是在内存中进行的，即在磁盘上找到指针p所指结点后，先将结点中的信息读入内存，然后再利用顺序查找或折半查找查询等于key的关键字。显然，在磁盘上进行一次查找比在内存中进行一次查找耗费时间多出很多，因此，在磁盘上进行查找的次数，即待查关键字所在结点在B-树上的层次数，是决定B-树查找效率的首要因素。

现考虑最坏的情况，即待查结点在B-树的最下面一层。也就是说，含N个关键字的m阶B-树的最大深度是多少？

先看一棵3阶的B-树。按B-树上的定义，3阶的B-树上所有非终端结点至多可有两个关键字，至少有一个关键字（即子树个数为2或3，故又称2-3树）。因此，若关键字个数≤2时，树的深度为2（即叶子结点层次为2）；若关键字个数≤6时，树的深度不超过3。反之，若B-树的深度为4，则关键字的个数必须≥7（见图7.24（g）），此时，每个结点都含有可能的关键字的最小数目。

![image-20240731101134926](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/image-20240731101134926.png)

​							不同关键字数目的B-树(24)

一般情况的分析可类似平衡二叉树进行，先讨论深度为h+1的m阶B-树所具有的最少结点数。

根据B-树的定义，第一层至少有1个结点；第二层至少有2个结点；由于除根之外的每个非终端结点至少有<img src="D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/image-20240731101212135.png" alt="image-20240731101212135" style="zoom:25%;" />棵子树，则第三层至少有<img src="D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/image-20240731101232191.png" alt="image-20240731101232191" style="zoom:25%;" />个结点；……；依次类推，第h+1层至少有<img src="D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/image-20240731101256504.png" alt="image-20240731101256504" style="zoom:25%;" />个结点。而h+1层的结点为叶子结点。若m阶B-树中具有N个关键字，则叶子结点即查找不成功的结点为N+1，由此有：

![image-20240731101310971](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/image-20240731101310971.png)

反之

![image-20240731101406135](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/image-20240731101406135.png)

这就是说，在含有N个关键字的B-树上进行查找时，从根结点到关键字所在结点的路径上涉及的结点数不超过

![image-20240731101346691](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/image-20240731101346691.png)

### 3)．B-树的插入

B-树是动态查找树，因此其生成过程是从空树起，在查找的过程中通过逐个插入关键字而得到。但由于B-树中除根之外的所有非终端结点中的关键字个数必须大于等于[插图]，因此，每次插入一个关键字不是在树中添加一个叶子结点，而是首先在最低层的某个非终端结点中添加一个关键字，若该结点的关键字个数不超过m−1，则插入完成，否则表明结点已满，要产生结点的“分裂”，将此结点在同一层分成两个结点。一般情况下，结点分裂方法是：以中间关键字为界把结点一分为二，成为两个结点，并把中间关键字向上插入到双亲结点上，若双亲结点已满，则采用同样的方法继续分解。最坏的情况下，一直分解到树根结点，这时B-树高度增加1。

例如，图7.25（a）所示为3阶的B-树（图中略去F结点（即叶子结点）），假设需依次插入关键字30、26、85和7。首先通过查找确定应插入的位置。由根*a起进行查找，确定30应插入在*d结点中，由于*d中关键字数目不超过2（即m−1），故第一个关键字插入完成。插入30后的B-树如图7.25（b）所示。同样，通过查找确定关键字26亦应插入在*d结点中。由于*d中关键字的数目超过2，此时需将*d分裂成两个结点，关键字26及其前、后两个指针仍保留在*d结点中，而关键字37及其前、后两个指针存储到新产生的结点*d'中。同时，将关键字30和指示结点*d'的指针插入到其双亲结点中。由于*b结点中的关键字数目没有超过2，则插入完成。插入后的B-树如图7.25（d）所示。类似地，在*g中插入85之后需分裂成两个结点，而当70继而插入到双亲结点中时，由于*e中关键字数目超过2，则再次分裂为结点*e和*e'，如图7.25（g）所示。最后在插入关键字7时，*c、*b和*a相继分裂，并生成一个新的根结点*m，如图7.25（h）～（j）所示。

![image-20240731101455113](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/image-20240731101455113.png)

![image-20240731101507841](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/image-20240731101507841.png)

![image-20240731101525182](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/image-20240731101525182.png)

​						在B-树中进行插入（省略叶子结点）（25）

###### B-树的插入【算法步骤】

① 在B-树中查找给定关键字的记录，若查找成功，则插入操作失败；否则将新记录作为空指针ap插入到查找失败的叶子结点的上一层结点（由q指向）中。

② 若插入新记录和空指针后，q指向的结点的关键字个数未超过m−1，则插入操作成功，否则转入步骤③。

③ 以该结点的第[m/2]个关键字<img src="D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/image-20240731102622077.png" alt="image-20240731102622077" style="zoom: 50%;" />为拆分点，将该结点分成3个部分：<img src="D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/image-20240731102656417.png" alt="image-20240731102656417" style="zoom:33%;" />左边部分、<img src="D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/image-20240731102722327.png" alt="image-20240731102722327" style="zoom:33%;" />右边部分。<img src="D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/image-20240731102743821.png" alt="image-20240731102743821" style="zoom:33%;" />左边部分仍然保留在原结点中；<img src="D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/image-20240731102804891.png" alt="image-20240731102804891" style="zoom:33%;" />右边部分存放在一个新创建的结点（由ap指向)中；关键字值为<img src="D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/image-20240731102827871.png" alt="image-20240731102827871" style="zoom:33%;" />的记录和指针ap插入到q的双亲结点中。因q的双亲结点增加一个新的记录，所以必须对q的双亲结点重复②和③的操作，依次类推，直至由q指向的结点是根结点，转入步骤④。

④ 由于根结点无双亲，则由其分裂产生的两个结点的指针ap和q，以及关键字为[插图]的记录构成一个新的根结点。此时，B-的高度增加1。

下面算法描述中的q和i是由查找函数SearchBTree返回的信息而得。

###### 【算法描述】

![image-20240731102927152](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/image-20240731102927152.png)

### 4)．B-树的删除

m阶B-树的删除操作是在B-树的某个结点中删除指定的关键字及其邻近的一个指针，删除后应该进行调整使该树仍然满足B-树的定义，也就是要保证每个结点的关键字数目范围为<img src="D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/image-20240731103147852.png" alt="image-20240731103147852" style="zoom:33%;" />。删除记录后，结点的关键字个数如果小于<img src="D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/image-20240731103205183.png" alt="image-20240731103205183" style="zoom:33%;" />，则要进行“合并”结点的操作。除了删除记录，还要删除该记录邻近的指针。若该结点为最下层的非终端结点，由于其指针均为空，删除后不会影响其他结点，可直接删除；若该结点不是最下层的非终端结点，邻近的指针则指向一棵子树，不可直接删除。此时可做如下处理：将要删除记录用其右（左）边邻近指针指向的子树中关键字最小（大）的记录（该记录必定在最下层的非终端结点中）替换。采取这种方法进行处理，无论要删除的记录所在的结点是否为最下层的非终端结点，都可归结为在最下层的非终端结点中删除记录的情况。

例如，在图7.25（a)所示的B-树上删去45，可以用*f结点中的50替代45，然后在*f结点中删去50。因此，下面可以只讨论删除最下层非终端结点中的关键字的情形。有以下3种可能。

（1）被删关键字所在结点中的关键字数目不小于<img src="D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/image-20240731103246783.png" alt="image-20240731103246783" style="zoom:33%;" />，则只需从该结点中删去该关键字Ki和相应指针Pi，树的其他部分不变。例如，从图7.25（a）所示B-树中删去关键字12，删除后的B-树如图7.26（a)所示。

（2）被删关键字所在结点中的关键字数目等于[插图]，而与该结点相邻的右兄弟（或左兄弟）结点中的关键字数目大于<img src="D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/image-20240731103316744.png" alt="image-20240731103316744" style="zoom:33%;" />，则需将其兄弟结点中的最小（或最大）的关键字上移至双亲结点中，而将双亲结点中小于（或大于）且紧靠该上移关键字的关键字下移至被删关键字所在结点中。例如，从图7.26（a）中删去50，需将其右兄弟结点中的61上移至*e结点中，而将*e结点中的53移至*f，从而使*f和*g中关键字数目均不小于<img src="D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/image-20240731103338695.png" alt="image-20240731103338695" style="zoom:33%;" />，而双亲结点中的关键字数目不变，如图7.26（b)所示。*

（3）被删关键字所在结点和其相邻的兄弟结点中的关键字数目均等于<img src="D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/image-20240731103408408.png" alt="image-20240731103408408" style="zoom:33%;" />。假设该结点有右兄弟，且其右兄弟结点地址由双亲结点中的指针Pi所指，则在删去关键字之后，它所在结点中剩余的关键字和指针，加上双亲结点中的关键字Ki一起，合并到Pi所指兄弟结点中（若没有右兄弟，则合并至左兄弟结点中）。例如，从图7.26（b）所示B-树中删去53，则应删去*f结点，并将*f的剩余信息（指针“空”）和双亲*e结点中的61一起合并到右兄弟结点*g中，删除后的树如图7.26（c）所示。如果因此使双亲结点中关键字数目小于<img src="D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/image-20240731103426991.png" alt="image-20240731103426991" style="zoom:33%;" />则依次类推做相应处理。例如，在图7.26（c）的B-树中删去关键字37之后，双亲*b结点中剩余信息（指针c）应和其双亲*a结点中关键字45一起合并至右兄弟结点*e中，删除后的B-树如图7.26（d)所示。

![image-20240731103445873](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/image-20240731103445873.png)

​							在B-树中删除关键字的情形(26)

在B-树中删除结点的算法在此不再详述，读者可根据上述讨论自行写出此算法。

## 8.B+树

B+树是一种B-树的变形树，更适合用于文件索引系统。严格来讲，它已不符合第5章中定义的树了。

### 1)．B+树和B-树的差异

一棵m阶的B+树和m阶的B-树的差异在于：

- （1）有n棵子树的结点中含有n个关键字；
- （2）所有的叶子结点中包含了全部关键字的信息，以及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接；
- （3）所有的非终端结点可以看成是索引部分，结点中仅含有其子树（根结点）中的最大（或最小）关键字。

例如，图7.27所示为一棵3阶的B+树，通常在B+树上有两个头指针，一个指向根结点，另一个指向关键字最小的叶子结点。因此，可以对B+树进行两种查找运算：一种是从最小关键字起顺序查找，另一种是从根结点开始，进行随机查找。

![image-20240731105658955](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/image-20240731105658955.png)

​							一棵3阶的B+树(27)

### 2)．B+树的查找、插入和删除

在B+树上进行随机查找、插入和删除的过程基本上与B-树类似。

（1）查找：若非终端结点上的关键字等于给定值，并不终止，而是继续向下直到叶子结点。因此，在B+树中，不管查找成功与否，每次查找都是走了一条从根到叶子结点的路径。B+树查找的分析类似于B-树。

B+树不仅能够有效地查找单个关键字，而且更适合查找某个范围内的所有关键字。例如，在B+树上找出范围在[a，b]之间的所有关键字值。处理方法如下：通过一次查找找出关键字a，不管它是否存在，都可以到达可能出现a的叶子结点，然后在叶子结点中查找关键字值等于a或大于a的那些关键字，对于所找到的每个关键字都有一个指针指向相应的记录，这些记录的关键字在所需要的范围。如果在当前结点中没有发现大于b的关键字，就可以使用当前叶子结点的最后一个指针找到下一个叶子结点，并继续进行同样的处理，直至在某个叶子结点中找到大于b的关键字，才停止查找。

（2）插入：仅在叶子结点上进行插入，当结点中的关键字个数大于m时要分裂成两个结点，它们所含关键字的个数分别为[插图]；并且，它们的双亲结点中应同时包含这两个结点中的最大关键字。

（3）删除：B+树的删除也仅在叶子结点进行，当叶子结点中最大关键字被删除时，其在非终端结点中的值可以作为一个“分界关键字”存在。若因删除而使结点中关键字的个数少于[插图]时，其和兄弟结点的合并过程亦和B-树类似。

# 四、散列查找

## 1.散列表的基本概念

（1）散列函数和散列地址：在记录的存储位置p和其关键字key之间建立一个确定的对应关系H，使p=H(key)，称这个对应关系H为散列函数，p为散列地址。

（2）散列表：一个有限连续的地址空间，用以存储按散列函数计算得到相应散列地址的数据记录。通常散列表的存储空间是一个一维数组，散列地址是数组的下标。

（3）冲突和同义词：对不同的关键字可能得到同一散列地址，即key1≠key2，而H(key1)=H(key2)，这种现象称为冲突。具有相同函数值的关键字对该散列函数来说称作同义词，key1与key2互称为同义词。

例如，对C语言某些关键字集合建立一个散列表，关键字集合为

```
S1={main, int, float, while, return, break, switch,case, do}
```

设定一个长度为26的散列表应该足够，散列表可定义为

```
char HT[26][8];
```

假设散列函数的值取为关键字key中第一个字母在字母表{a, b,…, z}的序号（序号范围为0～25），即

```
H(key)=key[0]−‘a’
```

其中，设key的类型是长度为8的字符数组，根据此散列函数构造的散列表如表所示。

![image-20240731105927755](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/image-20240731105927755.png)

假设关键字集合扩充为：

```
S2=S1+{short, default, double, static, for, struct}
```

如果散列函数不变，新加入的七个关键字经过计算得到：

```
H(short)=H(static)=H(struct)=18，H(default)=H(double)=3，H(for)=5，
```

而18、3和5这几个位置均已存放相应的关键字，这就发生了冲突现象，其中，switch、short、static和struct称为同义词；float和for称为同义词，do、default和double称为同义词。

集合S2中的关键字仅有15个，仔细分析这15个关键字的特性，应该不难构造一个散列函数避免冲突。但在实际应用中，理想化的、不产生冲突的散列函数极少存在，这是因为通常散列表中关键字的取值集合远远大于表空间的地址集。例如，高级语言的编译程序要对源程序中的标识符建立一张符号表进行管理，多数都采取散列表。在设定散列函数时，考虑的查找关键字集合应包含所有可能产生的关键字，不同的源程序中使用的标识符一般也不相同，如果此语言规定标识符为长度不超过8的、字母开头的字母数字串，字母区分大小写，则标识符取值集合的大小为

![image-20240731110057844](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/image-20240731110057844.png)

而一个源程序中出现的标识符是有限的，所以编译程序将散列表的长度设为1000足矣。于是，要将多达10^12^个可能的标识符映射到有限的地址上，难免产生冲突。通常，散列函数是一个多对一的映射，所以冲突是不可避免的，只能通过选择一个“好”的散列函数使得在一定程度上减少冲突。而一旦发生冲突，就必须采取相应措施及时予以解决。综上所述，散列查找法主要研究以下两方面的问题：

- （1）如何构造散列函数；
- （2）如何处理冲突。

## 2.散列函数的构造方法

构造散列函数的方法很多，一般来说，应根据具体问题选用不同的散列函数，通常要考虑以下因素：

- （1）散列表的长度；
- （2）关键字的长度；
- （3）关键字的分布情况；
- （4）计算散列函数所需的时间；
- （5）记录的查找频率。

构造一个“好”的散列函数应遵循以下两条原则：

- （1）函数计算要简单，每一关键字只能有一个散列地址与之对应；
- （2）函数的值域需在表长的范围内，计算出的散列地址的分布应均匀，尽可能减少冲突。

下面介绍构造散列函数的几种常用方法。

### 1．数字分析法
如果事先知道关键字集合，且每个关键字的位数比散列表的地址码位数多，每个关键字由n位数组成，如k1k2…kn，则可以从关键字中提取数字分布比较均匀的若干位作为散列地址。

例如，有80个记录，其关键字为8位十进制数。假设散列表的表长为100，则可取两位十进制数组成散列地址，选取的原则是分析这80个关键字，使得到的散列地址尽量避免产生冲突。假设这80个关键字中的一部分如下所列：

![image-20240731110317946](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/image-20240731110317946.png)

对关键字全体的分析中可以发现：第①、②位都是“8 1”，第③位只可能取3或4，第⑧位可能取2、5或7，因此这4位都不可取。由于中间的4位可看成是近乎随机的，因此可取其中任意两位，或取其中两位与另外两位的叠加求和后舍去进位作为散列地址。

数字分析法的适用情况：事先必须明确知道所有的关键字每一位上各种数字的分布情况。

在实际应用中，例如，同一出版社出版的所有图书，其ISBN号的前几位都是相同的，因此，若数据表只包含同一出版社的图书，构造散列函数时可以利用这种数字分析排除ISBN号的前几位数字。

### 2．平方取中法

通常在选定散列函数时不一定能知道关键字的全部情况，取其中哪几位也不一定合适，而一个数平方后的中间几位数和数的每一位都相关，如果取关键字平方后的中间几位或其组合作为散列地址，则使随机分布的关键字得到的散列地址也是随机的，具体所取的位数由表长决定。平方取中法是一种较常用的构造散列函数的方法。

例如，为源程序中的标识符建立一个散列表，假设标识符为字母开头的字母数字串。假设人为约定每个标识的内部编码规则如下：把字母在字母表中的位置序号作为该字母的内部编码，如I的内部编码为09，D的内部编码为04，A的内部编码为01。数字直接用其自身作为内部编码，如1的内部编码为01，2的内部编码为02。根据以上编码规则，可知“IDA1”的内部编码为09040101，同理可以得到“IDB2”、“XID3”和“YID4”的内部编码。之后分别对内部编码进行平方运算，再取出第7位到第9位作为其相应标识符的散列地址，

![image-20240731110410818](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/image-20240731110410818.png)

​							标识符及其散列地址

平方取中法的适用情况：不能事先了解关键字的所有情况，或难于直接从关键字中找到取值较分散的几位。

### 3．折叠法

将关键字分割成位数相同的几部分（最后一部分的位数可以不同），然后取这几部分的叠加和（舍去进位）作为散列地址，这种方法称为折叠法。根据数位叠加的方式，可以把折叠法分为移位叠加和边界叠加两种。移位叠加是将分割后每一部分的最低位对齐，然后相加；边界叠加是将两个相邻的部分沿边界来回折叠，然后对齐相加。

例如，当散列表长为1000时，关键字key=45387765213，从左到右按3位数一段分割，可以得到4个部分：453、877、652、13。分别采用移位叠加和边界叠加，求得散列地址为995和914

![image-20240731110511734](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/image-20240731110511734.png)

​								由折叠法求得散列地址(28)

折叠法的适用情况：适合于散列地址的位数较少，而关键字的位数较多，且难于直接从关键字中找到取值较分散的几位。

### 4．除留余数法

假设散列表表长为m，选择一个不大于m的数p，用p去除关键字，除后所得余数为散列地址，即

```
H(key)=key%p
```

这个方法的关键是选取适当的p，一般情况下，可以选p为小于表长的最大质数。例如，表长m=100，可取p=97。

除留余数法计算简单，适用范围非常广，是最常用的构造散列函数的方法。它不仅可以对关键字直接取模，也可在折叠、平方取中等运算之后取模，这样能够保证散列地址一定落在散列表的地址空间中。

## 3.处理冲突的方法

选择一个“好”的散列函数可以在一定程度上减少冲突，但在实际应用中，很难完全避免发生冲突，所以选择一个有效的处理冲突的方法是散列法的另一个关键问题。创建散列表和查找散列表都会遇到冲突，两种情况下处理冲突的方法应该一致。下面以创建散列表为例，来说明处理冲突的方法。

冲突的方法与散列表本身的组织形式有关。按组织形式的不同，通常分两大类：开放地址法和链地址法。

### 1．开放地址法

开放地址法的基本思想是：把记录都存储在散列表数组中，当某一记录关键字key的初始散列地址H0=H(key)发生冲突时，以H0为基础，采取合适方法计算得到另一个地址H1，如果H1仍然发生冲突，以H1为基础再求下一个地址H2，若H2仍然冲突，再求得H3。依次类推，直至Hk不发生冲突为止，则Hk为该记录在表中的散列地址。

这种方法在寻找“下一个”空的散列地址时，原来的数组空间对所有的元素都是开放的，所以称为开放地址法。通常把寻找“下一个”空位的过程称为探测，上述方法可用如下公式表示：

```
Hi=(H(key)+di)%mi=1, 2, …, k (k≤m−1)
```

其中，H(key)为散列函数，m为散列表表长，di为增量序列。根据di取值的不同，可以分为以下3种探测方法。

#### （1）线性探测法

di=1, 2, 3, …, m−1这种探测方法可以将散列表假想成一个循环表，发生冲突时，从冲突地址的下一单元顺序寻找空单元，如果到最后一个位置也没找到空单元，则回到表头开始继续查找，直到找到一个空位，就把此元素放入此空位中。如果找不到空位，则说明散列表已满，需要进行溢出处理。

#### （2）二次探测法

```
di=12, −12, 22,−22, 32,…,+k2, −k2 (k≤m/2)
```

#### （3）伪随机探测法

```
di=伪随机数序列
```

例如，散列表的长度为11，散列函数H(key)=key%11，假设表中已填有关键字分别为17、60、29的记录，如图7.29（a）所示。现有第四个记录，其关键字为38，由散列函数得到散列地址为5，产生冲突。

若用线性探测法处理时，得到下一个地址6，仍冲突；再求下一个地址7，仍冲突；直到散列地址为8的位置为“空”时为止，处理冲突的过程结束，38填入散列表中序号为8的位置，如图7.29（b）所示。

若用二次探测法，散列地址5冲突后，得到下一个地址6，仍冲突；再求得下一个地址4，无冲突，38填入序号为4的位置，如图7.29（c）所示。

若用伪随机探测法，假设产生的伪随机数为9，则计算下一个散列地址为(5+9)%11=3，所以38填入序号为3的位置，如图7.29（d）所示。

![image-20240731110835519](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/image-20240731110835519.png)

​								开放地址法处理冲突时，关键字为38的记录插入前后的散列表(29)

从上述线性探测法处理的过程中可以看到一个现象：当表中i，i+1，i+2位置上已填有记录时，下一个散列地址为i、i+1、i+2和i+3的记录都将填入i+3的位置，这种在处理冲突过程中发生的两个第一个散列地址不同的记录争夺同一个后继散列地址的现象称作“二次聚集”（或称作“堆积”），即在处理同义词的冲突过程中又添加了非同义词的冲突。

可以看出，上述三种处理方法各有优缺点。线性探测法的优点是：只要散列表未填满，总能找到一个不发生冲突的地址。缺点是：会产生“二次聚集”现象。而二次探测法和伪随机探测法的优点是：可以避免“二次聚集”现象。缺点也很显然：不能保证一定找到不发生冲突的地址。

### 2．链地址法

链地址法的基本思想是：把具有相同散列地址的记录放在同一个单链表中，称为同义词链表。有m个散列地址就有m个单链表，同时用数组HT[0…m−1]存放各个链表的头指针，凡是散列地址为i的记录都以结点方式插入到以HT[i]为头结点的单链表中。

【例7.2】 已知一组关键字为（19, 14, 23, 1, 68,20, 84, 27, 55, 11, 10, 79），设散列函数H(key)=key %13，用链地址法处理冲突，试构造这组关键字的散列表。

由散列函数H(key)=key %13得知散列地址的值域为0～12，故整个散列表有13个单链表组成，用数组HT[0..12]存放各个链表的头指针。如散列地址均为1的同义词14、1、27、79构成一个单链表，链表的头指针保存在HT[1]中，同理，可以构造其他几个单链表，整个散列表的结构如图所示。

![image-20240731111045604](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/image-20240731111045604.png)

​						用链地址法处理冲突时的散列表(30)

这种构造方法在具体实现时，依次计算各个关键字的散列地址，然后根据散列地址将关键字插入到相应的链表中。

## 4.散列表的查找

在散列表上进行查找的过程和创建散列表的过程基本一致。算法7.10描述了开放地址法（线性探测法）处理冲突的散列表的查找过程。

下面以开放地址法为例，给出散列表的存储表示。

```c
//- - - - -开放地址法散列表的存储表示- - - - -
#define m 20                                            //散列表的表长
typedef struct{
    KeyType key;                                        //关键字项
    InfoType otherinfo;                                 //其他数据项
}HashTable[m];
```

###### 【算法步骤】

① 给定待查找的关键字key，根据造表时设定的散列函数计算H0=H(key)。

② 若单元H0为空，则所查元素不存在。

③ 若单元H0中元素的关键字为key，则查找成功。

④ 否则重复下述解决冲突的过程：

- 按处理冲突的方法，计算下一个散列地址Hi；
- 若单元Hi为空，则所查元素不存在；
- 若单元Hi中元素的关键字为key，则查找成功。

###### 【算法描述】

```c
#define NULLKEY 0                               //单元为空的标记
int SearchHash(HashTable HT,KeyType key)
{//在散列表HT中查找关键字为key的元素，若查找成功，返回散列表的单元标号，否则返回-1  
   H0=H(key);                                  //根据散列函数H（key）计算散列地址 
   if(HT[H0].key==NULLKEY) return -1;          //若单元H0为空，则所查元素不存在 
   else if(HT[H0].key==key) return H0;         //若单元H0中元素的关键字为key，则查找成功 
   else 
   { 
      for(i=1;i<m;++i) 
     {     
         Hi=(H0+i)%m;                          //按照线性探测法计算下一个散列地址Hi 
         if(HT[Hi].key==NULLKEY) return -1;    //若单元Hi为空，则所查元素不存在 
         else if(HT[Hi].key==key) return Hi;   //若单元Hi中元素的关键字为key，则查找成功 
      }                                        //for 
      return -1; 
    }                                          //else 
}
```

###### 【算法分析】

从散列表的查找过程可见：

（1）虽然散列表在关键字与记录的存储位置之间建立了直接映像，但由于“冲突”的产生，使得散列表的查找过程仍然是一个给定值和关键字进行比较的过程。因此，仍需以平均查找长度作为衡量散列表查找效率的量度。

（2）查找过程中需和给定值进行比较的关键字的个数取决于三个因素：散列函数、处理冲突的方法和散列表的装填因子。

散列表的装填因子α定义为

![image-20240731111348629](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/image-20240731111348629.png)

α标志散列表的装满程度。直观地看，α越小，发生冲突的可能性就越小；反之，α越大，表中已填入的记录越多，再填记录时，发生冲突的可能性就越大，则查找时，给定值需与之进行比较的关键字的个数也就越多。

（3）散列函数的“好坏”首先影响出现冲突的频繁程度。但一般情况下认为：凡是“均匀的”散列函数，对同一组随机的关键字，产生冲突的可能性相同，假如所设定的散列函数是“均匀”的，则影响平均查找长度的因素只有两个——处理冲突的方法和装填因子α。

下图给出了在等概率情况下，采用几种不同方法处理冲突时，得到的散列表查找成功和查找失败时的平均查找长度，证明过程从略。

![image-20240731111441272](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/image-20240731111441272.png)

​					用几种不同方法处理冲突时散列表的平均查找长度

（4）从表可以看出，散列表的平均查找长度是α的函数，而不是记录个数n的函数。由此，在设计散列表时，不管n多大，总可以选择合适的α以便将平均查找长度限定在一个范围内。

对于一个具体的散列表，通常采用直接计算的方法求其平均查找长度，下面通过具体示例说明。

(19, 14, 23, 1, 68,20, 84, 27, 55, 11, 10, 79)，仍设散列函数为H(key)=key %13，用线性探测法处理冲突。设表长为16，试构造这组关键字的散列表，并计算查找成功和查找失败时的平均查找长度。

依次计算各个关键字的散列地址，如果没有冲突，将关键字直接存放在相应的散列地址所对应的单元中；否则，用线性探测法处理冲突，直到找到相应的存储单元中。

如对于前三个关键字进行计算，H(19)=6，H(14)=1，H(23)=10，所得散列地址均没有冲突，直接填入所在单元。

而对于第四个关键字，H(1)=1，发生冲突，根据线性探测法，求得下一个地址(1+1)%16=2，没有冲突，所以1填入序号为2的单元。

同理，可依次填入其他关键字。对于最后一个关键字79，H(79)=1，发生冲突，用线性探测法处理冲突，后面的地址2～8均有冲突，最终79填入9号单元。

最终构造结果如表7.4所示，表中最后一行的数字表示放置该关键字时所进行的关键字比较次数。

![image-20240731112829309](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/image-20240731112829309.png)

​							用线性探测法处理冲突时的散列表(4)

要查找一个关键字key，首先用散列函数计算H0=H(key)，然后进行比较，比较的次数和创建散列表时放置此关键字的比较次数是相同的。

例如，查找19时，计算散列函数H(19)=6，HT[6].key非空且值为19，查找成功，关键字比较次数为1次。

同样，当查找关键字14、68、20、23、11时，均需比较1次即查找成功。

当查找关键字1时，计算散列函数H(1)=1，HT[1].key非空且值为14≠1，用线性探测法处理冲突，计算下一个地址为(1+1)%16=2，HT[2].key非空且值为1，查找成功，关键字比较次数为2次。

当查找关键字55，84，10时，需比较3次；当查找27时，需比较4次；而查找79时，需要比较9次才能查找成功。

在记录的查找概率相等的前提下，这组关键字采用线性探测法处理散列表冲突时，查找成功时的平均查找长度为

![image-20240731113013704](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/image-20240731113013704.png)

查找失败时有两种情况：

- （1）单元为空；
- （2）按处理冲突的方法探测一遍后仍未找到。假设散列函数的取值个数为r，则0到r−1相当于r个查找失败的入口，从每个入口进入后，直到确定查找失败为止，其关键字的比较次数就是与该入口对应的查找失败的查找长度。

在例7.3中，散列函数的取值个数为13，即总共有13个查找失败的入口（0到12），对每个入口依次进行计算。

假设待查找的关键字不在表中，若计算散列函数H(key)=0，HT[0].key为空，比较1次即确定查找失败。若H(key)=1，HT[1].key非空，则依次向后比较，直到HT[13].key为空，总共比较13次才能确定查找失败。类似地，对H(key)=2, 3,…, 12进行分析，可得查找失败的平均查找长度为

![image-20240731113125548](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/image-20240731113125548.png)

在例7.2中，采用链地址法处理冲突时，对于图7.30中所示的每个单链表中的第1个结点的关键字（如14、68、19、20、23、11），查找成功时只需比较1次，而对于第2个结点的关键字（如1、55、84、10），查找成功时需比较2次，第3个结点的关键字27需比较3次，第4个结点的关键字79则需比较4次才能查找成功。这时，查找成功时的平均查找长度为

![image-20240731113140508](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/image-20240731113140508.png)

采用链地址法处理冲突时，待查的关键字不在表中，若计算散列函数H(key)=0，HT[0]的指针域为空，比较1次即确定查找失败。若H(key)=1，HT[1]所指的单链表包括4个结点，所以需要比较5次才能确定失败。类似地，对H(key)=2, 3,…, 12进行分析，可得查找失败的平均查找长度为

![image-20240731113157501](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/image-20240731113157501.png)

容易看出，线性探测法在处理冲突的过程中易产生记录的二次聚集，使得散列地址不相同的记录又产生新的冲突；而链地址法处理冲突不会发生类似情况，因为散列地址不同的记录在不同的链表中，所以链地址法的平均查找长度小于开放地址法。另外，由于链地址法的结点空间是动态申请的，无需事先确定表的容量，因此更适用于表长不确定的情况。同时，易于实现插入和删除操作。

通过上面的示例，可以看出，在查找概率相等的前提下，直接计算查找成功的平均查找长度可以采用以下公式

![image-20240731113218498](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/image-20240731113218498.png)

其中，n为散列表中记录的个数，Ci为成功查找第i个记录所需的比较次数。

而直接计算查找失败的平均查找长度可以采用以下公式

![image-20240731113238119](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/image-20240731113238119.png)

其中，r为散列函数取值的个数，Ci为散列函数取值为i时查找失败的比较次数。
