# 一、排序的基本概念

## 1．排序
**排序**（Sorting）是按关键字的非递减或非递增顺序对一组记录重新进行排列的操作。确切描述如下。

假设含n个记录的序列为

![image-20240720083815468](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240720083815468.png)

其相应的关键字序列为

{K1, K2,…, Kn}

需确定1, 2, …, n的一种排列p1，p2，…，pn，使其相应的关键字满足如下的非递减（或非递增）关系

![image-20240720083902638](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240720083902638.png)

即使式（8-1）的序列成为一个按关键字有序的序列

![image-20240720083931009](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240720083931009.png)

这样一种操作称为排序

## 2．排序的稳定性

当排序记录中的关键字Ki（i=1, 2, …, n）都不相同时，则任何一个记录的无序序列经排序后得到的结果唯一；反之，当待排序的序列中存在两个或两个以上关键字相等的记录时，则排序所得的结果不唯一。假设Ki=Kj（1≤i≤n，1≤j≤n，i≠j），且在排序前的序列中Ri领先于Rj（即i<j）。若在排序后的序列中Ri仍领先于Rj，则称所用的排序方法是**稳定**的；反之，若可能使排序后的序列中Rj领先于Ri，则称所用的排序方法是**不稳定**的。注意，排序算法的稳定性是针对所有记录而言的。也就是说，在所有的待排序记录中，只要有一组关键字的实例不满足稳定性要求，则该排序方法就是不稳定的。虽然稳定的排序方法和不稳定的排序方法排序结果不同，但不能说不稳定的排序方法就不好，各有各的适用场合。

## 3．内部排序和外部排序

由于待排序记录的数量不同，使得排序过程中数据所占用的存储设备会有所不同。根据在排序过程中记录所占用的存储设备，可将排序方法分为两大类：一类是**内部排序**，指的是待排序记录全部存放在计算机内存中进行排序的过程；另一类是**外部排序**，指的是待排序记录的数量很大，以致内存一次不能容纳全部记录，在排序过程中尚需对外存进行访问的排序过程。

### 1).内部排序方法的分类

内部排序的方法很多，但就其全面性能而言，很难提出一种被认为是最好的方法，每一种方法都有各自的优缺点，适合在不同的环境（如记录的初始排列状态等）下使用

内部排序的过程是一个逐步扩大记录的有序序列长度的过程。在排序的过程中，可以将排序记录区分为两个区域：有序序列区和无序序列区

使有序区中记录的数目增加一个或几个的操作称为一趟排序。

根据逐步扩大记录有序序列长度的原则不同，可以将内部排序分为以下几类

- （1）插入类：将无序子序列中的一个或几个记录“插入”到有序序列中，从而增加记录的有序子序列的长度。主要包括直接插入排序、折半插入排序和希尔排序
- （2）交换类：通过“交换”无序序列中的记录从而得到其中关键字最小或最大的记录，并将它加入到有序子序列中，以此方法增加记录的有序子序列的长度。主要包括冒泡排序和快速排序
- （3）选择类：从记录的无序子序列中“选择”关键字最小或最大的记录，并将它加入到有序子序列中，以此方法增加记录的有序子序列的长度。主要包括简单选择排序、树形选择排序和堆排序
- （4）归并类：通过“归并”两个或两个以上的记录有序子序列，逐步增加记录有序序列的长度。2-路归并排序是最为常见的归并排序方法
- （5）分配类：是唯一一类不需要进行关键字之间比较的排序方法，排序时主要利用分配和收集两种基本操作来完成。基数排序是主要的分配类排序方法。

### 2).待排序记录的存储方式

- （1）顺序表：记录之间的次序关系由其存储位置决定，实现排序需要移动记录
- （2）链表：记录之间的次序关系由指针指示，实现排序不需要移动记录，仅需修改指针即可。这种排序方式称为链表排序
- （3）待排序记录本身存储在一组地址连续的存储单元内，同时另设一个指示各个记录存储位置的地址向量，在排序过程中不移动记录本身，而移动地址向量中这些记录的“地址”，在排序结束之后再按照地址向量中的值调整记录的存储位置。这种排序方式称为地址排序。

在本章的讨论中，除基数排序外，待排序记录均按上述第一种方式存储，且为了讨论方便，设记录的关键字均为整数。

即在以后讨论的大部分算法中，待排序记录的数据类型定义为：
```c
#define MAXSIZE 20                                 //顺序表的最大长度
typedef int KeyType;                            //定义关键字类型为整型
typedef struct{
    KeyType key;                                //关键字项
    InfoType otherinfo;                         //其他数据项
}RedType;                                       //记录类型
typedef struct{
    RedType r[MAXSIZE+1];                       //r[0]闲置或用做哨兵单元
    int length;                                 //顺序表长度
}SqList;                                        //顺序表类型
```

### 3).排序算法效率的评价指标
前面已指出，就排序方法的全面性能而言，很难提出一种被认为是最好的方法。目前，评价排序算法好坏的标准主要有两点

#### （1）执行时间
对于排序操作，时间主要消耗在关键字之间的比较和记录的移动上（这里，只考虑以顺序表方式存储待排序记录），排序算法的时间复杂度由这两个指标决定。因此可以认为，高效的排序算法的比较次数和移动次数都应该尽可能的少

#### （2）辅助空间
空间复杂度由排序算法所需的辅助空间决定。辅助空间是除了存放待排序记录占用的空间之外，执行算法所需要的其他存储空间。理想的空间复杂度为O(1)，即算法执行期间所需要的辅助空间与待排序的数据量无关。
# 二、插入排序

插入排序的基本思想是：每一趟将一个待排序的记录，按其关键字的大小插入到已经排好序的一组记录的适当位置上，直到所有待排序记录全部插入为止。

例如，打扑克牌在抓牌时要保证抓过的牌有序排列，则每抓一张牌，就插入到合适的位置，直到抓完牌为止，即可得到一个有序序列。

可以选择不同的方法在已排好序的记录中寻找插入位置。根据查找方法的不同，有多种插入排序方法，这里仅介绍三种方法：直接插入排序、折半插入排序和希尔排序。

## 1).直接插入排序
###### 【算法步骤】
① 设待排序的记录存放在数组r[1..n]中，r[1]是一个有序序列

② 循环n−1次，每次使用顺序查找法，查找r[i]（i=2,…,n）在已排好序的序列r[1…i−1]中的插入位置，然后将r[i]插入表长为i−1的有序序列r[1…i−1]，直到将r[n]插入表长为n−1的有序序列r[1…n-1]，最后得到一个表长为n的有序序列。

已知待排序记录的关键字序列为{49,38,65,97,76,13,27,**49**}，请给出用直接插入排序法进行排序的过程。

直接插入排序过程如图所示，其中( )中为已排好序的记录的关键字。
![image-20240720091009952](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240720091009952.png)

具体实现r[i]向前面的有序序列插入时，有两种方法：一种是将r[i]与r[1], r[2], …, r[i-1]从前向后顺序比较；另一种是将r[i]与r[i−1], r[i−2], …, r[1]从后向前顺序比较。这里采用后一种方法，和顺序查找类似，为了在查找插入位置的过程中避免数组下标出界，在r[0]处设置监视哨。在自i−1起往前查找插入位置的过程中，可以同时后移记录。
###### 【算法描述】

```c
void InsertSort(SqList &L)
{//对顺序表L做直接插入排序 
   for(i=2;i<=L.length;++i) 
      if(L.r[i].key<L.r[i-1].key)                 //“<”，需将r[i]插入有序子表 
      {  
         L.r[0]=L.r[i];                          //将待插入的记录暂存到监视哨中 
         L.r[i]=L.r[i-1];                        //r[i-1]后移 
         for(j=i-2; L.r[0].key<L.r[j].key; --j)  //从后向前寻找插入位置 
            L.r[j+1]=L.r[j];                     //记录逐个后移，直到找到插入位置 
         L.r[j+1]=L.r[0];                        //将r[0]即原r[i]，插入到正确位置 
      }                                          //if 
}
```

###### 【算法分析】
### （1）时间复杂度
从时间来看，排序的基本操作为：比较两个关键字的大小和移动记录。
对于其中的某一趟插入排序，算法中内层的for循环次数取决于待插记录的关键字与前i-1个记录的关键字之间的关系。其中，在最好情况（正序：待排序序列中记录按关键字非递减有序排列）下，比较1次，不移动；在最坏情况（逆序：待排序序列中记录按关键字非递增有序排列）下，比较i次（依次同前面的i−1个记录进行比较，并和哨兵比较1次），移动i+1次（前面的i−1个记录依次向后移动，另外开始时将待插入的记录移动到监视哨中，最后找到插入位置，又从监视哨中移过去）。
对于整个排序过程需执行n−1趟，最好情况下，总的比较次数达最小值n−1，记录不需移动；最坏情况下，总的关键字比较次数KCN和记录移动次数RMN均达到最大值，分别为

![image-20240720091104404](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240720091104404.png)

若待排序序列中出现各种可能排列的概率相同，则可取上述最好情况和最坏情况的平均情况。在平均情况下，直接插入排序关键字的比较次数和记录移动次数均约为n2/4。
由此，直接插入排序的时间复杂度为O(n2)

### （2）空间复杂度
直接插入排序只需要一个记录的辅助空间r[0]，所以空间复杂度为O(1)。
###### 【算法特点】
		（1）稳定排序
		（2）算法简便，且容易实现
		（3）也适用于链式存储结构，只是在单链表上无需移动记录，只需修改相应的指针。
		（4）更适合于初始记录基本有序（正序）的情况，当初始记录无序，n较大时，此算法时间复杂度较高，不宜采用。
## 2).折半插入排序
直接插入排序采用顺序查找法查找当前记录在已排好序的序列中的插入位置，从7.2节的讨论中可知，这个“查找”操作可利用“折半查找”来实现，由此进行的插入排序称之为折半插入排序（Binary Insertion Sort）。
###### 【算法步骤】
① 设待排序的记录存放在数组r[1…n]中，r[1]是一个有序序列
② 循环n−1次，每次使用折半查找法，查找r[i]（i=2, …, n）在已排好序的序列r[1..i−1]中的插入位置，然后将r[i]插入表长为i−1的有序序列r[1…i−1]，直到将r[n]插入表长为n−1的有序序列r[1…n−1]，最后得到一个表长为n的有序序列。
###### 【算法描述】
```c
void BInsertSort(SqList &L)
{//对顺序表L做折半插入排序 
   for(i=2;i<=L.length;++i) 
   { 
      L.r[0]=L.r[i];                              //将待插入的记录暂存到监视哨中 
      low=1;high=i-1;                             //置查找区间初值 
      while(low<=high)                            //在r[low..high]中折半查找插入的位置
      {        
         m=(low+high)/2;                           //折半 
         if(L.r[0].key<L.r[m].key) high=m-1;       //插入点在前一子表 
         else low=m+1;                             //插入点在后一子表 
      }                                            //while 
      for(j=i-1;j>=high+1; --j) L.r[j+1]=L.r[j];   //记录后移 
      L.r[high+1]=L.r[0];                          //将r[0]即原r[i]，插入到正确位置 
   }                                               //for 
}
```
###### 【算法分析】
（1）时间复杂度从时间上比较，折半查找比顺序查找快，所以就平均性能来说，折半插入排序优于直接插入排序。折半插入排序所需要的关键字比较次数与待排序序列的初始排列无关，仅依赖于记录的个数。不论初始序列情况如何，在插入第i个记录时，需要经过[插图]次比较，才能确定它应插入的位置。所以当记录的初始排列为正序或接近正序时，直接插入排序比折半插入排序执行的关键字比较次数要少。折半插入排序的对象移动次数与直接插入排序相同，依赖于对象的初始排列。在平均情况下，折半插入排序仅减少了关键字间的比较次数，而记录的移动次数不变。因此，折半插入排序的时间复杂度仍为O(n2)。
（2）空间复杂度折半插入排序所需附加存储空间和直接插入排序相同，只需要一个记录的辅助空间r[0]，所以空间复杂度为O(1)。
###### 【算法特点】
（1）稳定排序
（2）因为要进行折半查找，所以只能用于顺序结构，不能用于链式结构
（3）适合初始记录无序、n较大时的情况。

## 3).希尔排序
希尔排序（Shell's Sort）又称“缩小增量排序”（Diminishing Increment Sort），是插入排序的一种，因D.L.Shell于1959年提出而得名。
直接插入排序，当待排序的记录个数较少且待排序序列的关键字基本有序时，效率较高。希尔排序基于以上两点，从“减少记录个数”和“序列基本有序”两个方面对直接插入排序进行了改进。算法8.3 希尔排序
###### 【算法步骤】
希尔排序实质上是采用分组插入的方法。先将整个待排序记录序列分割成几组，从而减少参与直接插入排序的数据量，对每组分别进行直接插入排序，然后增加每组的数据量，重新分组。这样当经过几次分组排序后，整个序列中的记录“基本有序”时，再对全体记录进行一次直接插入排序。希尔对记录的分组，不是简单地“逐段分割”，而是将相隔某个“增量”的记录分成一组。
- ① 第一趟取增量d1（d1<n）把全部记录分成d1个组，所有间隔为d1的记录分在同一组，在各个组中进行直接插入排序

- ② 第二趟取增量d2（d2<d1），重复上述的分组和排序

- ③ 依次类推，直到所取的增量dt=1（dt<dt−1 <…< d2 < d1），所有记录在同一组中进行直接插入排序为止。

- 已知待排序记录的关键字序列为{49,38,65,97,76,13,27,**49**,55,04}，请给出用希尔排序法进行排序的过程。
  ![image-20240720091345828](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240720091345828.png)

  

  （1）第一趟取增量d1=5，所有间隔为5的记录分在同一组，全部记录分成5组，在各个组中分别进行直接插入排序，排序结果如图8.2的第7行所示。
  （2）第二趟取增量d2=3，所有间隔为3的记录分在同一组，全部记录分成3组，在各个组中分别进行直接插入排序，排序结果如图8.2的第11行所示。
  （3)第三趟取增量d3=1，对整个序列进行一趟直接插入排序，排序完成。

预设好的增量序列保存在数组dt[0…t−1]中，整个希尔排序算法需执行t趟。从上述排序过程可见，

算法中的直接插入排序可以看成一趟增量是1的希尔排序，所以可以通过改写算法8.1，得到一趟希尔排序算法ShellInsert。在ShellInsert中，具体改写主要有两处：
		（1）前后记录位置的增量是dk，而不是1
		（2）r[0]只是暂存单元，不是哨兵。当j≤0时，插入位置已找到
###### 【算法描述】
```c
void ShellInsert(SqList &L, int dk)
{//对顺序表L做一趟增量是dk的希尔插入排序 
   for(i=dk+1;i<=L.length;++i) 
      if(L.r[i].key<L.r[i-dk].key)     //需将L.r[i]插入有序增量子表 
      {     
         L.r[0]=L.r[i];                //暂存在L.r[0] 
         for(j=i-dk; j>0&& L.r[0].key<L.r[j].key;j-=dk) 
            L.r[j+dk]=L.r[j];          //记录后移，直到找到插入位置 
         L.r[j+dk]=L.r[0];             //将r[0]即原r[i]，插入到正确位置 
      }                                //if 
}            
@@@@
void ShellSort(SqList &L,int dt[],int t) 
{//按增量序列dt[0..t-1]对顺序表L作t趟希尔排序 
   for(k=0;k<t;++k) 
      ShellInsert(L,dt[k]);            //一趟增量为dt[t]的希尔插入排序 
}
```
###### 【算法分析】
### （1）时间复杂度
当增量大于1时，关键字较小的记录就不是一步一步地挪动，而是跳跃式地移动，从而使得在进行最后一趟增量为1的插入排序中，序列已基本有序，只要做记录的少量比较和移动即可完成排序，因此希尔排序的时间复杂度较直接插入排序低。但要具体进行分析，则是一个复杂的问题，因为希尔排序的时间复杂度是所取“增量”序列的函数，这涉及一些数学上尚未解决的难题。因此，到目前为止尚未有人求得一种最好的增量序列，但大量的研究已得出一些局部的结论。如有人指出，当增量序列为dt[k]=2t−k+1−1时，希尔排序的时间复杂度为O(n3/2)，其中t为排序趟数，[插图]。还有人在大量的实验基础上推出：当n在某个特定范围内，希尔排序所需的比较和移动次数约为n1.3，当n→∞时，可减少到n(log2n)2。
### （2）空间复杂度
从空间来看，希尔排序和前面两种排序方法一样，也只需要一个辅助空间r[0]，空间复杂度为O(1)。
###### 【算法特点】
（1）记录跳跃式地移动导致排序方法是不稳定的
（2）只能用于顺序结构，不能用于链式结构
（3）增量序列可以有各种取法，但应该使增量序列中的值没有除1之外的公因子，并且最后一个增量值必须等于1
（4）记录总的比较次数和移动次数都比直接插入排序要少，n越大时，效果越明显。所以适合初始记录无序、n较大时的情况。

# 三、交换排序

交换排序的基本思想是：两两比较待排序记录的关键字，一旦发现两个记录不满足次序要求时则进行交换，直到整个序列全部满足要求为止。

## 1 冒泡排序

**冒泡排序**（Bubble Sort）是一种最简单的交换排序方法，它通过两两比较相邻记录的关键字，如果发生逆序，则进行交换，从而使关键字小的记录如气泡一般逐渐往上“漂浮”（左移），或者使关键字大的记录如石块一样逐渐向下“坠落”（右移）。

###### 【算法步骤】

① 设待排序的记录存放在数组r[1…n]中。首先将第一个记录的关键字和第二个记录的关键字进行比较，若为逆序（即L.r[1].key>L.r[2].key），则交换两个记录。然后比较第二个记录和第三个记录的关键字。依次类推，直至第n−1个记录和第n个记录的关键字进行过比较为止。上述过程称作第一趟起泡排序，其结果使得关键字最大的记录被安置到最后一个记录的位置上

② 然后进行第二趟起泡排序，对前n−1个记录进行同样操作，其结果是使关键字次大的记录被安置到第n−1个记录的位置上

③ 重复上述比较和交换过程，第i趟是从L.r[1]到L.r[n−i+1]依次比较相邻两个记录的关键字，并在“逆序”时交换相邻记录，其结果是这n−i+1个记录中关键字最大的记录被交换到第n−i+1的位置上。直到在某一趟排序过程中没有进行过交换记录的操作，说明序列已全部达到排序要求，则完成排序。

已知待排序记录的关键字序列为{49,38,65,97,76,13,27,**49**}，请给出用冒泡排序法进行排序的过程。

![image-20240720125500230](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240720125500230.png)

待排序的记录总共有8个，但算法在第六趟排序过程中没有进行过交换记录的操作，则完成排序。

###### 【算法描述】

```c
void BubbleSort(SqList &L)
{//对顺序表L做冒泡排序 
   m=L.length-1;flag=1;                           //flag用来标记某一趟排序是否发生交换 
   while((m>0)&&(flag==1)) 
   { 
      flag=0;                                     //flag置为0，如果本趟排序没有发生交换，则不会执行下一趟排序 
      for(j=1;j<=m;j++) 
         if(L.r[j].key>L.r[j+1].key) 
         { 
            flag=1;                                //flag置为1，表示本趟排序发生了交换 
            t=L.r[j]; L.r[j]=L.r[j+1]; L.r[j+1]=t;//交换前后两个记录 
          }                                       //if 
        --m; 
    }                                            //while 
}                                                //BubbleSort
```

###### 【算法分析】

### （1）时间复杂度

最好情况（初始序列为正序）：只需进行一趟排序，在排序过程中进行n−1次关键字间的比较，且不移动记录。最坏情况（初始序列为逆序）：需进行n−1趟排序，总的关键字比较次数KCN和记录移动次数RMN（每次交换都要移动3次记录）分别为

![image-20240720125649836](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240720125649836.png)

所以，在平均情况下，冒泡排序关键字的比较次数和记录移动次数分别约为n2/4和3n2/4，时间复杂度为O(n2)。

### （2）空间复杂度

冒泡排序只有在两个记录交换位置时需要一个辅助空间用做暂存记录，所以空间复杂度为O(1)

###### 【算法特点】

```
（1）稳定排序
（2）可用于链式存储结构
（3）移动记录次数较多，算法平均时间性能比直接插入排序差。当初始记录无序，n较大时，此算法不宜采用
```

## 2.快速排序

快速排序（Quick Sort）是由冒泡排序改进而得的。在冒泡排序过程中，只对相邻的两个记录进行比较，因此每次交换两个相邻记录时只能消除一个逆序。如果能通过两个（不相邻）记录的一次交换，消除多个逆序，则会大大加快排序的速度。快速排序方法中的一次交换可能消除多个逆序。

###### 【算法步骤】

在待排序的n个记录中任取一个记录（通常取第一个记录）作为枢轴（或支点），设其关键字为pivotkey。经过一趟排序后，把所有关键字小于pivotkey的记录交换到前面，把所有关键字大于pivotkey的记录交换到后面，结果将待排序记录分成两个子表，最后将枢轴放置在分界处的位置。然后，分别对左、右子表重复上述过程，直至每一子表只有一个记录时，排序完成。其中，一趟快速排序的具体步骤如下

① 选择待排序表中的第一个记录作为枢轴，将枢轴记录暂存在r[0]的位置上。附设两个指针low和high，初始时分别指向表的下界和上界（第一趟时，low=1; high=L.length;）

② 从表的最右侧位置依次向左搜索，找到第一个关键字小于枢轴关键字pivotkey的记录，将其移到low处。具体操作是：当low<high时，若high所指记录的关键字大于等于pivotkey，则向左移动指针high（执行操作--high）；否则将high所指记录与枢轴记录交换

③ 然后再从表的最左侧位置，依次向右搜索找到第一个关键字大于pivotkey的记录和枢轴记录交换。具体操作是：当low<high时，若low所指记录的关键字小于等于pivotkey，则向右移动指针low（执行操作++low）；否则将low所指记录与枢轴记录交换

④ 重复步骤②和③，直至low与high相等为止。此时low或high的位置即为枢轴在此趟排序中的最终位置，原表被分成两个子表。在上述过程中，记录的交换都是与枢轴之间发生，每次交换都要移动3次记录，可以先将枢轴记录暂存在r[0]的位置上，排序过程中只移动要与枢轴交换的记录，即只做r[low]或r[high]的单向移动，直至一趟排序结束后再将枢轴记录移至正确位置上

已知待排序记录的关键字序列为{49,38,65,97,76,13,27,**49**}，请给出用快速排序法进行排序的过程

![image-20240720125855982](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240720125855982.png)

由上述可知，整个快速排序的过程可递归进行，其递归树如图8.5所示。快速排序的算法实现如算法8.5所示。其中，算法Partition完成一趟快速排序，返回枢轴的位置。若待排序序列长度大于1（low<high），算法QuickSort调用Partition获取枢轴位置，然后递归执行分别对分割所得的两个子表进行排序。若待排序序列中只有一个记录，递归结束，排序完成

![image-20240720130040550](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240720130040550.png)

​								快速排序的递归树

###### 【算法描述】

```c
int Partition(SqList &L, int low, int high)
{//对顺序表L中的子表r[low..high]进行一趟排序，返回枢轴位置 
   L.r[0]=L.r[low];                     //用子表的第一个记录做枢轴记录 
   pivotkey=L.r[low].key;               //枢轴记录关键字保存在pivotkey中 
   while(low<high)                      //从表的两端交替地向中间扫描 
   {      
      while(low<high&&L.r[high].key>=pivotkey) --high; 
      L.r[low]=L.r[high];               //将比枢轴记录小的记录移到低端 
      while(low<high&&L.r[low].key<=pivotkey) ++low; 
      L.r[high]=L.r[low];               //将比枢轴记录大的记录移到高端 
   }                                    //while 
   L.r[low]=L.r[0];                     //枢轴记录到位 
   return low;                          //返回枢轴位置 
}          
@@@@
void QSort(SqList &L,int low,int high) 
{//调用前置初值：low=1; high=L.length; 
 //对顺序表L中的子序列L.r[low..high]做快速排序 
   if(low<high){                        //长度大于1 
      pivotloc=Partition(L, low, high); //将L.r[low..high]一分为二，pivotloc是枢轴位置 
      QSort(L, low, pivotloc-1);        //对左子表递归排序 
      QSort(L, pivotloc+1, high);       //对右子表递归排序 
   } 
}  
@@@@
void QuickSort(SqList &L) 
{//对顺序表L做快速排序 
   QSort(L,1,L.length); 
}
```

###### 【算法分析】

### （1）时间复杂度

从快速排序算法的递归树可知，快速排序的趟数取决于递归树的深度

最好情况：每一趟排序后都能将记录序列均匀地分割成两个长度大致相等的子表，类似折半查找。在n个元素的序列中，对枢轴定位所需时间为O(n)。若设T(n)是对n个元素的序列进行排序所需的时间，而且每次对枢轴正确定位后，正好把序列划分为长度相等的两个子表，此时，设Cn是一个常数，表示n个元素进行一趟快速排序的时间，则总的排序时间为

T(n)=Cn+2T(n/2 )

≤n+2T(n/2 )

≤n+2(n/2+2T(n/4))=2n+4T(n/4)

≤2n+4(n/4+2T(n/8))=3n+8T(n/8)……

≤kn+2kT(n/2k)

∵ k=log2n

∴ T(n)≤nlog2n+nT(1)≈O(nlog2n)

最坏情况：在待排序序列已经排好序的情况下，其递归树成为单支树，每次划分只得到一个比上一次少一个记录的子序列。这样，必须经过n−1趟才能将所有记录定位，而且第i趟需要经过n−i次比较。这样，总的关键字比较次数KCN为

![image-20240720130217147](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240720130217147.png)

这种情况下，快速排序的速度已经退化到简单排序的水平。枢轴记录的合理选择可避免这种最坏情况的出现，如利用“三者取中”的规则：比较当前表中第一个记录、最后一个记录和中间一个记录的关键字，取关键字居中的记录作为枢轴记录，事先调换到第一个记录的位置

理论上可以证明，平均情况下，快速排序的时间复杂度为O(nlog2n)。

### 2）空间复杂度

快速排序是递归的，执行时需要有一个栈来存放相应的数据。最大递归调用次数与递归树的深度一致，所以最好情况下的空间复杂度为O(log2n)，最坏情况下为O(n)。

###### 【算法特点】

```
（1）记录非顺次的移动导致排序方法是不稳定的
（2）排序过程中需要定位表的下界和上界，所以适合用于顺序结构，很难用于链式结构
（3）当n较大时，在平均情况下快速排序是所有内部排序方法中速度最快的一种，所以其适合初始记录无序、n较大时的情况
```

# 四\选择排序

选择排序的基本思想是：每一趟从待排序的记录中选出关键字最小的记录，按顺序放在已排序的记录序列的最后，直到全部排完为止。本节首先介绍一种简单选择排序方法，然后给出另一种改进的选择排序方法——堆排序

## 1).简单选择排序

**简单选择排序（Simple Selection Sort）也称作直接选择排序**

###### 【算法步骤】

① 设待排序的记录存放在数组r[1…n]中。第一趟从r[1]开始，通过n−1次比较，从n个记录中选出关键字最小的记录，记为r[k]，交换r[1]和r[k]

② 第二趟从r[2]开始，通过n−2次比较，从n−1个记录中选出关键字最小的记录，记为r[k]，交换r[2]和r[k]

③ 依次类推，第i趟从r[i]开始，通过n−i次比较，从n−i+1个记录中选出关键字最小的记录，记为r[k]，交换r[i]和r[k]

④ 经过n−1趟，排序完成

 已知待排序记录的关键字序列为{49,38,65,97,76,13,27,**49**},给出用简单选择排序法进行排序的过程。

![image-20240720130505199](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240720130505199.png)

​								简单选择排序过程

###### 【算法描述】

```c
void SelectSort(SqList &L)
{//对顺序表L做简单选择排序 
   for(i=1;i<L.length;++i){                     //在L.r[i..L.length] 中选择关键字最小的记录 
      k=i;                  
      for(j=i+1;j<=L.length;++j) 
         if(L.r[j].key<L.r[k].key) k=j;        //k指向此趟排序中关键字最小的记录 
      if(k!=i) 
         {t=L.r[i]; L.r[i]=L.r[k]; L.r[k]=t;}  //交换r[i]与r[k]         
    }                                          //for   
}
```

###### 【算法分析】

### （1）时间复杂度

简单选择排序过程中，所需进行记录移动的次数较少。最好情况（正序）：不移动；最坏情况（逆序）：移动3(n−1)次。然而，无论记录的初始排列如何，所需进行的关键字间的比较次数相同，均为

![image-20240720130557195](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240720130557195.png)

因此，简单选择排序的时间复杂度也是O(n^2^)

### （2）空间复杂度

同冒泡排序一样，只有在两个记录交换时需要一个辅助空间，所以空间复杂度为O(1)

###### 【算法特点】

（1）就选择排序方法本身来讲，它是一种稳定的排序方法，但图8.6所表现出来的现象是不稳定的，这是因为上述实现选择排序的算法采用“交换记录”的策略所造成的，改变这个策略，可以写出不产生“不稳定现象”的选择排序算法

（2）可用于链式存储结构

（3）移动记录次数较少，当每一记录占用的空间较多时，此方法比直接插入排序快。

从上述可见，选择排序的主要操作是进行关键字间的比较，因此改进简单选择排序应从如何减少“比较”出发考虑。显然，在n个关键字中选出最小值，至少要进行n−1次比较，然而，继续在剩余的n−1个关键字中选择次小值并非一定要进行n−2次比较，若能利用前n−1次比较所得信息，则可减少以后各趟选择排序中所用的比较次数。实际上，体育比赛中的锦标赛便是一种选择排序。例如，在8个运动员中决出前3名至多需要11场比赛，而不是7+6+5=18场比赛（它的前提是，若乙胜丙，甲胜乙，则认为甲必能胜丙）。例如，图（a）中最低层的叶子结点中8个选手之间经过第一轮的4场比寒之后选拔出4个优胜者“CHA”、“BAO”、“DIAO”和“WANG”，然后经过两场半决赛和一场决赛之后，选拔出冠军“BAO”。显然，按照锦标赛的传递关系，亚军只能产生于分别在决赛、半决赛和第一轮比赛中输给冠军的选手中。由此，在经过“CHA”和“LIU”、“CHA”和“DIAO”的两场比赛之后，选拔出亚军“CHA”，同理，选拔季军的比赛只要在“ZHAO”、“LIU”和“DIAO”3个选手之间进行即可。按照这种锦标赛的思想可导出树形选择排序。

![image-20240720130709014](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240720130709014.png)

## 2).树形选择排序

树形选择排序（Tree Selection Sort），又称锦标赛排序（Tournament Sort），是一种按照锦标赛的思想进行选择排序的方法。首先对n个记录的关键字进行两两比较，然后在其中[插图]个较小者之间再进行两两比较，如此重复，直至选出最小关键字的记录为止。这个过程可用一棵有n个叶子结点的完全二叉树表示。例如，图8.8（a）中的二叉树表示从8个关键字中选出最小关键字的过程。8个叶子结点中依次存放排序之前的8个关键字，每个非终端结点中的关键字均等于其左、右孩子结点中较小的关键字，则根结点中的关键字即为叶子结点中的最小关键字。在输出最小关键字之后，根据关系的可传递性，欲选出次小关键字，仅需将叶子结点中的最小关键字（13）改为“最大值”，然后从该叶子结点开始，和其左（或右）兄弟的关键字进行比较，修改从叶子结点到根的路径上各结点的关键字，则根结点的关键字即为次小关键字。同理，可依次选出从小到大的所有关键字（参见图8.8（b）和（c））。由于含有n个叶子结点的完全二叉树的深度为[插图]，则在树形选择排序中，除了最小关键字之外，每选择一个次小关键字仅需进行[插图]次比较，因此，它的时间复杂度为O（nlog2n）。但是，这种排序方法尚有辅助存储空间较多、和“最大值”进行多余的比较等缺点。为了改进这个缺点，威洛姆斯（J.Willioms）在1964提年出了另一种形式的选择排序——堆排序。

![image-20240720130858432](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240720130858432.png)

​								树形选择排序示例

## 3).堆排序

堆排序（Heap Sort）是一种树形选择排序，在排序过程中，将待排序的记录r[1..n]看成是一棵完全二叉树的顺序存储结构，利用完全二叉树中双亲结点和孩子结点之间的内在关系，在当前无序的序列中选择关键字最大（或最小）的记录。

首先给出堆的定义。

n个元素的序列{k1,k2,…,kn}称之为堆，当且仅当满足以下条件时：

![image-20240720130954016](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240720130954016.png)

若将和此序列对应的一维数组（即以一维数组做此序列的存储结构）看成是一个完全二叉树，则堆实质上是满足如下性质的完全二叉树：树中所有非终端结点的值均不大于（或不小于）其左、右孩子结点的值。

例如，关键字序列{96,83,27,38,11,09}和{12,36,24,85,47,30,53,91}分别满足条件（1）和条件（2），故它们均为堆，对应的完全二叉树分别如图8.9（a）和（b）所示。显然，在这两种堆中，堆顶元素（或完全二叉树的根）必为序列中n个元素的最大值（或最小值），分别称之为大根堆（或小根堆）

![image-20240720131030192](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240720131030192.png)

​								堆的示例

堆排序利用了大根堆（或小根堆）堆顶记录的关键字最大（或最小）这一特征，使得当前无序的序列中选择关键字最大（或最小）的记录变得简单。

下面讨论用大根堆进行排序，堆排序的步骤如下。

① 按堆的定义将待排序序列r[1..n]调整为大根堆（这个过程称为建初堆），交换r[1]和r[n]，则r[n]为关键字最大的记录

② 将r[1..n−1]重新调整为堆，交换r[1]和r[n−1]，则r[n−1]为关键字次大的记录

③ 循环n−1次，直到交换了r[1]和r[2]为止，得到了一个非递减的有序序列r[1..n]

同样，可以通过构造小根堆得到一个非递增的有序序列

由此，实现堆排序需要解决如下两个问题

（1）建初堆：如何将一个无序序列建成一个堆？

（2）调整堆：去掉堆顶元素，在堆顶元素改变之后，如何调整剩余元素成为一个新的堆？

因为建初堆要用到调整堆的操作，所以下面先讨论调整堆的实现。

### 1．调整堆

先看一个例子，图8.10（a）是个堆，将堆顶元素97和堆中最后一个元素38交换后，如图（b）所示。由于此时除根结点外，其余结点均满足堆的性质，由此仅需自上至下进行一条路径上的结点调整即可。首先以堆顶元素38和其左、右子树根结点的值进行比较，由于左子树根结点的值大于右子树根结点的值且大于根结点的值，则将38和76交换；由于38替代了76之后破坏了左子树的“堆”，则需进行和上述相同的调整，直至叶子结点，调整后的状态如图（c）所示。重复上述过程，将堆顶元素76和堆中最后一个元素27交换且调整，得到如图（d）所示新的堆。

![image-20240720131207863](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240720131207863.png)

​						堆顶元素改变后调整堆的过程

上述过程就像过筛子一样，把较小的关键字逐层筛下去，而将较大的关键字逐层选上来。因此，称此方法为“筛选法”

假设r[s+1..m]已经是堆的情况下，按“筛选法”将r[s..m]调整为以r[s]为根的堆，算法实现如下。

###### 【算法步骤】

从r[2s]和r[2s+l]中选出关键字较大者，假设r[2s]的关键字较大，比较r[s]和r[2s]的关键字

① 若r[s].key>=r[2s].key，说明以r[s]为根的子树已经是堆，不必做任何调整

② 若r[s].key<r[2s].key，交换r[s]和r[2s]。交换后，以r[2s+l]为根的子树仍是堆，如果以r[2s]为根的子树不是堆，则重复上述过程，将以r[2s]为根的子树调整为堆，直至进行到叶子结点为止。

###### 【算法描述】

```
void HeapAdjust(SqList &L,int s,int m)
{//假设r[s+1..m]已经是堆，将r[s..m]调整为以r[s]为根的大根堆 
   rc=L.r[s]; 
   for(j=2*s;j<=m;j*=2)                     //沿key较大的孩子结点向下筛选 
   {       
      if(j<m&&L.r[j].key<L.r[j+1].key) ++j; //j为key较大的记录的下标 
      if(rc.key>=L.r[j].key) break;         //rc应插入在位置s上 
      L.r[s]=L.r[j];s=j; 
   }                                        //for 
   L.r[s]=rc;                              //插入 
}
```

### 2．建初堆

要将一个无序序列调整为堆，就必须将其所对应的完全二叉树中以每一结点为根的子树都调整为堆。显然，只有一个结点的树必是堆，而在完全二叉树中，所有序号大于[插图]的结点都是叶子，因此以这些结点为根的子树均已是堆。这样，只需利用筛选法，从最后一个分支结点[插图]开始，依次将序号为[插图]的结点作为根的子树都调整为堆即可

###### 【算法步骤】

对于无序序列r[1…n]，从i=n/2开始，反复调用筛选法HeapAdjust (L,i,n)，依次将以r[i]，r[i−1],…,r[1]为根的子树调整为堆

###### 【算法描述】

```c
void CreatHeap(SqList &L)
{//把无序序列L.r[1..n]建成大根堆
   n=L.length;
   for(i=n/2;i>0; --i)                  //反复调用HeapAdjust
     HeapAdjust(L,i,n);
}
```



已知无序序列为{49,38,65,97,76,13,27,**49**}，用“筛选法”将其调整为一个大根堆，给出建堆的过程。

从图（a）所示的无序序列的最后一个非终端结点开始筛选，即从第4个元素97开始，由于97>49，则无需交换。同理，第3个元素65不小于其左、右子树根的值，仍无需交换。而第2个元素38<97，被筛选之后序列的状态如图（b）所示，然后对根元素49筛选之后得到图（c）所示的大根堆。

![image-20240720131516494](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240720131516494.png)

​									建初堆的过程

### 3．堆排序算法的实现

根据前面堆排序算法步骤的描述，可知堆排序就是将无序序列建成初堆以后，反复进行交换和堆调整。在建初堆和调整堆算法实现的基础上，下面给出堆排序算法的实现

###### 【算法描述】

```c
void HeapSort(SqList &L)
{//对顺序表L进行堆排序
   CreatHeap(L);                 //把无序序列L.r[1..L.length]建成大根堆
   for(i=L.length;i>1;--i)
   {
     x=L.r[1];                  //将堆顶记录和当前未经排序子序列L.r[1..i]中最后一个记录互换
     L.r[1]=L.r[i];
         L.r[i]=x;
     HeapAdjust(L,1,i-1);       //将L.r[1..i-1]重新调整为大根堆
   }                            //for
}
```



已知待排序记录的关键字序列为，给出用堆排序法进行排序的过程。

首先将无序序列建初堆，过程如图8.11所示。在初始大根堆的基础上，反复交换堆顶元素和最后一个元素，然后重新调整堆，直至最后得到一个有序序列，整个堆排序过程如图所示

![image-20240720131701270](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240720131701270.png)

​							堆排序的过程

###### 【算法分析】

### （1）时间复杂度

堆排序的运行时间主要耗费在建初堆和调整堆时进行的反复“筛选”上。设有n个记录的初始序列所对应的完全二叉树的深度为h，建初堆时，每个非终端结点都要自上而下进行“筛选”。由于第i层上的结点数小于等于2i−1，且第i层结点最大下移的深度为h−i，每下移一层要做两次比较，所以建初堆时关键字总的比较次数为

![image-20240720131738666](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240720131738666.png)

调整建新堆时要做n−1次“筛选”，每次“筛选”都要将根结点下移到合适的位置。n个结点的完全二叉树的深度为，则重建堆时关键字总的比较次数不超过

![image-20240720131756557](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240720131756557.png)

实验研究表明，平均性能接近于最坏性能

### （2）空间复杂度

仅需一个记录大小供交换用的辅助存储空间，所以空间复杂度为O(1)

###### 【算法特点】

（1）是不稳定排序

（2）只能用于顺序结构，不能用于链式结构

（3）初始建堆所需的比较次数较多，因此记录数较少时不宜采用。堆排序在最坏情况下时间复杂度为O(nlog2n)，相对于快速排序最坏情况下的O(n2)而言是一个优点，当记录较多时较为高效

# 五.归并排序

**归并排序**（Merging Sort）就是将两个或两个以上的有序表合并成一个有序表的过程。将两个有序表合并成一个有序表的过程称为2-路归并，2-路归并最为简单和常用。下面以2-路归并为例，介绍归并排序算法。

**归并排序算法的思想是：**

```
假设初始序列含有n个记录，则可看成是n个有序的子序列，每个子序列的长度为1，然后两两归并，得到[插图]个长度为2或1的有序子序列；再两两归并，……，如此重复，直至得到一个长度为n的有序序列为止。
```

已知待排序记录的关键字序列为{49, 38,65, 97, 76, 13, 27}，给出用2-路归并排序法进行排序的过程。

![image-20240720132030710](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240720132030710.png)

​								路归并排序过程

 相邻两个有序子序列的归并

###### 【算法步骤】

设两个有序表存放在同一数组中相邻的位置上：R[low..mid]和R[mid+1..high]，每次分别从两个表中取出一个记录进行关键字的比较，将较小者放入T[1ow..high]中，重复此过程，直至其中一个表为空，最后将另一非空表中余下的部分直接复制到T中

###### 【算法描述】

```c
void Merge(RedType R[],RedType T[],int low,int mid,int high)
{//将有序表R[low..mid]和R[mid+1..high]归并为有序表T[low..high]
   i=low;j=mid+1;k=low;
   while(i<=mid&&j<=high)                 //将R中记录由小到大地并入T中
   {
     if(R[i].key<=R[j].key) T[k++]=R[i++];
     else T[k++]=R[j++];
   }                                      //while
   while(i<=mid) T[k++]=R[i++];           //将剩余的R[i..mid]复制到T中
   while(j<=high) T[k++]=R[j++];          //将剩余的R[j.high]复制到T中
}
```

假设每个子序列的长度为h，则一趟归并排序需调用[ n/2h ]次算法merge进行两两归并，得到前后相邻、长度为2h的有序段，整个归并排序需进行[log~2~n]趟

与快速排序类似，2-路归并排序也可以利用划分为子序列的方法递归实现。首先把整个待排序序列划分为两个长度大致相等的子序列，对这两个子序列分别递归地进行排序，然后再把它们归并。

###### 【算法步骤】

2-路归并排序将R[low..high]中的记录归并排序后放入T[low..high]中。当序列长度等于1时，递归结束，否则：

① 将当前序列一分为二，求出分裂点[插图]

② 对子序列R[low..mid]递归，进行归并排序，结果放入S[low..mid]中

③ 对子序列R[mid+1..high]递归，进行归并排序，结果放入S[mid+1..high]中

④ 调用算法Merge，将有序的两个子序列S[low..mid]和S[mid+1..high]归并为一个有序的序列T[low..high]。

###### 【算法描述】

```c
void MSort(RedType R[],RedType &T[],int low,int high)
{//R[low..high]归并排序后放入T[low..high]中  
   if(low==high) T[low]=R[low];  
   else 
   {  
      mid=(low+high)/2;       //将当前序列一分为二，求出分裂点mid  
      MSort(R,S,low,mid);     //对子序列R[low..mid]递归归并排序，结果放入S[low..mid]  
      MSort(R,S,mid+1,high);  //对子序列R[mid+1..high]递归归并排序，结果放入S[mid+1..high] 
      Merge(S,T,low,mid,high);//将S[low..mid]和S[mid+1..high]归并到T[low..high] 
   }         //else  
}  
@@@@
void MergeSort(SqList &L) 
{//对顺序表L做归并排序  
   MSort(L.r,L.r,1,L.length);  
}
```

###### 【算法分析】

### （1）时间复杂度

当有n个记录时，需进行[插图]趟归并排序，每一趟归并，其关键字比较次数不超过n，元素移动次数都是n，因此，归并排序的时间复杂度为O(nlog2n)

### （2）空间复杂度

用顺序表实现归并排序时，需要和待排序记录个数相等的辅助存储空间，所以空间复杂度为O(n)。

###### 【算法特点】

（1）是稳定排序。（2）可用于链式结构，且不需要附加存储空间，但递归实现时仍需要开辟相应的递归工作栈

# 六、基数排序

前述各类排序方法都是建立在关键字比较的基础上，而分配类排序不需要比较关键字的大小，它是根据关键字中各位的值，通过对待排序记录进行若干趟“分配”与“收集”来实现排序的，是一种借助于多关键字排序的思想对单关键字排序的方法。**基数排序**（Radix Sorting）是典型的分配类排序。

## 1).多关键字的排序

已知扑克牌中52张牌面的次序关系为

![image-20240720132647422](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240720132647422.png)

每一张牌有两个“关键字”：花色

![image-20240720132711831](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240720132711831.png)

和面值（2<3<…<A），且“花色”的地位高于“面值”，在比较任意两张牌面的大小时，必须先比较“花色”，若“花色”相同，则再比较面值。

由此，将扑克牌整理成如上所述次序关系时，有以下两种排序法。

**（1）最高位优先法**：先按不同“花色”分成有次序的4堆，每一堆的牌均具有相同的“花色”，然后分别对每一堆按“面值”大小整理有序。

**（2）最低位优先法**：这是一种“分配”与“收集”交替进行的方法。先按不同“面值”分成13堆，然后将这13堆牌自小至大叠在一起（“3”在“2”之上，“4”在“3”之上，……，最上面的是4张“A”），然后将每堆按照面值的次序收集到一起。再重新对这些牌按不同“花色”分成4堆，最后将这4堆牌按花色的次序再收集到一起（![image-20240720132752497](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240720132752497.png)在最下面，![image-20240720132812406](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240720132812406.png)在最上面)，此时同样得到一副满足如上次序关系的牌，

![image-20240720132831441](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240720132831441.png)

​						扑克牌的一种洗牌过程

## 2).链式基数排序

基数排序的思想类似于上述“最低位优先法”的洗牌过程，是借助“分配”和“收集”两种操作对单逻辑关键字进行排序的一种内部排序方法。有的逻辑关键字可以看成由若干个关键字复合而成的。例如，若关键字是数值，且其值都在0≤K≤999范围内，则可把每一个十进制数字看成一个关键字，即可认为K由3个关键字(K0, K1, K2)组成，其中K0是百位数，K1是十位数，K2是个位数；又若关键字K是由5个字母组成的单词，则可看成是由5个关键字(K0, K1, K2, K3,K4)组成，其中Kj−1是（自左至右的）第j个字母。由于如此分解而得的每个关键字Kj都在相同的范围内（对数字，0≤Kj≤9，对字母′A′≤Kj≤′Z′），故可以按照“分配”和“收集”的方法进行排序。

假设记录的逻辑关键字由d个“关键字”组成，每个关键字可能取rd个值。只要从最低数位关键字起，按关键字的不同值将序列中记录“分配”到rd个队列中后再“收集”之，如此重复d次完成排序。按这种方法实现排序称之为基数排序，其中“基”指的是rd的取值范围，在上述两种关键字的情况下，rd分别为“10”和“26”。

具体实现时，一般采用链式基数排序。

先看一个具体例子。首先以链表存储n个待排记录，并令表头指针指向第一个记录，如图8.15（a）所示，然后通过以下三趟“分配”和“收集”操作来完成排序。

第一趟分配对最低数位关键字（个位数）进行，改变记录的指针值将链表中的记录分配至10个链队列中去，每个队列中的记录关键字的个位数相等，如图（b）所示，其中f[i]和e[i]分别为第i个队列的头指针和尾指针；第一趟收集是改变所有非空队列的队尾记录的指针域，令其指向下一个非空队列的队头记录，重新将10个队列中的记录链成一个链表，如图（c）所示。

第二趟分配和第二趟收集是对十位数进行的，其过程和个位数相同。分配和收集结果分别如图（d）和图（e）所示。

第三趟分配和第三趟收集是对百位数进行的，过程同上，分配和收集结果分别如图（f）和图（g）所示。至此排序完毕

![image-20240720133015176](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240720133015176.png)

​						 链式基数排序过程

算法实现时采用静态链表，以便于更有效地存储和重排记录。相关数据类型的定义如下：

```c
#define MAXNUM_KEY 8                    //关键字项数的最大值
#define RADIX 10                        //关键字基数，此时是十进制整数的基数
#define MAX_SPACE 10000
typedef struct
{
   KeyType keys[MAXNUM_KEY];            //关键字
   InfoType otheritems;                 //其他数据项
   int next；
}SLCell；                               //静态链表的结点类型
typedef struct
{
   SLCell r[MAX_SPACE];                //静态链表的可利用空间，r[0]为头结点
   int keynum;                         //记录的当前关键字个数
   int recnum;                         //静态链表的当前长度
}SLList;                               //静态链表类型
typedef int ArrType[RADIX]             //数组类型
```

###### 【算法描述】

```c
//基数排序

void Distribute(SLCell &r,int i,ArrType &f,ArrType &e)
{//静态链表L的r域中记录已按（keys[0], …, keys[i-1]）有序
 //本算法按第i个关键字keys[i]建立RADIX个子表，使同一子表中记录的 keys[i]相同
 //f[0..RADIX-1]和e[0..RADIX-1]分别指向各子表中第一个和最后一个记录
   for(j=0;j<RADIX;++j) f[j]=0;                   //各子表初始化为空表
   for(p=r[0].next;p;p=r[p].next)
   {
     j=ord(r[p].keys[i]);                         //ord将记录中第i个关键字映射到[0..RADIX-1]
     if(!f[j]) f[j]=p;
     else r[e[j]].next=p;
     e[j]=p;                                      //将p所指的结点插入第j个子表中
   }                                              //for
}
@@@@
void Collect(SLCell &r,int i,ArrType f,ArrType e)
{//本算法按keys[i]自小至大地将f[0..RADIX-1]所指各子表依次链接成一个链表
 //e[0..RADIX-1]为各子表的尾指针
   for(j=0;!f[j]; j=succ(j));                     //找第一个非空子表，succ为求后继函数
   r[0].next=f[j]; t=e[j];                        //r[0].next指向第一个非空子表中第一个结点
   while(j<RADIX)
   {
     for(j=succ(j);j<RADIX-1&&!f[j];j=succ(j));   //找下一个非空子表
     if(f[j]) {r[t].next=f[j]; t=e[j];}           //链接两个非空子表
   }                                              //while
   r[t].next=0;                                   //t指向最后一个非空子表中的最后一个结点
}
@@@@
void RadixSort(SLList &L)
{//L是采用静态链表表示的顺序表
 //对L做基数排序，使得L成为按关键字自小到大的有序静态链表，L.r[0]为头结点
   for(i=0;i<L.recnum;++i) L.r[i].next=i+1;
   L.r[L.recnum].next=0;                         //将L改造为静态链表
   for(i=0;i<L.keynum;++i)  {                    //按最低位优先依次对各关键字进行分配和收集
     Distribute(L.r,i,f,e);                      //第i趟分配
     Collect(L.r,i,f,e);                         //第i趟收集
   }                                             //for
}
```

###### 【算法分析】

### （1）时间复杂度

对于n个记录（假设每个记录含d个关键字，每个关键字的取值范围为rd个值）进行链式基数排序时，每一趟分配的时间复杂度为O(n)，每一趟收集的时间复杂度为O(rd)，整个排序需进行d趟分配和收集，所以时间复杂度为O(d(n+rd))。

### （2）空间复杂度

所需辅助空间为2rd个队列指针，另外由于需用链表做存储结构，则相对于其他以顺序结构存储记录的排序方法而言，还增加了n个指针域的空间，所以空间复杂度为O(n+rd)

###### 【算法特点】

```
（1）是稳定排序

（2）可用于链式结构，也可用于顺序结构

（3）时间复杂度可以突破基于关键字比较一类方法的下界O(nlog2n)，达到O(n)

（4）基数排序使用条件有严格的要求：需要知道各级关键字的主次关系和各级关键字的取值范围。
```

# 七、外部排序

前面讨论的都是内部排序的方法，即整个排序过程全部是在内存中完成的，并不涉及数据的内外存交换问题。但如果待排序的记录数目很大，无法一次性调入内存，整个排序过程就必须借用外存分批调入内存才能完成。

## 1). 外部排序的基本方法

外部排序基本上由两个相对独立的阶段组成。首先，按可用内存大小，将外存上含n个记录的文件分成若干长度为l的子文件或**段**（segment），依次读入内存并利用有效的内部排序方法对它们进行排序，并将排序后得到的有序子文件重新写入外存，通常称这些有序子文件为**归并段**或**顺串**（run）；然后，对这些归并段进行逐趟归并，使归并段（有序的子文件）逐渐由小至大，直至得到整个有序文件为止。显然，第一阶段所涉及的内部排序的工作在前几节已经讨论过。

假设有一个含10000个记录的文件，首先通过10次内部排序得到10个初始归并段R1～R10，其中每一段都含1000个记录。然后对它们作如图8.16所示的两两归并，直至得到一个有序文件为止。

![image-20240720133615279](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240720133615279.png)

​											2-路平衡归并

从图可见，由10个初始归并段到一个有序文件，共进行了4趟归并，每一趟从m个归并段得到个归并段。这种归并方法称为**2-路平衡归并**

将两个有序段归并成一个有序段的过程，若在内存进行，则很简单，算法8.10的merge过程便可实现此归并。但是，在外部排序中实现两两归并时，不仅要调用merge过程，而且要进行外存的读/写，这是由于我们不可能将两个有序段及归并结果段同时存放在内存中的缘故。我们知道，对外存上信息的读/写是以“物理块”为单位的。假设在上例中每个物理块可以容纳200个记录，则每一趟归并需进行50次“读”和50次“写”，4趟归并加上内部排序时所需进行的读/写使得在外排中总共需进行500次的读/写。

一般情况下

![image-20240720133705689](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240720133705689.png)

其中，tIS是为得到一个初始归并段进行内部排序所需时间的均值；tIO是进行一次外存读/写时间的均值；utmg是对u个记录进行内部归并所需时间；m为经过内部排序之后得到的初始归并段的个数；s为归并的趟数；d为总的读/写次数。由此，上例10000个记录利用2-路归并进行外排所需总的时间为：

```
10×tIS+500×tIO+4×10000tmg
```

其中，tIO取决于所用的外存设备，显然，tIO较tmg要大得多。因此，提高外排的效率应主要着眼于减少外存信息读写的次数d

下面来分析d和“归并过程”的关系。若对上例中所得的10个初始归并段进行5-路平衡归并（即每一趟将5个或5个以下的有序子文件归并成一个有序子文件），则下图可见，仅需进行二趟归并，外排时总的读/写次数便减至2×100+100=300，比2-路归并减少了200次的读/写

![image-20240720133756232](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240720133756232.png)

​							5-路平衡归并

可见，对同一文件而言，进行外排时所需读/写外存的次数和归并的趟数s成正比。而在一般情况下，对m个初始归并段进行k-路平衡归并时，归并的趟数

![image-20240720133822923](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240720133822923.png)

此时，为了减少归并趟数s，可以从以下两个方面进行改进：

​		（1）增加归并段的个数k；

​		（2）减少初始归并段的个数m。

其中，“多路平衡归并”的方法是通过增加归并段的个数来减少对数据的扫描趟数；“置换-选择”的方法是在扫描一遍的前提下，能够得到更长的初始归并段，从而减少了初始归并段的个数

## 2). 多路平衡归并的实现

从式（8-5）得知，增加k可以减少s，从而减少外存读/写的次数。但是，从下面的讨论中又可发现，单纯增加k将导致增加内部归并的时间utmg。那么，如何解决这个矛盾呢？

先看2-路归并。令u个记录分布在两个归并段上，按merge过程进行归并。每得到归并后的一个记录，仅需一次比较即可，则得到含u个记录的归并段需进行u-1次比较。

再看k-路归并。令u个记录分布在k个归并段上，显然，归并后的第一个记录应是k个归并段中关键字最小的记录，即应从每个归并段的第一个记录的相互比较中选出最小者，这需要进行k-1次比较。同理，每得到归并后的有序段中的一个记录，都要进行k-1次比较。显然，为得到含u个记录的归并段需进行（u-1）（k-1）次比较。由此，对n个记录的文件进行外排时，在内部归并过程中进行的总的比较次数为s（k-1）（n-1）。假设所得初始归并段为m个，则由式（8-5）可得内部归并过程中进行比较的总的次数为

![image-20240720133946803](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240720133946803.png)

由于![image-20240720134007698](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240720134007698.png)随k的增长而增长，则内部归并时间亦随k的增长而增长。这将抵消由于增大k而减少外存信息读写时间所得效益，这是我们所不希望的。然而，若在进行k-路归并时利用“**败者树**”（Tree of Loser），则可使在k个记录中选出关键字最小的记录时仅需进行[  **log~2~k**  ]次比较，从而使总的归并时间由式（8-6)变为![image-20240720134212430](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240720134212430.png)，显然，这个式子和k无关，它不再随k的增长而增长。

那么，什么是“败者树”？它是树形选择排序的一种变形。相对地，我们可称图8.7和图8.8中的二叉树为“胜者树”，因为每个非终端结点均表示其左、右孩子结点中的“胜者”。反之，若在双亲结点中记下刚进行完的这场比赛中的败者，而让胜者去参加更高一层的比赛，便可得到一棵“败者树”。例如，图8.18（a）所示为一棵实现5-路归并的败者树ls[0..4]，图中方形结点表示叶子结点（也可看成是外结点），分别为5个归并段中当前参加归并选择的记录的关键字；败者树中根结点ls[1]的双亲结点ls[0]为“冠军”，在此指示各归并段中的最小关键字记录为第3段中的当前记录；结点ls[3]指示b1和b2两个叶子结点中的败者即b2，而胜者b1和b3（b3是叶子结点b3、b4和b0经过两场比赛后选出的获胜者）进行比较，结点ls[1]则指示它们中的败者为b1。在选得最小关键字的记录之后，只要修改叶子结点b3中的值，使其为同一归并段中的下一个记录的关键字，然后从该结点向上和双亲结点所指的关键字进行比较，败者留在该双亲结点，胜者继续向上直至树根的双亲。如图8.18（b）所示，当第3个归并段中第2个记录参加归并时，选得的最小关键字记录为第1个归并段中的记录。为防止在归并过程中某个归并段变空，可以在每个归并段中附加一个关键字为最大值的记录。当选出的“冠军”记录的关键字为最大值时，表明此次归并已完成。由于实现k-路归并的败者树的深度为[插图]，则在k个记录中选择最小关键字仅需进行[插图]次比较。败者树的初始化也容易实现，只要先令所有的非终端结点指向一个含最小关键字的叶子结点，然后从各个叶子结点出发调整非终端结点为新的败者即可。

![image-20240720134253765](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240720134253765.png)

​						实现5-路归并的败者树

最后要提及一点，k值的选择并非越大越好，如何选择合适的k是一个需要综合考虑的问题

## 3).置换-选择排序

由8-5式得知，归并的趟数s不仅和k成反比，也和m成反比，因此，减少m是减少s的另一条途径。然而，我们从8.7.1小节的讨论中也得知，m是外部文件经过内部排序之后得到的初始归并段的个数，显然，m=[n/l]，其中n为外部文件中的记录数，l为初始归并段中的记录数。回顾前面讨论的各种内排方法，在内排过程中移动记录和对关键字进行比较都是在内存中进行的。因此，用这些方法进行内部排序得到的各个初始归并段的长度l（除最后一段外）都相同，且完全依赖于进行内部排序时可用内存工作区的大小，则m也随其而限定。由此，若要减小m，即增加l，就必须探索新的排序方法

**置换-选择排序**（Replacement-Selection Sorting）是在树形选择排序的基础上得来的，它的特点是：在整个排序（得到所有初始归并段）的过程中，选择最小（或最大）关键字和输入、输出交叉或平行进行。

先从具体例子谈起。已知初始文件含有24个记录，它们的关键字分别为51,49,39,46,38,29,14,61,15,30,1,48,52,3,63,27,4,13,89,24,46,58,33,76。假设内存工作区可容纳6个记录，则按前面讨论的选择排序可求得如下4个初始归并段：

```
RUN1：29,38,39,46,49,51
RUN2：1,14,15,30,48,61
RUN3：3,4,13,27,52,63
RUN4：24,33,46,58,76,89
```

若按置换-选择排序进行排序，则可求得如下3个初始归并段：

```
RUN1：29,38,39,46,49,51,61
RUN2：1,3,14,15,27,30,48,52,63,89
RUN3：4,13,24,33,46,58,76
```

假设初始待排文件为输入文件FI,初始归并段文件为输出文件FO，内存工作区为WA，FO和WA的初始状态为空，并设内存工作区的容量可容纳w个记录，则置换-选择排序的操作过程为：

```
1).从FI输入w个记录到工作区WA。

2).从WA中选出其中关键字取最小值的记录，记为MINIMAX记录。

3).将MINIMAX记录输入到FO中去。

4).若FI不空，则从FI输入下一个记录到WA中。

5).从WA中所有关键字比MINIMAX记录的关键字大的记录中选出最小关键字记录，作为新的MINIMAX记录

6).重复③～⑤，直至WA中选不出新的MINIMAX记录为止，由此得到一个初始归并段，输出一个归并段的结束标志到FO中去

7).重复②～⑥，直至WA为空。由此得到所有初始归并段。
```

![image-20240720134411998](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240720134411998.png)

​						置换-选择的过程

在WA中选择MINIMAX记录的过程需利用“败者树”来实现。关于“败者树”本身，上节已有详细讨论，在此仅就置换-选择排序中的实现细节加以说明

###### 说明

```
（1）内存工作区中的记录作为败者树的外部结点，而败者树中根结点的双亲结点指示工作区中关键字最小的记录
（2）为了便于选出MINIMAX记录，为每个记录附设一个所在归并段的序号，在进行关键字的比较时，先比较段号，段号小者为胜者；段号相同的则关键字小的为胜者
（3）败者树的建立可从设工作区中所有记录的段号均为“零”开始，然后从FI逐个输入w个记录到工作区时，自上而下调整败者树。由于这些记录的段号为“1”，则它们对于“零”段的记录而言均为败者，从而逐个填充到败者树的各结点中去。
```

下面利用败者树对前面例子进行置换-选择排序时的局部状况进行说明，如图所示。其中，内存工作区的存储结构定义如下：

```c
//- - - - - 内存工作区的存储结构- - - - -
typedef  struct
{
   RedType rec;                 //记录
   KeyType key;                 //从记录中抽取的关键字
   int rnum;                    //所属归并段的段号
}RcdNode,WorkArea[w];           //内存工作区，容量为w
WorkArea wa;
```

![image-20240720134911327](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240720134911327.png)

​							置换-选择过程中的败者树（8.19）

（a）～（g）建立败者树，选出最小关键字记录wa[0] （h）～（l）选好新的MINIMAX记录

图8.19（a）～（g）显示了败者树建立过程中的状态变化状况。最后得到最小关键字的记录为wa[0]，之后，输出wa[0].rec，并从FI中输入下一个记录至wa[0]。由于它的关键字小于刚刚输出的记录的关键字，则设此新输入的记录的段号为2（如图8.19（h）所示），而由于在输出wa[1]之后新输入的关键字较wa[1].key大，则该新输入的记录的段号仍为1（如图8.19（i）所示）。图8.19（j）所示为在输出6个记录之后选得的MINIMAX记录为wa[1]时的败者树。图8.19（k）表明在该记录wa[1]之后，由于输入的下一条记录的关键字较小，其段号亦为2，致使工作区中的所有记录的段号均为2。由此败者树选出的新的MINIMAX记录的段号大于当前生成的归并段的序号。这说明该段已结束，而此新的MINIMAX记录应是下一归并段中的第一个记录。

从上述可见，由置换-选择排序所得初始归并段的长度不等。且可证明，当输入文件中记录的关键字为随机数时，所得初始归并段的平均长度为内存工作区大小w的两倍。这个证明是E.F.Moore在1961年从置换-选择排序和扫雪机的类比中得出的。

假设一台扫雪机在环形路上等速进行扫雪，又下雪的速度也是均衡的（即每小时落到地面上的雪量相等），雪均匀地落在扫雪机的前、后路面上，边下雪边扫雪。显然，在某个时刻之后，整个系统达到平衡状态，路面上的积雪总量不变。且在任何时刻，整个路面上的积雪都形成一个均匀的斜面，紧靠扫雪机前端的积雪最厚，其深度为h，而在扫雪机刚扫过的路面上的积雪深度为零。若将环形路伸展开来，路面积雪状态如图8.20所示。假设此刻路面积雪的总体积为w，环形路一圈的长度为l，由于扫雪机在任何时刻扫走的雪的深度为h，则扫雪机在环形路上走一圈扫掉的积雪体积为lh即2w。

![image-20240720134950254](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240720134950254.png)

​						环形路上扫雪机系统平衡时的状态

将置换-选择排序与此类比，工作区中的记录好比路面的积雪，输出的MINIMAX记录好比扫走的雪，新输入的记录好比新下的雪，当关键字为随机数时，新记录的关键字比MINIMAX大或小的概率相等。若大，则属当前归并段（好比落在扫雪机前面的积雪，在这一圈中将被扫走）；若小，则属下一归并段（好比落在扫雪机后面的积雪，在下一圈中才能扫走）。由此，得到一个初始归并段好比扫雪机走一圈。假设工作区的容量为w，则置换-选择所得初始归并段长度的期望值便为2w。

容易看出，若不计输入、输出的时间，则对n个记录的文件而言，生成所有初始归并段所需时间为O(nlog2w)。

## 4).最佳归并树

这一节要讨论的问题是，由置换-选择生成所得的初始归并段，其各段长度不等对平衡归并有何影响？

假设由置换-选择得到9个初始归并段，其长度（即记录数）依次为9，30，12，18，3，17，2，6，24。现作3-路平衡归并，其归并树（表示归并过程的图）如下图所示，图中每个圆圈表示一个初始归并段，圆圈中数字表示归并段的长度。假设每个记录占一个物理块，则两趟归并所需对外存进行读/写次数为

![image-20240720135225914](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240720135225914.png)

​							3-路平衡归并的归并树（8.21）

​					(9+30+12+18+3+17+2+6+24)×2×2=484

若将初始归并段的长度看成是归并树中叶子结点的权，则此3叉树的带权路径长度的两倍恰为484。显然，归并方案不同，树的带权路径长度（或外存读/写次数）亦不同。回顾在第5章中曾讨论了有n个叶子结点的带权路径长度最短的二叉树称哈夫曼树，同理，存在有n个叶子结点的带权路径长度最短的3叉、4叉、...、k叉树，亦称哈夫曼树。因此，若对长度不等的m个初始归并段，构造一棵哈夫曼树作为归并树，便可使在进行外部归并时所需对外存进行读/写次数达最少。例如，对上述9个初始归并段可构造一棵如图8.22所示的归并树，按此树进行归并，仅需对外存进行446次读/写，这棵归并树便称做**最佳归并树**

图8.22的哈夫曼树是一棵真正的3叉树，即树中只有度为3或0的结点。假若只有8个初始归并段，例如，在前面例子中少了一个长度为30的归并段。如果在设计归并方案时，缺额的归并段留在最后，即除了最后一次作2-路归并外，其他各次归并仍都是3路归并，容易看出此归并方案的外存读/写次数为386。显然，这不是最佳方案。正确的做法是，当初始归并段的数目不足时，需附加长度为零的“虚段”，按照哈夫曼树构成的原则，权为零的叶子应离树根最远，因此，这个只有8个初始归并段的归并树应如图8.23所示。

![image-20240720135413116](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240720135413116.png)

​						3-路平衡归并的最佳归并树图（8.22)

![image-20240720135443920](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240720135443920.png)

​						8个归并段的最佳归并树 (8.23)

那么，如何判断附加虚段的数目？当3叉树中只有度为3或0的结点时，必有n3=(n0-1)/2，其中，n3是度为3的结点数，n0是度为0的结点数。由于n3必为整数，则(n0-1)MOD2=0。也就是说，对3-路归并而言，只有当初始归并段的个数为偶数时，才需加1个虚段。

在一般情况下，对k-路归并而言，容易推算得到，若(m-1) MOD (k-1)=0，则不需加虚段，否则需附加k-(m-1) MOD (k-1)-1个虚段。换句话说，第一次归并为(m-1) MOD (k-1)+1路归并。

若按最佳归并树的归并方案进行磁盘归并排序，需在内存建立一张载有归并段的长度和它在磁盘上的物理位置的索引表。

## 5).总结

![image-20240720135552534](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240720135552534.png)

从表的时间复杂度的平均情况来看，直接插入排序、折半插入排序、冒泡排序和简单选择排序的速度较慢，而其他排序方法的速度较快。从算法实现的角度来看，速度较慢的算法实现过程比较简单，称之为简单的排序方法；而速度较快的算法可以看作是对某一排序算法的改进，称之为先进的排序方法，但这些算法实现过程比较复杂。总的来看，各种排序算法各有优缺点，没有哪一种是绝对最优的。在使用时需根据不同情况适当选用，甚至可将多种方法结合起来使用。一般综合考虑以下因素：

- （1）待排序的记录个数
- （2）记录本身的大小
- （3）关键字的结构及初始状态
- （4）对排序稳定性的要求
- （5）存储结构。

根据这些因素和表8.2所做的比较，可以得出以下几点结论。

（1）当待排序的记录个数n较小时，n2和nlog2n的差别不大，可选用简单的排序方法。而当关键字基本有序时，可选用直接插入排序或冒泡排序，排序速度很快，其中直接插入排序最为简单常用、性能最佳。

（2）当n较大时，应该选用先进的排序方法。对于先进的排序方法，从平均时间性能而言，快速排序最佳，是目前基于比较的排序方法中最好的方法。但在最坏情况下，即当关键字基本有序时，快速排序的递归深度为n，时间复杂度为O(n2)，空间复杂度为O(n)。堆排序和归并排序不会出现快速排序的最坏情况，但归并排序的辅助空间较大。这样，当n较大时，具体选用的原则是：

- ① 当关键字分布随机，稳定性不做要求时，可采用快速排序
- ② 当关键字基本有序，稳定性不做要求时，可采用堆排序
- ③ 当关键字基本有序，内存允许且要求排序稳定时，可采用归并排序

（3）可以将简单的排序方法和先进的排序方法结合使用。例如，当n较大时，可以先将待排序序列划分成若干子序列，分别进行直接插入排序，然后再利用归并排序，将有序子序列合并成一个完整的有序序列。或者，在快速排序中，当划分子区间的长度小于某值时，可以转而调用直接插入排序算法

（4）基数排序的时间复杂度也可写成O(d·n)。因此，它最适用于n值很大而关键字较小的序列。若关键字也很大，而序列中大多数记录的“最高位关键字”均不同，则亦可先按“最高位关键字”不同将序列分成若干“小”的子序列，而后进行直接插入排序。但基数排序使用条件有严格的要求：需要知道各级关键字的主次关系和各级关键字的取值范围，即只适用于像整数和字符这类有明显结构特征的关键字，当关键字的取值范围为无穷集合时，则无法使用基数排序

（5）从方法的稳定性来比较，基数排序是稳定的内排方法，所有时间复杂度为O(n2)的简单排序法也是稳定的，然而，快速排序、堆排序和希尔排序等时间性能较好的排序方法都是不稳定的。

一般来说，如果排序过程中的“比较”是在“相邻的两个记录关键字”间进行的，则排序方法是稳定的。值得提出的是，稳定性是由方法本身决定的，对不稳定的排序方法而言，不管其描述形式如何，总能举出一个说明不稳定的实例来。反之，对稳定的排序方法，可能有的描述形式会引起不稳定，但总能找到一种不引起不稳定的描述形式。由于大多数情况下排序是按记录的主关键字进行的，则所用的排序方法是否稳定无关紧要。若排序按记录的次关键字进行，则必须采用稳定的排序方法。

（6）在本章讨论的排序方法中，多数是采用顺序表实现的。若记录本身信息量较大，为避免移动记录耗费大量时间，可采用链式存储结构。比如直接插入排序、归并排序都易于在链表上实现。但像折半插入排序、希尔排序、快速排序和堆排序，却难于在链表上实现。

对于外部排序，常用的方法是归并方法，这种方法主要由两个独立的阶段组成：第一，把待排序的文件划分成若干个子文件；第二，逐趟归并子文件，最后形成对整个文件的排序。为减少归并中外存读写的次数，提高外排序的效率，一般通过增大归并路数和减少初始归并段个数两种方案对归并算法进行改进，其中，“多路平衡归并”的方法可以增加归并段的个数，“置换-选择”的方法可以减少初始归并段的个数。
