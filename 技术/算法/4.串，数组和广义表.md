# 一、串

## 1.串的定义

**串**（string）（或**字符串**）是由零个或多个字符组成的有限序列，一般记为

s=“a1a2 … an”(n≥0)

其中，s是串的名，用双引号括起来的字符序列是串的值；ai(1≤i≤n)可以是字母、数字或其他字符；串中字符的数目n称为串的**长度**。零个字符的串称为**空串**（null string），其长度为零。

串中任意个连续的字符组成的子序列称为该串的**子串**。包含子串的串相应地称为**主串**。通常称字符在序列中的序号为该字符在串中的**位置**。子串在主串中的位置则以子串的第一个字符在主串中的位置来表示。

例如，假设a、b、c、d为如下的4个串：

a=“BEI”，b=“JING”

c=“BEIJING”，d=“BEI JING”

则它们的长度分别为3、4、7和8；并且a和b都是c和d的子串，a在c和d中的位置都是1，而b在c中的位置是4，在d中的位置则是5。

称两个串是相等的，当且仅当这两个串的值相等。也就是说，只有当两个串的长度相等，并且各个对应位置的字符都相等时才相等。例如，上例中的串a、b、c和d彼此都不相等

在各种应用中，空格常常是串的字符集合中的一个元素；因而可以出现在其他字符中间。由一个或多个空格组成的串“ ”称为空格串（blank string，请注意：此处不是空串），其长度为串中空格字符的个数。为了清楚起见，以后我们用符号“Ø”来表示“空串”

## 2.串的类型定义、存储结构及其运算

### 1),串的抽象类型定义

串的逻辑结构和线性表极为相似，区别仅在于串的数据对象约束为字符集。然而，串的基本操作和线性表有很大差别。在线性表的基本操作中，大多以“单个元素”作为操作对象，例如，在线性表中查找某个元素，求取某个元素，在某个位置上插入一个元素或删除一个元素等；而在串的基本操作中，通常以“串的整体”作为操作对象，例如，在串中查找某个子串，求取一个子串，在串的某个位置上插入一个子串，以及删除一个子串等

串的抽象数据类型的定义如下：

```
ADT String{
  数据对象：D={ai|ai∈CharacterSet,i=1,2,…,n,n≥0}
  数据关系：R1={<ai-1,ai>|ai-1,ai∈D,i=2,…,n}
  基本操作：
    StrAssign(&T,chars)    
      初始条件：chars是字符串常量。    
      操作结果：生成一个其值等于chars的串T。    
    StrCopy(&T,S)    
      初始条件：串S存在。    
      操作结果：由串S复制得串T。    
    StrEmpty(S)    
      初始条件：串S存在。    
      操作结果：若S为空串，则返回true，否则返回false。    
    StrCompare(S,T)    
      初始条件：串S和T存在。    
      操作结果：若S>T，则返回值>0；若S=T，则返回值＝0；若S<T，则返回值<0。  
    StrLength(S)    
      初始条件：串S存在。    
      操作结果：返回S的元素个数，称为串的长度。    
    ClearString(&S)    
      初始条件：串S存在。    
      操作结果：将S清为空串。    
    Concat(&T,S1,S2)    
      初始条件：串S1和S2存在。    
      操作结果：用T返回由S1和S2联接而成的新串。    
    SubString(&Sub,S,pos,len)
      初始条件：串S存在，1≤pos≤StrLength(S)且0≤len≤StrLength(S)-pos+1。  
      操作结果：用Sub返回串S的第pos个字符起长度为len的子串。
    Index(S,T,pos)    
      初始条件：串S和T存在，T是非空串，1≤pos≤StrLength(S)。 
      操作结果：若主串S中存在和串T值相同的子串，则返回它在主串S中第pos个字符之后第一次出现的位置；否则函数值为0。  
    Replace(&S,T,V)  
      初始条件：串S，T和V存在，T是非空串。    
      操作结果：用V替换主串S中出现的所有与T相等的不重叠的子串。    
    StrInsert(&S,pos,T)    
      初始条件：串S和T存在，1≤pos≤StrLength(S)+1。    
      操作结果：在串S的第pos个字符之前插入串T。    
    StrDelete(&S,pos,len)    
      初始条件：串S存在，1≤pos≤StrLength(S)-len+1。    
      操作结果：从串S中删除第pos个字符起长度为len的子串。    
    DestroyString(&S)    
      初始条件：串S存在。    
      操作结果：串S被销毁。    
}ADT String
```

### 2).串的存储结构
#### a.串的顺序存储
类似于线性表的顺序存储结构，用一组地址连续的存储单元存储串值的字符序列。按照预定义的大小，为每个定义的串变量分配一个固定长度的存储区，则可用定长数组如下描述：
```c
//- - - - - 串的定长顺序存储结构- - - - -
#define MAXLEN 255                      //串的最大长度
typedef struct{
   char ch[MAXLEN+1];                   //存储串的一维数组
   int length;                          //串的当前长度
}SString;
```
其中，MAXLEN表示串的最大长度，ch是存储字符串的一维数组，每个分量存储一个字符，length表示字符串的当前长度。为了便于说明问题，本章后面算法描述当中所用到的顺序存储的字符串都是从下标为1的数组分量开始存储的，下标为0的分量闲置不用

这种定义方式是静态的，在编译时刻就确定了串空间的大小。而多数情况下，串的操作是以串的整体形式参与的，串变量之间的长度相差较大，在操作中串值长度的变化也较大，这样为串变量设定固定大小的空间不尽合理。因此最好是根据实际需要，在程序执行过程中动态地分配和释放字符数组空间。在C语言中，存在一个称之为“堆”（Heap）的自由存储区，可以为每个新产生的串动态分配一块实际串长所需的存储空间，若分配成功，则返回一个指向起始地址的指针，作为串的基址，同时为了以后处理方便，约定串长也作为存储结构的一部分。这种字符串的存储方式也称为串的堆式顺序存储结构，定义如下：
```c
//- - - - - 串的堆式顺序存储结构- - - - -
typedef struct{
   char *ch;                            //若是非空串，则按串长分配存储区，否则ch为NULL
   int length;                          //串的当前长度
}HString;
```
#### b.串的链式存储
顺序串的插入和删除操作不方便，需要移动大量的字符。因此，可采用单链表方式存储串。由于串结构的特殊性——结构中的每个数据元素是一个字符，则在用链表存储串值时，存在一个“结点大小”的问题，即每个结点可以存放一个字符，也可以存放多个字符。例如，图（a）所示为结点大小为4（即每个结点存放4个字符）的链表，图（b）所示为结点大小为1的链表。当结点大小大于1时，由于串长不一定是结点大小的整倍数，则链表中的最后一个结点不一定全被串值占满，此时通常补上“#”或其他的非串值字符（通常“#”不属于串的字符集，是一个特殊的符号）。

![image-20240720070802768](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240720070802768.png)

​						串值的链表存储方式

为了便于进行串的操作，当以链表存储串值时，除头指针外，还可附设一个尾指针指示链表中的最后一个结点，并给出当前串的长度。称如此定义的串存储结构为块链结构，说明如下：

```c
//- - - - - 串的链式存储结构- - - - -
#define CHUNKSIZE 80                            //可由用户定义的块大小
typedef struct Chunk{
   char ch［CHUNKSIZE］;
   struct Chunk *next;
}Chunk;
typedef struct{
   Chunk *head,*tail;                           //串的头和尾指针
   int length;                                  //串的当前长度
}LString;
```

在链式存储方式中，结点大小的选择直接影响着串处理的效率。在各种串的处理系统中，所处理的串往往很长或很多，如一本书的几百万个字符，情报资料的成千上万个条目，这就要求考虑串值的存储密度

显然，存储密度小（如结点大小为1时），运算处理方便，然而，存储占用量大。如果在串处理过程中需进行内、外存交换的话，则会因为内、外存交换操作过多而影响处理的总效率。应该看到，串的字符集的大小也是一个重要因素。一般来说，字符集小，则字符的机内编码就短，这也影响串值存储方式的选取

串值的链式存储结构对某些串操作，如联接操作等，有一定方便之处，但总地说来，不如顺序存储结构灵活，它占用存储量大且操作复杂。此外，串值在链式存储结构时，串操作的实现和线性表在链表存储结构中的操作类似，故在此不作详细讨论

#### c.串的模式匹配算法

子串的定位运算通常称为串的**模式匹配**或**串匹配**。此运算的应用非常广泛，比如在搜索引擎、拼写检查、语言翻译、数据压缩等应用中，都需要进行串匹配。

串的模式匹配设有两个字符串S和T，设S为主串，也称正文串；设T为子串，也称为模式。在主串S中查找与模式T相匹配的子串，如果匹配成功，确定相匹配的子串中的第一个字符在主串S中出现的位置。
##### 1．BF算法
最简单直观的模式匹配算法是BF（Brute-Force）算法

###### 【算法步骤】

① 分别利用计数指针i和j指示主串S和模式T中当前正待比较的字符位置，i初值为pos，j初值为1

② 如果两个串均未比较到串尾，即i和j均分别小于等于S和T的长度时，则循环执行以下操作：·
​	S.ch[i]和T.ch[j]比较，若相等，则i和j分别指示串中下个位置，继续比较后续字符
	若不等，指针后退重新开始匹配，从主串的下一个字符（i=i-j+2）起再重新和模式的第一个字符（j=1）比较
③ 如果j>T.length，说明模式T中的每个字符依次和主串S中的一个连续的字符序列相等，则匹配成功，返回和模式T中第一个字符相等的字符在主串S中的序号（i-T.length）；否则称匹配不成功，返回0
###### 【算法描述】
```c
int Index_BF(SString S,SString T,int pos)
{//返回模式T在主串S中第pos个字符开始第一次出现的位置。若不存在，则返回值为0  
 //其中，T非空，1≤pos≤S.length 
   i=pos; j=1;                         //初始化 
   while(i<=S.length && j<=T.length)  //两个串均未比较到串尾 
   {  
      if(S[i].ch==T[j].ch){++i;++j;}   //继续比较后继字符  
      else{i=i-j+2;j=1;}               //指针后退重新开始匹配 
   }    
   if(j>T.length) return i-T.length;  //匹配成功 
   else return 0;                      //匹配失败 
}
```
![image-20240720073930920](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240720073930920.png)
​				模式T=“abcac”和主串S的匹配过程（pos=1）

###### 【算法分析】
BF算法的匹配过程易于理解，且在某些应用场合效率也较高。在匹配成功的情况下，考虑以下两种极端情况：
	（1）最好情况下，每趟不成功的匹配都发生在模式串的第一个字符与主串中相应字符的比较。
例如：
​	S=“aaaaaba”
​	T=“ba”
设主串的长度为n，子串的长度为m，假设从主串的第i个位置开始与模式串匹配成功，则在前i−1趟匹配中字符总共比较了i−1次；若第i趟成功的字符比较次数为m，则总比较次数为i−1+m。对于成功匹配的主串，其起始位置由1到n−m+1，假定这n−m+1个起始位置上的匹配成功概率相等，则最好的情况下匹配成功的平均比较次数为
![image-20240720074747489](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240720074747489.png)

即最好情况下的平均时间复杂度是O(n+m)
	（2）最坏情况下，每趟不成功的匹配都发生在模式串的最后一个字符与主串中相应字符的比较。
例如：
S=“aaaaaab”
T=“aab”
假设从主串的第i个位置开始与模式串匹配成功，则在前i−1趟匹配中字符总共比较了(i−1) ×m次；若第i趟成功的字符比较次数为m，则总比较次数i ×m。因此最坏情况下匹配成功的平均比较次数为
![image-20240720074807774](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240720074807774.png)
即最坏情况下的平均时间复杂度是O(n ×m)
BF算法思路直观简明。但当匹配失败时，主串的指针i总是回溯到i−j+2位置，模式串的指针总是恢复到首字符位置j=1，因此，算法时间复杂度高。

#### d．KMP算法

这种改进算法是由Knuth、Morris和Pratt同时设计实现的，因此简称KMP算法。此算法可以在O(n+m)的时间数量级上完成串的模式匹配操作。其改进在于：每当一趟匹配过程中出现字符比较不等时，不需回溯i指针，而是利用已经得到的“部分匹配”的结果将模式向右“滑动”尽可能远的一段距离后，继续进行比较。
下面先从具体例子看起：
回顾图4.4中的匹配过程示例，在第三趟的匹配中，当i=7、j=5字符比较不等时，又从i=4、j=1重新开始比较。然后，经仔细观察可发现，i=4和j=1，i=5和j=1，以及i=6和j=1这3次比较都是不必进行的。因为从第三趟部分匹配的结果就可得出，主串中第4个、第5个和第6个字符必然是“b”、“c”和“a”（即模式串中第2个、第3个和第4个字符）。因为模式中的第一个字符是“a”，因此它无需再和这3个字符进行比较，而仅需将模式向右滑动3个字符的位置继续进行i=7、j=2时的字符比较即可。同理，在第一趟匹配中出现字符不等时，仅需将模式向右移动两个字符的位置继续进行i=3、j=1时的字符比较。由此，在整个匹配的过程中，i指针没有回溯
![image-20240720074921372](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240720074921372.png)
​						KMP算法的匹配过程
现在讨论一般情况。假设主串为“s1s2…sn”，模式串为“t1t2…tm”，从上例的分析可知，为了实现改进算法，需要解决下述问题：当匹配过程中产生“失配”（即si≠tj）时，模式串“向右滑动”可行的距离多远，换句话说，当主串中第i个字符与模式中第j个字符“失配”（即比较不等）时，主串中第i个字符（i指针不回溯）应与模式中哪个字符再比较？
假设此时应与模式中第k（k<j）个字符继续比较，则模式中前k−1个字符的子串必须满足下列关系式（4-1），且不可能存在k'>k满足下列关系式（4-1）
![image-20240720075029058](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240720075029058.png)
而已经得到的“部分匹配”的结果是
![image-20240720075056354](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240720075056354.png)
由式（4-1）和式（4-2）推得下列等式
![image-20240720075120042](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240720075120042.png)
反之，若模式串中存在满足式（4-3）的两个子串，则当匹配过程中，主串中第i个字符与模式中第j个字符比较不等时，仅需将模式向右滑动至模式中第k个字符和主串中第i个字符对齐，此时，模式中头k−1个字符的子串“t1t2…tk−1”必定与主串中第i个字符之前长度为k−1的子串“si−k+1si−k+2…si−1”相等，由此，匹配仅需从模式中第k个字符与主串中第i个字符开始，依次向后进行比较。
若令next[j]=k，则next[j]表明当模式中第j个字符与主串中相应字符“失配”时，在模式中需重新和主串中该字符进行比较的字符的位置。由此可引出模式串的next函数的定义：
![image-20240720075143019](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240720075143019.png)
由此定义可推出模式串的next函数值，如图所示
![image-20240720075210362](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240720075210362.png)
​							模式串的next函数值
在求得模式的next函数之后，匹配可如下进行：假设以指针i和j分别指示主串和模式中正待比较的字符，令i的初值为pos，j的初值为1。若在匹配过程中si=tj，则i和j分别增1，否则，i不变，而j退到next［j］的位置再比较，若相等，则指针各自增1，否则j再退到下一个next值的位置，依次类推，直至下列两种可能：一种是j退到某个next值（next［next［…next［j］…］］）时字符比较相等，则指针各自增1，继续进行匹配；另一种是j退到值为零（即模式的第一个字符“失配”），则此时需将模式继续向右滑动一个位置，即从主串的下一个字符si+1起和模式重新开始匹配。图4.7所示正是上述匹配过程的一个例子。
![image-20240720075245536](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240720075245536.png)
​					利用模式的next函数进行匹配的过程示例
KMP算法如算法4.2所示，它在形式上和算法4.1极为相似。不同之处仅在于：当匹配过程中产生“失配”时，指针i不变，指针j退回到next［j］所指示的位置上重新进行比较，并且当指针j退至零时，指针i和指针j需同时增1。即若主串的第i个字符和模式的第1个字符不等，应从主串的第i+1个字符起重新进行匹配。

###### 【算法描述】
```c
int Index_KMP(SString S,SString T,int pos)
{//利用模式串T的next函数求T在主串S中第pos个字符之后的位置    
 //其中，T非空，1≤pos≤S.length 
   i=pos;j=1;    
   while(i<=S.length && j<=S.length)   //两个串均未比较到串尾 
   {    
      if(j==0‖S[i]==T[j]){++i;++j;}     //继续比较后继字符    
      else j=next[j];                   //模式串向右移动    
   }    
   if(j>T[0]) return i-T[0];           //匹配成功    
   else return 0;                      //匹配失败 
} 
```
KMP算法是在已知模式串的next函数值的基础上执行的，那么，如何求得模式串的next函数值呢？
从上述讨论可见，此函数值仅取决于模式串本身，而和相匹配的主串无关，可从分析其定义出发用递推的方法求得next函数值。
由定义得知：
![image-20240720075346014](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240720075346014.png)
设next[j]=k，这表明在模式串中存在下列关系：
![image-20240720075407919](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240720075407919.png)
其中k为满足1<k<j的某个值，并且不可能存在k'>k满足等式（4-7）。此时next[j+1]=?可能有以下两种情况
​	（1）若tk=tj，则表明在模式串中
![image-20240720075436638](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240720075436638.png)
并且不可能存在k'>k满足等式（4-7），这就是说next[j+1]=k+1，即
![image-20240720075455046](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240720075455046.png)
​	（2）若tk≠tj，则表明在模式串中
```
“t1t2…tk”≠“tj−k+1tj−k+2…tj”
```
此时可把求next函数值的问题看成是一个模式匹配的问题，整个模式串既是主串又是模式串，而当前在匹配的过程中，已有tj–k+1=t1，tj–k+2=t2，…，tj−1=tk−1，则当tj≠tk时应将模式向右滑动至以模式中的第next[k]个字符和主串中的第j个字符相比较。若next[k]=k'，且tj=tk'，则说明在主串中第j+1个字符之前存在一个长度为k'（即next[k]）的最长子串，和模式串中从首字符起长度为k'的子串相等，即
![image-20240720075529987](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240720075529987.png)
这就是说next[j+1]=k'+1，即
![image-20240720075551835](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240720075551835.png)
同理，若tj≠tk'，则将模式继续向右滑动直至将模式中第next[k']个字符和tj对齐，…，依次类推，直至tj和模式中某个字符匹配成功或者不存在任何k'(1<k'<j)满足等式（4-9），则
![image-20240720075622504](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240720075622504.png)
例如，图4.8中的模式串，已求得前6个字符的next函数值，现求next[7]，因为next[6]=3，又t6 ≠ t3，则需比较t6和t1（因为next[3]=1），这相当于将子串模式向右滑动。由于t6 ≠ t1，而且next[1]=0，所以next[7]=1，而因为t7=t1，则next[8]=2
![image-20240720075650698](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240720075650698.png)
​						模式串的next函数值
根据上述分析所得结果（式（4-5）、式（4-8）、式（4-10）和式（4-11）），仿照KMP算法，可得到求next函数值的算法
###### 【算法描述】
```c
void get_next(SString T,int next[])
{//求模式串T的next函数值并存入数组next
   i=1;next[1]=0;j=0；
   while(i<T.length)
   {
     if(j==0‖T.ch[i]==T.ch[j]){++i;++j;next[i]=j;}
     else j=next[j];
    }
}
```
算法4.3的时间复杂度为O(m)。通常，模式串的长度m比主串的长度n要小得多，因此，对整个匹配算法来说，所增加的这点时间是值得的。
最后，要说明以下两点。
​		（1）虽然BF算法的时间复杂度是O(n×m)，但在一般情况下，其实际的执行时间近似于O(n+m)，因此至今仍被采用。KMP算法仅当模式与主串之间存在许多“部分匹配”的情况下，才显得比BF算法快得多。但是KMP算法的最大特点是指示主串的指针不需回溯，整个匹配过程中，对主串仅需从头至尾扫描一遍，这对处理从外设输入的庞大文件很有效，可以边读入边匹配，而无需回头重读
​		（2）前面定义的next函数在某些情况下尚有缺陷。例如模式“aaaab”在和主串“aaabaaaab”匹配时，当i=4、j=4时s.ch[4]≠t.ch[4]，由next[j]的指示还需进行i=4、j=3，i=4、j=2，i=4、j=1这3次比较。实际上，因为模式中第1～3个字符和第4个字符都相等，因此不需要再和主串中第4个字符相比较，而可以将模式连续向右滑动4个字符的位置直接进行i=5、j=1时的字符比较。这就是说，若按上述定义得到next[j]=k，而模式中tj=tk，则当主串中字符si和tj比较不等时，不需要再和tk进行比较，而直接和Tnext［k］进行比较，换句话说，此时的next[j]应和next[k]相同。由此可得计算next函数修正值的算法如算法4.4所示，next函数修正值的计算结果如图4.9所示。此时匹配算法不变
![image-20240720075836898](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240720075836898.png)
​						next函数修正值
###### 【算法描述】
```c
void get_nextval(SString T，int nextval[])
{//求模式串T的next函数修正值并存入数组nextval
   i=1;nextval［1］=0;j=0;
   while(i<T.length)
   {
     if(j==0‖T.ch[i]==T.ch[j])
     {
        ++i;++j; 
                if(T.ch[i]!=T.ch[j]) nextval[i]=j;
        else  nextval[i]=nextval[j];
     }
         else j=nextval[j];
   }
}
```

# 二、数组
## 1).数组的类型定义
数组是由类型相同的数据元素构成的有序集合，每个元素称为数组元素，每个元素受n（n≥1）个线性关系的约束，每个元素在n个线性关系中的序号i1，i2，…，in称为该元素的下标，可以通过下标访问该数据元素。因为数组中每个元素处于n（n≥1）个关系中，故称该数组为n维数组。数组可以看成是线性表的推广，其特点是结构中的元素本身可以是具有某种结构的数据，但属于同一数据类型。
例如，一维数组可以看成是一个线性表，二维数组可以看成数据元素是线性表的线性表。图（a）所示的二维数组可以看成是一个线性表
![image-20240720080204726](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240720080204726.png)
​					A=(a0,a1,…ap) (p=m-1或n-1)
其中每个数据元素aj是一个列向量形式的线性表
​					aj=(a0j, a1j,…,am-1,j) 0≤j≤n−1
（见图（b））或者ai是一个行向量形式的线性表
​					ai=(ai0,ai1,…,ai,n-1) 0≤i≤m−1
（见图（c））在C语言中，一个二维数组类型可以定义为其分量类型为一维数组类型的一维数组类型，也就是说，
![image-20240720080334298](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240720080334298.png)
同理，一个n维数组类型可以定义为其数据元素为n−1维数组类型的一维数组类型
数组一旦被定义，它的维数和维界就不再改变。因此，除了结构的初始化和销毁之外，数组只有存取元素和修改元素值的操作
抽象数据类型数组可形式地定义为：
```
ADT Array{
  数据对象：ji=0,…,bi-1,i=1,2,…,n，
            D={aj1j2…jn|n(>0)称为数组的维数，bi是数组第i维的长度，
            ji是数组元素的第i维下标, aj1j2…jn ∈ ElemSet}
  数据关系：R={R1,R2,…，Rn}
  基本操作：
    InitArray(&A,n,boundi，…，boundn)  
      操作结果：若维数n和各维长度合法，则构造相应的数组A，并返回OK。  
    DestroyArray(&A)  
      操作结果：销毁数组A。  
    Value(A,&e,indexl,…,indexn)  
      初始条件：A是n维数组，e为元素变量，随后是n个下标值。  
      操作结果：若各下标不超界，则e赋值为所指定的A的元素值，并返回OK。  
    Assign(&A,e,indexl,…,indexn)  
      初始条件：A是n维数组，e为元素变量，随后是n个下标值。  
      操作结果：若下标不超界，则将e的值赋给所指定的A的元素，并返回OK。  
} ADT Array
```
## 2).数组的顺序存储
由于数组一般不做插入或删除操作，也就是说，一旦建立了数组，则结构中的数据元素个数和元素之间的关系就不再发生变动。因此，采用顺序存储结构表示数组比较合适。
由于存储单元是一维的结构，而数组可能是多维的结构，则用一组连续存储单元存放数组的数据元素就有次序约定问题。例如图（a）所示的二维数组可以看成如图（b）所示的一维数组，也可看成如图（c）所示的一维数组。对应地，对二维数组可有两种存储方式：一种是以列序为主序的存储方式，如图（a）所示；一种是以行序为主序的存储方式，如图（b）所示。在扩展Basic、Pascal、Java和C语言中，用的都是以行序为主序的存储结构，而在FORTRAN语言中，用的是以列序为主序的存储结构。
![image-20240720080513419](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240720080513419.png)
​							二维数组的两种存储方式
由此，对于数组，一旦规定了其维数和各维的长度，便可为它分配存储空间。反之，只要给出一组下标便可求得相应数组元素的存储位置。下面仅用以行序为主序的存储结构为例予以说明
假设每个数据元素占L个存储单元，则二维数组A[0..m−1, 0.. n−1]（即下标从0开始，共有m行n列）中任一元素aij的存储位置可由下式确定
![image-20240720080556320](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240720080556320.png)
式中，LOC(i, j)是aij的存储位置；LOC(0, 0)是a00的存储位置，即二维数组A的起始存储位置，也称为基地址或基址。
将式（4-12）推广到一般情况，可得到n维数组A[0..b1−1，0.. b2−1，…，0.. bn−1]的数据元素存储位置的计算公式：
![image-20240720080636837](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240720080636837.png)
可缩写成
![image-20240720080709468](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240720080709468.png)
其中，cn=L, ci−1=bi×ci, 1<i≤n
式（4-13）称为n维数组的映像函数。容易看出，数组元素的存储位置是其下标的线性函数，一旦确定了数组各维的长度，ci就是常数。由于计算各个元素存储位置的时间相等，所以存取数组中任一元素的时间也相等，即数组是一种随机存取结构
## 3).特殊矩阵的压缩存储
矩阵是很多科学与工程计算问题中研究的数学对象，矩阵用二维数组来表示是最自然的方法。但是，在数值分析中经常出现一些阶数很高的矩阵，同时在矩阵中有很多值相同的元素或者是零元素。有时为了节省存储空间，可以对这类矩阵进行压缩存储。所谓压缩存储，是指为多个值相同的元只分配一个存储空间，对零元不分配空间。假若值相同的元素或者零元素在矩阵中的分布有一定规律，则称此类矩阵为特殊矩阵。特殊矩阵主要包括对称矩阵、三角矩阵和对角矩阵等，下面我们重点讨论这三种特殊矩阵的压缩存储。
### 1．对称矩阵
若n阶矩阵A中的元满足下述性质
				aij=aji 1≤i,j≤n
则称为n阶对称矩阵
对于对称矩阵，可以为每一对对称元分配一个存储空间，则可将n2个元压缩存储到n(n+1)/2个元的空间中，不失一般性，可以行序为主序存储其下三角（包括对角线）中的元
假设以一维数组sa[n(n+1)/2]作为n阶对称矩阵A的存储结构，则sa[k]和矩阵元aij之间存在着一一对应的关系：
![image-20240720080836275](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240720080836275.png)
对于任意给定的一组下标（i, j)，均可在sa中找到矩阵元aij；反之，对所有的k=0,1,2,…,
![image-20240720081638139](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240720081638139.png)
都能确定sa[k]中的元在矩阵中的位置（i, j）。由此，称sa[n(n+1)/2]为n阶对称矩阵A的压缩存储
![image-20240720080908985](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240720080908985.png)
​								对称矩阵的压缩存储	
### 2．三角矩阵
以主对角线划分，三角矩阵有上三角矩阵和下三角矩阵两种。上三角矩阵是指矩阵下三角（不包括对角线）中的元均为常数c或零的n阶矩阵，下三角矩阵与之相反。对三角矩阵进行压缩存储时，除了和对称矩阵一样，只存储其上（下）三角中的元素之外，再加一个存储常数c的存储空间即可
#### （1）上三角矩阵
sa[k]和矩阵元aij之间的对应关系为
![image-20240720080936765](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240720080936765.png)
#### （2）下三角矩阵
sa[k]和矩阵元aij之间的对应关系为
![image-20240720081001401](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240720081001401.png)
### 3．对角矩阵
对角矩阵所有的非零元都集中在以主对角线为中心的带状区域中，即除了主对角线上和直接在对角线上、下方若干条对角线上的元之外，所有其他的元皆为零，如图所示。
对这种矩阵，也可按某个原则（或以行为主，或以对角线的顺序）将其压缩存储到一维数组上。
![image-20240720081020586](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240720081020586.png)
在上述这些特殊矩阵中，非零元的分布都有一个明显的规律，从而可将其压缩存储到一维数组中，并找到每个非零元在一维数组中的对应关系
然而，在实际应用中还经常会遇到另一类矩阵，其非零元较零元少，且分布没有一定规律，称之为**稀疏矩阵**。这类矩阵的压缩存储就要比特殊矩阵复杂，在此不做讨论
# 三、广义表
## 1.广义表的定义
顾名思义，广义表是线性表的推广，也称为列表。广泛地用于人工智能等领域的表处理语言LISP语言，把广义表作为基本的数据结构，就连程序也表示为一系列的广义表
广义表一般记作
​		LS=(a1,a2,…,an)
其中，LS是广义表（a1, a2,…,an）的名称，n是其长度。在线性表的定义中，ai（1≤i≤n）只限于是单个元素。而在广义表的定义中，ai可以是单个元素，也可以是广义表，分别称为广义表LS的原子和子表。习惯上，用大写字母表示广义表的名称，用小写字母表示原子
显然，广义表的定义是一个递归的定义，因为在描述广义表时又用到了广义表的概念。下面列举一些广义表的例子
- （1）A=( )—A是一个空表，其长度为零
- （2）B=(e)—B只有一个原子e，其长度为1
- （3）C=(a, (b, c, d))—C的长度为2，两个元素分别为原子a和子表(b, c, d)
- （4）D=(A, B, C)—D的长度为3，3个元素都是广义表。显然，将子表的值代入后，则有D=(( ), (e)，(a,(b, c, d)))
- （5）E=(a, E)—这是一个递归的表，其长度为2。E相当于一个无限的广义表E=(a，(a, (a, …)))
- 
从上述定义和例子可推出广义表的如下3个重要结论
- （1）广义表的元素可以是子表，而子表的元素还可以是子表……由此，广义表是一个多层次的结构，可以用图形象地表示。例如，图4.14表示的是广义表D，图中以圆圈表示广义表，以方块表示原子
![image-20240720082140999](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240720082140999.png)
- （2）广义表可为其他广义表所共享。例如在上述例子中，广义表A、B和C为D的子表，则在D中可以不必列出子表的值，而是通过子表的名称来引用
- （3）广义表可以是一个递归的表，即广义表也可以是其本身的一个子表。例如，表E就是一个递归的表
- 
由于广义表的结构比较复杂，其各种运算的实现也不如线性表简单，其中，最重要的两个运算如下
- （1）取表头GetHead(LS)：取出的表头为非空广义表的第一个元素，它可以是一个单原子，也可以是一个子表
（2）取表尾GetTail(LS)：取出的表尾为除去表头之外，由其余元素构成的表。即表尾一定是一个广义表
​		例如：
​			GetHead(B)=e，GetTail(B)=( )
​			GetHead(D)=A，GetTail(D)=(B，C),
​			由于(B,C)为非空广义表，则可继续分解得到：
​			GetHead(B，C)=B，GetTail(B，C)=(C)，
值得提醒的是，广义表( )和(( ))不同。前者为空表，长度n=0；后者长度n=1，可分解得到其表头、表尾均为空表( )。

## 2.广义表的存储结构

由于广义表中的数据元素可以有不同的结构（或是原子，或是列表），因此难以用顺序存储结构表示，通常采用链式存储结构。常用的链式存储结构有两种，头尾链表的存储结构和扩展线性链表的存储结构

### 1).头尾链表的存储结构

由于广义表中的数据元素可能为原子或广义表，由此需要两种结构的结点：一种是表结点，用以表示广义表；一种是原子结点，用以表示原子。从上节得知：若广义表不空，则可分解成表头和表尾，因此，一对确定的表头和表尾可唯一确定广义表。一个表结点可由3个域组成：标志域、指示表头的指针域和指示表尾的指针域。而原子结点只需两个域：标志域和值域。如图4.15所示，其中tag是标志域，值为1时表明结点是子表，值为0时表明结点是原子。

![image-20240720082218629](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240720082218629.png)

​						头尾链表表示的结点结构

其形式定义说明如下：

```c
//- - - - -广义表的头尾链表存储表示- - - - -
typedef  enum{ATOM,LIST} ElemTag;  //ATOM==0：原子；LIST==1：子表  
typedef  struct GLNode 
{  
   ElemTag tag;                   //公共部分，用于区分原子结点和表结点  
   union                          //原子结点和表结点的联合部分 
   { 
      AtomType atom;              //atom是原子结点的值域，AtomType由用户定义  
      struct{struct GLNode*hp，*tp;}ptr;  
                                 //ptr是表结点的指针域，ptr.hp和ptr.tp分别指向表头和表尾  
   };  
}*GList;                         //广义表类型
```

上节中曾列举了广义表的例子，它们的存储结构如图所示，在这种存储结构中有以下几种情况。
![image-20240720082316722](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240720082316722.png)
​					头尾链表表示的存储结构示例
- （1）除空表的表头指针为空外，对任何非空广义表，其表头指针均指向一个表结点，且该结点中的hp域指示广义表表头（或为原子结点，或为表结点），tp域指向广义表表尾（除非表尾为空，则指针为空，否则必为表结点）。
- （2）容易分清列表中原子和子表所在层次。如在广义表D中，原子a和e在同一层次上，而b、c和d在同一层次且比a和e低一层，B和C是同一层的子表
- （3）最高层的表结点个数即为广义表的长度。以上3个特点在某种程度上给广义表的操作带来方便
### 2).扩展线性链表的存储结构
在这种结构中，无论是原子结点还是表结点均由三个域组成，其结点结构如图所示。
![image-20240720082400268](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240720082400268.png)
​						扩展线性链表表示的结点结构

![image-20240720082437634](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240720082437634.png)
​						扩展线性链表表示的存储结构示例