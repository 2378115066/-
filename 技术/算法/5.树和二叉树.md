# 一、树和二叉树的概念
## 1、树的定义
树（Tree）是n（n≥0）个结点的有限集，它或为空树（n=0）；或为非空树，对于非空树T：		（1）有且仅有一个称之为根的结点；

（2）除根结点以外的其余结点可分为m（m>0）个互不相交的有限集T1, T2, …, Tm,其中每一个集合本身又是一棵树，并且称为根的子树（SubTree）。

例如，在下图中，（a）是只有一个根结点的树；（b）是有13个结点的树，其中A是根，其余结点分成3个互不相交的子集：T1={B, E, F,K, L}，T2={C, G}，T3={D, H, I, J, M}。T1、T2和T3都是根A的子树，且本身也是一棵树。例如T1，其根为B，其余结点分为两个互不相交的子集：T11={E, K, L}，T12={F}。T11和T12都是B的子树。而T11中E是根，{K}和{L}是E的两棵互不相交的子树，其本身又是只有一个根结点的树。

![image-20240815141159206](D:\文档\笔记\技术\算法\image-20240815141159206.png)

​								图5.1 树的示例

树的结构定义是一个递归的定义，即在树的定义中又用到树的定义，它道出了树的固有特性。树还可有其他的表示形式，如图5.2所示为图5.1（b）中树的各种表示。其中（a）是以嵌套集合（即是一些集合的集体，对于其中任何两个集合，或者不相交，或者一个包含另一个）的形式表示的；（b）是以广义表的形式表示的，根作为由子树森林组成的表的名字写在表的左边；（c）用的是凹入表示法（类似书的编目）。表示方法的多样化，正说明了树结构在日常生活中及计算机程序设计中的重要性。一般来说，分等级的分类方案都可用层次结构来表示，也就是说，都可由一个树结构来表示。

![image-20240815141256022](D:\文档\笔记\技术\算法\image-20240815141256022.png)

​								图5.2 树的其他3种表示法

## 2.术语

- （1）结点：树中的一个独立单元。包含一个数据元素及若干指向其子树的分支，如图5.1（b）中的A、B、C、D等。（下面术语中均以图5.1（b）为例来说明）
- （2）结点的度：结点拥有的子树数称为结点的度。例如，A的度为3，C的度为1，F的度为0。
- （3）树的度：树的度是树内各结点度的最大值。图5.1（b）所示的树的度为3。
- （4）叶子：度为0的结点称为叶子或终端结点。结点K、L、F、G、M、I、J都是树的叶子。
- （5）非终端结点：度不为0的结点称为非终端结点或分支结点。除根结点之外，非终端结点也称为内部结点。
- （6）双亲和孩子：结点的子树的根称为该结点的孩子，相应地，该结点称为孩子的双亲。例如，B的双亲为A，B的孩子有E和F。
- （7）兄弟：同一个双亲的孩子之间互称兄弟。例如，H、I和J互为兄弟。
- （8）祖先：从根到该结点所经分支上的所有结点。例如，M的祖先为A、D和H。
- （9）子孙：以某结点为根的子树中的任一结点都称为该结点的子孙。如B的子孙为E、K、L和F。
- （10）层次：结点的层次从根开始定义起，根为第一层，根的孩子为第二层。树中任一结点的层次等于其双亲结点的层次加1。
- （11）堂兄弟：双亲在同一层的结点互为堂兄弟。例如，结点G与E、F、H、I、J互为堂兄弟。
- （12）树的深度：树中结点的最大层次称为树的深度或高度。图5.1（b）所示的树的深度为4。
- （13）有序树和无序树：如果将树中结点的各子树看成从左至右是有次序的（即不能互换），则称该树为有序树，否则称为无序树。在有序树中最左边的子树的根称为第一个孩子，最右边的称为最后一个孩子。
- （14）森林：是m（m≥0）棵互不相交的树的集合。对树中每个结点而言，其子树的集合即为森林。由此，也可以用森林和树相互递归的定义来描述树。

就逻辑结构而言，任何一棵树都是一个二元组Tree＝(root , F)，其中root是数据元素，称作树的根结点；F是m（m≥0）棵树的森林，F=(T1, T2, …, Tm)，其中Ti=(ri, Fi)称作根root的第i棵子树；当m≠0时，在树根和其子树森林之间存在下列关系：

```
RF={<root,ri>|i=1,2,…,m,m>0
```

这个定义将有助于得到森林和树与二叉树之间转换的递归定义。

## 3.二叉树的定义

二叉树（Binary Tree）是n（n≥0）个结点所构成的集合，它或为空树（n=0）；或为非空树，对于非空树T：

- （1）有且仅有一个称之为根的结点；
- （2）除根结点以外的其余结点分为两个互不相交的子集T1和T2，分别称为T的左子树和右子树，且T1和T2本身又都是二叉树。二叉树与树一样具有递归性质，

二叉树与树的区别主要有以下两点：

- （1）二叉树每个结点至多只有两棵子树（即二叉树中不存在度大于2的结点）；
- （2）二叉树的子树有左右之分，其次序不能任意颠倒。

二叉树的递归定义表明二叉树或为空，或是由一个根结点加上两棵分别称为左子树和右子树的、互不相交的二叉树组成。由于这两棵子树也是二叉树，则由二叉树的定义，它们也可以是空树。由此，二叉树可以有5种基本形态，如图5.3所示。

![image-20240815141543891](D:\文档\笔记\技术\算法\image-20240815141543891.png)

# 二、树和二叉树的抽象数据类型定义

```c
ADT Tree{
  数据对象D：D是具有相同特性的数据元素的集合。
  数据关系R：若D为空集，则称为空树；
      若D仅含一个数据元素，则R为空集，否则R={H}，H是如下二元关系： 
      （1）在D中存在唯一的称为根的数据元素root，它在关系H下无前驱； 
      （2）若D-{root}≠Φ，则存在D-{root}的一个划分D1，D2，…，Dm（m>0），对任意j≠k（1≤j, k≤m）有
      DjnDkΦ= ，且对任意的i（1≤i≤m），唯一存在数据元素xi∈Di，有<root,xi>∈H；
      （3）对应于D-{root}的划分，H-{<root,x1>，…，<root,xm>＝有唯一的一个划分H1，H2，… ，
        Hm（m>0），对任意j≠k（1≤j, k≤m）有HjnHkΦ= ，且对任意i（1≤i≤m），Hi是Di上的二元关
        系 ，（Di,{Hi}）是一棵符合本定义的树，称为根root的子树。
  基本操作P：
    InitTree(&T) 
      操作结果：构造空树T。 
    DestroyTree(&T) 
      初始条件：树T存在。 
      操作结果：销毁树T。 
    CreateTree(&T,definition) 
      初始条件：definition给出树T的定义。 
      操作结果：按definition构造树T。 
    ClearTree(&T) 
      初始条件：树T存在。 
      操作结果：将树T清为空树。
    TreeEmpty(T) 
      初始条件：树T存在。 
      操作结果：若T为空树，则返回true，否则false。 
    TreeDepth(T) 
      初始条件：树T存在。 
      操作结果：返回T的深度。 
    Root(T) 
      初始条件：树T存在。 
      操作结果：返回T的根。 
    Value(T,cur_e) 
      初始条件：树T存在，cur_e是T中某个结点。 
      操作结果：返回cur_e的值。 
    Assign(T,cur_e,value) 
      初始条件：树T存在，cur_e是T中某个结点。 
      操作结果：结点cur_e赋值为value。 
    Parent(T,cur_e); 
      初始条件：树T存在，cur_e是T中某个结点。 
      操作结果：若cur_e是T的非根结点，则返回它的双亲，否则函数值为“空”。 
    LeftChild(T,cur_e) 
      初始条件：树T存在，cur_e是T中某个结点。 
      操作结果：若cur_e是T的非叶子结点，则返回它的最左孩子，否则返回“空”。 
    RightSibling(T,cur_e) 
      初始条件：树T存在,cur_e是T中某个结点。 
      操作结果：若cur_e有右兄弟，则返回它的右兄弟，否则函数值为“空”。 
    InsertChild(&T,p,i,c) 
      初始条件：树T存在，p指向T中某个结点，1≤i≤p所指结点的度＋1，非空树c与T不相交。 
      操作结果：插入c为T中p指结点的第i棵子树。 
    DeleteChild(&T,p,i) 
      初始条件：树T存在，p指向T中某个结点，1≤i≤p指结点的度。 
      操作结果：删除T中p所指结点的第i棵子树。 
    TraverseTree(T) 
      初始条件：树T存在。 
      操作结果：按某种次序对T的每个结点访问一次。               
} ADT Tree
```

二叉树的抽象数据类型定义如下：

```c
ADT BinaryTree{
  数据对象D：D是具有相同特性的数据元素的集合。
  数据关系R：
    若D=Ф，则R=Ф，称BinaryTree为空二叉树； 
    若D≠Ф，则R={H}，H是如下二元关系： 
      （1）在D中存在唯一的称为根的数据元素root，它在关系H下无前驱；
      （2）若D-{root}≠Ф，则存在D-{root}={Dl, Dr}，且D1∩Dr=Ф；
      （3）若D1≠Ф，则Dl中存在唯一的元素xl，<root, xl>∈H，且存在Dl上的关系H1⊂H；若Dr≠Ф，
      则Dr中存在唯一的元素xr，<root , xr>∈H，且存在Dr上的关系Hr⊂H；H={<root, x1>，<root,
      xr>，H1，Hr}；
      （4）（Dl, {Hl}）是一棵符合本定义的二叉树，称为根的左子树，（Dr, {Hr}）是一棵符合本定义的二
      叉树，称为根的右子树。 
  基本操作P：
    InitBiTree(&T) 
      操作结果：构造空二叉树T。 
    DestroyBiTree(&T) 
      初始条件：二叉树T存在。 
      操作结果：销毁二叉树T。 
    CreateBiTree(&T,definition) 
      初始条件；definition给出二叉树T的定义。 
      操作结果：按definition构造二叉树T。 
    ClearBiTree(&T) 
      初始条件：二叉树T存在。 
      操作结果：将二叉树T清为空树。 
    BiTreeEmpty(T) 
      初始条件：二叉树T存在。 
      操作结果：若T为空二叉树，则返回true，否则false。 
    BiTreeDepth(T) 
      初始条件：二叉树T存在。 
      操作结果：返回T的深度。 
    Root(T) 
      初始条件：二叉树T存在。 
      操作结果：返回T的根。 
    Value(T,e) 
      初始条件：二叉树T存在，e是T中某个结点。 
      操作结果：返回e的值。 
    Assign(T,&e,value) 
      初始条件：二叉树T存在，e是T中某个结点。 
      操作结果：结点e赋值为value。 
    Parent(T,e) 
      初始条件：二叉树T存在，e是T中某个结点。 
      操作结果：若e是T的非根结点，则返回它的双亲，否则返回“空”。 
    LeftChild(T,e) 
      初始条件：二叉树T存在，e是T中某个结点。 
      操作结果：返回e的左孩子。若e无左孩子，则返回“空”。 
    RightChild(T,e) 
      初始条件：二叉树T存在，e是T中某个结点。 
      操作结果：返回e的右孩子。若e无右孩子，则返回“空”。 
    LeftSibling(T,e) 
      初始条件：二叉树T存在，e是T中某个结点。 
      操作结果：返回e的左兄弟。若e是T的左孩子或无左兄弟，则返回“空”。 
    RightSibling(T,e) 
      初始条件：二叉树T存在，e是T中某个结点。 
      操作结果：返回e的右兄弟。若e是T的右孩子或无右兄弟，则返回“空”。 
    InsertChild(&T,p,LR,c) 
      初始条件：二叉树T存在，p指向T中某个结点，LR为0或1，非空二叉树c与T不相交且右子树为空。 
      操作结果：根据LR为0或1，插入 c为T中p所指结点的左或右子树。p所指结点的原有左或右子树则成 
      为c的右子树。 
    DeleteChild(&T,p,LR) 
      初始条件：二叉树T存在，p指向T中某个结点，LR为0或1。 
      操作结果：根据LR为0或1，删除T中p所指结点的左或右子树。 
    PreOrderTraverse(T) 
      初始条件：二叉树T存在。 
      操作结果：先序遍历T，对每个结点访问一次。 
    InOrderTraverse(T) 
      初始条件：二叉树T存在。 
      操作结果：中序遍历T，对每个结点访问一次。 
    PostOrderTraverse(T) 
      初始条件：二叉树T存在。 
      操作结果：后序遍历T，对每个结点访问一次。 
    LevelOrderTraverse(T) 
      初始条件：二叉树T存在。 
操作结果：层序遍历T，对每个结点访问一次。 
} ADT BinaryTree
```

# 三、二叉树的性质和存储结构

## 1.二叉树的性质

二叉树具有下列重要特性：

**性质1** 在二叉树的第i层上至多有2i−1个结点（i≥1）。

```
证明：利用归纳法容易证得此性质。i=1时，只有一个根结点。显然，2i−1=20=1是对的。现在假定对所有的j(1≤j<i)，命题成立，即第j层上至多有2j−1个结点。那么，可以证明j=i时命题也成立。由归纳假设：第i−1层上至多有2i−2个结点。由于二叉树每个结点的度至多为2，故在第i层上的最大结点数为第i−1层上的最大结点数的2倍，即2×2i−2=2i−1。
```

**性质2** 深度为k的二叉树至多有2k−1个结点（k≥1）。

```
证明：由性质1可见，深度为k的二叉树的最大结点数为
```

![image-20240815142228499](D:\文档\笔记\技术\算法\vdfgnsn)

**性质3** 对任何一棵二叉树T，如果其终端结点数为n0，度为2的结点数为n2，则n0=n2+1。

```
证明：设n1为二叉树T中度为1的结点数。因为二叉树中所有结点的度均小于或等于2，所以其结点总数为
		n=n0+n1+n2     				(5-1)
```

再看二叉树中的分支数。除了根结点外，其余结点都有一个分支进入，设B为分支总数，则n=B+1。由于这些分支是由度为1或2的结点射出的，所以又有B=n1+2n2。

于是得出

![image-20240904103607603](D:\文档\笔记\技术\算法\image-20240904103607603.png)

由式（5-1）和式（5-2）得n0=n2+1

**满二叉树**：深度为k且含有2k−1个结点的二叉树。图5.6（a）所示是一棵深度为4的满二叉树。

![image-20240904103721138](D:\文档\笔记\技术\算法\image-20240904103721138.png)

​					图5.6 特殊形态的二叉树

满二叉树的特点是：每一层上的结点数都是最大结点数，即每一层i的结点数都具有最大值2i−1。

可以对满二叉树的结点进行连续编号，约定编号从根结点起，自上而下，自左至右。由此可引出完全二叉树的定义。

**完全二叉树**：深度为k的，有n个结点的二叉树，当且仅当其每一个结点都与深度为k的满二叉树中编号从1至n的结点一一对应时，称之为完全二叉树。图5.6（b）所示为一棵深度为4的完全二叉树。

完全二叉树的特点是：（1）叶子结点只可能在层次最大的两层上出现；（2）对任一结点，若其右分支下的子孙的最大层次为l，则其左分支下的子孙的最大层次必为l或l+1。图5.6中（c）和（d）不是完全二叉树。

完全二叉树在很多场合下出现，下面的性质4和性质5是完全二叉树的两个重要特性。

**性质4** 具有n个结点的完全二叉树的深度为<img src="D:\文档\笔记\技术\算法\image-20240904103935538.png" alt="image-20240904103935538" style="zoom:50%;" />

注1 符号表示不大于x的最大整数，反之，[插图]表示不小于x的最小整数。

证明：假设深度为k，则根据性质2和完全二叉树的定义有2k−1−1<n≤2k−1或2k−1≤n<2k于是k−1≤log2n<k，因为k是整数，所以<img src="D:\文档\笔记\技术\算法\image-20240904104049878.png" alt="image-20240904104049878" style="zoom:50%;" />

**性质5** 如果对一棵有n个结点的完全二叉树（其深度为[xl]）的结点按层序编号（从第1层到第[xl]层，每层从左到右），则对任一结点i（1≤i≤n）

<img src="D:\文档\笔记\技术\算法\image-20240904104703450.png" alt="image-20240904104703450" style="zoom:50%;" />

- （1）如果i=1，则结点i是二叉树的根，无双亲；如果i>1，则其双亲PARENT(i)是结点[插图]。
- （2）如果2i>n，则结点i无左孩子（结点i为叶子结点）；否则其左孩子LCHILD(i)是结点2i。
- （3）如果2i+1>n，则结点i无右孩子；否则其右孩子RCHILD(i)是结点2i+1。

![image-20240904104756007](D:\文档\笔记\技术\算法\image-20240904104756007.png)

​				图5.7 完全二叉树中结点i和i+1的左、右孩子

## 2.二叉树的存储结构

### 1)．顺序存储结构

```c
//-----二叉树的顺序存储表示-----
#define  MAXTSIZE 100                           //二叉树的最大结点数
typedef  TElemType SqBiTree[MAXTSIZE];          //0号单元存储根结点
SqBiTree  bt；
```

顺序存储结构使用一组地址连续的存储单元来存储数据元素，为了能够在存储结构中反映出结点之间的逻辑关系，必须将二叉树中的结点依照一定的规律安排在这组单元中。

对于完全二叉树，只要从根起按层序存储即可，依次自上而下、自左至右存储结点元素，即将完全二叉树上编号为i的结点元素存储在如上定义的一维数组中下标为i−1的分量中。例如，图5.8（a）所示为图5.6（b）所示完全二叉树的顺序存储结构。

对于一般二叉树，则应将其每个结点与完全二叉树上的结点相对照，存储在一维数组的相应分量中，图5.6（c）所示二叉树的顺序存储结构如图5.8（b）所示，图中以“0”表示不存在此结点。

![image-20240904104920241](D:\文档\笔记\技术\算法\image-20240904104920241.png)

​					图5.8 二叉树的顺序存储结构

由此可见，这种顺序存储结构仅适用于完全二叉树。因为，在最坏的情况下，一个深度为k且只有k个结点的单支树（树中不存在度为2的结点）却需要长度为2k−1的一维数组。这造成了存储空间的极大浪费，所以对于一般二叉树，更适合采取下面的链式存储结构。

### 2).链式存储结构

设计不同的结点结构可构成不同形式的链式存储结构。由二叉树的定义得知，二叉树的结点（见图5.9（a））由一个数据元素和分别指向其左、右子树的两个分支构成，则表示二叉树的链表中的结点至少包含3个域：数据域和左、右指针域，如图5.9（b）所示。有时，为了便于找到结点的双亲，还可在结点结构中增加一个指向其双亲结点的指针域，如图5.9（c）所示。利用这两种结点结构所得二叉树的存储结构分别称之为二叉链表和三叉链表，如图5.10所示。链表的头指针指向二叉树的根结点。容易证得，在含有n个结点的二叉链表中有n+1个空链域。在5.5节中将会看到可以利用这些空链域存储其他有用信息，从而得到另一种链式存储结构——线索链表。

![image-20240904105018621](D:\文档\笔记\技术\算法\image-20240904105018621.png)

​				图5.9 二叉树的结点及其存储结构

![image-20240904105053546](D:\文档\笔记\技术\算法\image-20240904105053546.png)

​				图5.10 链表存储结构

在不同的存储结构中，实现二叉树的操作方法也不同，如找结点x的双亲PARENT(T, e)，在三叉链表中很容易实现，而在二叉链表中则需从根指针出发巡查。由此，在具体应用中采用什么存储结构，除根据二叉树的形态之外还应考虑需进行何种操作。读者可试以5.4.1小节中定义的各种操作对以上定义的各种存储结构进行比较。在下一节的二叉树遍历及其应用的算法均采用以下定义的二叉链表形式实现。

```c
//- - - - -二叉树的二叉链表存储表示- - - - -
typedef struct BiTNode{
    TElemType data;                                     //结点数据域
    struct BiTNode *lchild,*rchild;                     //左右孩子指针
}BiTNode,*BiTree;
```

# 四、遍历二叉树和线索二叉树

## 1.遍历二叉树

### 1).遍历二叉树算法描述

遍历二叉树（traversing binary tree）是指按某条搜索路径巡访树中每个结点，使得每个结点均被访问一次，而且仅被访问一次。访问的含义很广，可以是对结点做各种处理，包括输出结点的信息，对结点进行运算和修改等。遍历二叉树是二叉树最基本的操作，也是二叉树其他各种操作的基础，遍历的实质是对二叉树进行线性化的过程，即遍历的结果是将非线性结构的树中结点排成一个线性序列。由于二叉树的每个结点都可能有两棵子树，因而需要寻找一种规律，以便使二叉树上的结点能排列在一个线性队列上，从而便于遍历。

回顾二叉树的递归定义可知，二叉树是由3个基本单元组成：根结点、左子树和右子树。因此，若能依次遍历这三部分，便是遍历了整个二叉树。假如从L、D、R分别表示遍历左子树、访问根结点和遍历右子树，则可有DLR、LDR、LRD、DRL、RDL、RLD这6种遍历二叉树的方案。若限定先左后右，则只有前3种情况，分别称之为先（根）序遍历、中（根）序遍历和后（根）序遍历。基于二叉树的递归定义，可得下述遍历二叉树的递归算法定义。

先序遍历二叉树的操作定义如下：
```
若二叉树为空，则空操作；否则
    （1）访问根结点；
    （2）先序遍历左子树；
    （3）先序遍历右子树。
```
中序遍历二叉树的操作定义如下：
```
若二叉树为空，则空操作；否则
    （1）中序遍历左子树；
    （2）访问根结点；
    （3）中序遍历右子树。
```
后序遍历二叉树的操作定义如下：
```
若二叉树为空，则空操作；否则
（1）后序遍历左子树；
（2）后序遍历右子树；
（3）访问根结点。
```
例如，图5.5所示的二叉树表示下述表达式
```
a+b *(c − d)− e/f
```
若先序遍历此二叉树，按访问结点的先后次序将结点排列起来，可得到二叉树的先序序列为

```
-+a*b-cd/ef							(5-3)
```

类似地，中序遍历此二叉树，可得此二叉树的中序序列为

```
a+b*c-d-e/f							(5-4)
```

后序遍历此二叉树，可得此二叉树的后序序列为

```
abcd-*+ef/-							(5-5)
```

从表达式来看，以上3个序列（5-3）、（5-4）和（5-5）恰好为表达式的前缀表示（波兰式）、中缀表示和后缀表示（逆波兰式）。算法5.1给出了中序遍历二叉树基本操作的递归算法在二叉链表上的实现，算法将结点的访问简化成数据的输出。

#### 算法5.1 中序遍历的递归算法

###### 【算法描述】

```c
void InOrderTraverse(BiTree T)
{//中序遍历二叉树T的递归算法
   if(T)                                  //若二叉树非空
   {
     InOrderTraverse(T->lchild);         //中序遍历左子树
     cout<<T->data;                      //访问根结点
     InOrderTraverse(T->rchild);         //中序遍历右子树
   }
}
```

只要改变输出语句的顺序，读者便可类似地实现先序遍历和后序遍历的递归算法，此处不再一一列举。

从上述二叉树遍历的定义可知，3种遍历算法不同处仅在于访问根结点和遍历左、右子树的先后关系。如果在算法中暂且抹去和递归无关的cout语句，则3个遍历算法完全相同。由此，从递归执行过程的角度来看先序、中序和后序遍历也是完全相同的。图5.11（b）中用带箭头的虚线表示了这3种遍历算法的递归执行过程。其中，向下的箭头表示更深一层的递归调用，向上的箭头表示从递归调用退出返回；虚线旁三角形、圆形和方形内的字符分别表示在先序、中序和后序遍历二叉树过程中访问结点时输出的信息。例如，由于中序遍历中访问结点是在遍历左子树之后、遍历右子树之前进行，则带圆形的字符标在向左递归返回和向右递归调用之间。由此，只要沿虚线从1出发到2结束，将沿途所见的三角形（或圆形、或方形）内的字符记下，便得到遍历二叉树的先序（或中序、或后序）序列。例如，从图5.11（b）分别可得图5.11（a）所示表达式的前缀表示（-*abc）、中缀表示（a*b-c）和后缀表示（ab*c-）。

![image-20240904105458776](D:\文档\笔记\技术\算法\image-20240904105458776.png)

​								图5.11 3种遍历过程示意图

根据前面3.4.4小节的内容，可利用栈将递归算法改写成非递归算法，如算法5.2所示。例如，从中序遍历递归算法执行过程中递归工作栈的状态可见：

- （1）工作记录中包含两项，其一是递归调用的语句编号，其二是指向根结点的指针，则当栈顶记录中的指针非空时，应遍历左子树，即指向左子树根的指针进栈；
- （2）若栈顶记录中的指针值为空，则应退至上一层，若是从左子树返回，则应访问当前层（即栈顶记录）中指针所指的根结点；
- （3）若是从右子树返回，则表明当前层的遍历结束，应继续退栈。从另一个角度看，这意味着遍历右子树时不再需要保存当前层的根指针，直接修改栈顶记录中的指针即可。

#### 算法5.2 中序遍历的非递归算法

###### 【算法步骤】

```
1.初始化一个空栈S，指针p指向根结点。
2.申请一个结点空间q，用来存放栈顶弹出的元素。
3.当p非空或者栈S非空时，循环执行以下操作：
	如果p非空，则将p进栈，p指向该结点的左孩子；
	如果p为空，则弹出栈顶元素并访问，将p指向该结点的右孩子。
```

###### 【算法描述】

```c
void InOrderTraverse(BiTree T)
{//中序遍历二叉树T的非递归算法 
   InitStack(S);p=T; 
   q=new BiTNode; 
   while(p||!StackEmpty(S)) 
   { 
      if(p)                //p非空 
      { 
         Push(S,p);        //根指针进栈 
         p=p->lchild;     //根指针进栈，遍历左子树 
      } 
      else                //p为空 
      { 
         Pop(S,q);        //退栈 
         cout<<q->data;  //访问根结点 
         p=q->rchild;    //遍历右子树 
      } 
   }                     // while 
}
```

按上述算法，图5.11（a）所示的二叉树的中序非递归遍历的栈S的变化过程如图5.12所示。

![image-20240904105615983](D:\文档\笔记\技术\算法\image-20240904105615983.png)

​					图5.12 非递归中序遍历时栈S的变化情况

###### 【算法分析】

无论是递归还是非递归遍历二叉树，因为每个结点被访问一次，则不论按哪一种次序进行遍历，对含n个结点的二叉树，其时间复杂度均为O(n)。所需辅助空间为遍历过程中栈的最大容量，即树的深度，最坏情况下为n，则空间复杂度也为O(n)。

二叉树的先序、中序和后序遍历是最常用的三种遍历方式。此外，还有一种按层次遍历二叉树的方式，这种方式按照“从上到下，从左到右”的顺序遍历二叉树，即先遍历二叉树第一层的结点，然后是第二层的结点，直到最底层的结点，对每一层的遍历按照从左到右的次序进行。例如，图5.11（a）所示的二叉树的层次遍历序列是-*cab。层次遍历不是一个递归过程，层次遍历算法的实现可以借助队列这种数据结构，这里不做详细讨论，算法留给读者自行完成。

### 2)．根据遍历序列确定二叉树

从前面讨论的二叉树的遍历知道，若二叉树中各结点的值均不相同，任意一棵二叉树结点的先序序列、中序序列和后序序列都是唯一的。反过来，若已知二叉树遍历的任意两种序列，能否确定这棵二叉树呢？这样确定的二叉树是否是唯一的呢？

由二叉树的先序序列和中序序列，或由其后序序列和中序序列均能唯一地确定一棵二叉树。

根据定义，二叉树的先序遍历是先访问根结点，其次再按先序遍历方式遍历根结点的左子树，最后按先序遍历方式遍历根结点的右子树。这就是说，在先序序列中，第一个结点一定是二叉树的根结点。另一方面，中序遍历是先遍历左子树，然后访问根结点，最后再遍历右子树。这样，根结点在中序序列中必然将中序序列分割成两个子序列，前一个子序列是根结点的左子树的中序序列，而后一个子序列是根结点的右子树的中序序列。根据这两个子序列，在先序序列中找到对应的左子序列和右子序列。在先序序列中，左子序列的第一个结点是左子树的根结点，右子序列的第一个结点是右子树的根结点。这样，就确定了二叉树的三个结点。同时，左子树和右子树的根结点又可以分别把左子序列和右子序列划分成两个子序列，如此递归下去，当取尽先序序列中的结点时，便可以得到一棵二叉树。

同理，由二叉树的后序序列和中序序列也可唯一地确定一棵二叉树。因为，依据后序遍历和中序遍历的定义，后序序列的最后一个结点，就如同先序序列的第一个结点一样，可将中序序列分成两个子序列，分别为这个结点左子树的中序序列和右子树的中序序列，再拿出后序序列的倒数第二个结点，并继续分割中序序列，如此递归下去，当倒着取尽后序序列中的结点时，便可以得到一棵二叉树。

【例5.1】 已知一棵二叉树的中序序列和后序序列分别是BDCEAFHG和DECBHGFA，请画出这棵二叉树。

（1）由后序遍历特征，根结点必在后序序列尾部，即根结点是A；

（2）由中序遍历特征，根结点必在其中间，而且其左部必全部是左子树子孙（BDCE），其右部必全部是右子树子孙（FHG）；

（3）继而，根据后序中的DECB子树可确定B为A的左孩子，根据HGF子串可确定F为A的右孩子；依此类推，可以唯一地确定一棵二叉树，如图5.13所示。

![image-20240904105735967](D:\文档\笔记\技术\算法\image-20240904105735967.png)

​					图5.13 由中序序列和后序序列确定的二叉树

但是，由一棵二叉树的先序序列和后序序列不能唯一确定一棵二叉树，因为无法确定左右子树两部分。例如，如果有先序序列AB，后序序列BA，因为无法确定B为左子树还是右子树，所以可得到如图5.14所示的两棵不同的二叉树。

![image-20240904105811320](D:\文档\笔记\技术\算法\image-20240904105811320.png)

​						图5.14 两棵不同的二叉树

### 3)．二叉树遍历算法的应用

“遍历”是二叉树各种操作的基础，假设访问结点的具体操作不仅仅局限于输出结点数据域的值，而把“访问”延伸到对结点的判别、计数等其他操作，可以解决一些关于二叉树的其他实际问题。如果在遍历过程中生成结点，这样便可建立二叉树的存储结构。

#### 1.创建二叉树的存储结构——二叉链表

为简化问题，设二叉树中结点的元素均为一个单字符。假设按先序遍历的顺序建立二叉链表，T为指向根结点的指针，对于给定的一个字符序列，依次读入字符，从根结点开始，递归创建二叉树。

**算法5.3 先序遍历的顺序建立二叉链表**

###### 【算法步骤】

```
1.扫描字符序列，读入字符ch。
2.如果ch是一个“#”字符，则表明该二叉树为空树，即T为NULL；否则执行以下操作：
    申请一个结点空间T；
    将ch赋给T->data；
    递归创建T的左子树；
    递归创建T的右子树；
```

###### 【算法描述】

```c
void CreateBiTree(BiTree &T）
{//按先序次序输入二叉树中结点的值（一个字符），创建二叉链表表示的二叉树T 
   cin>>ch; 
   if(ch==’#’) T=NULL;             //递归结束，建空树 
   else                           //递归创建二叉树 
   { 
      T=new BiTNode;               //生成根结点 
      T->data=ch;                 //根结点数据域置为ch 
      CreateBiTree(T->lchild);    //递归创建左子树 
      CreateBiTree(T->rchild);    //递归创建右子树 
      }                           //else 
}
```

例如，对图5.10（b）所示的二叉树，读入字符的顺序为：ABC##DE#G##F###（其中#表示空树），可建立相应的二叉链表。

#### 2.复制二叉树

复制二叉树就是利用已有的一棵二叉树复制得到另外一棵与其完全相同的二叉树。根据二叉树的特点，复制步骤如下：若二叉树不空，则首先复制根结点，这相当于二叉树先序遍历算法中访问根结点的语句；然后分别复制二叉树根结点的左子树和右子树，这相当于先序遍历中递归遍历左子树和右子树的语句。因此，复制函数的实现与二叉树先序遍历的实现非常类似。

**算法5.4 复制二叉树**

###### 【算法步骤】

```
如果是空树，递归结束，否则执行以下操作：
    申请一个新结点空间，复制根结点；
    递归复制左子树；
    递归复制右子树。
```

###### 【算法描述】

```c
void Copy(BiTree T,BiTree &NewT)
{//复制一棵和T完全相同的二叉树 
   if(T==NULL)                         //如果是空树，递归结束 
   { 
      NewT=NULL; 
      return;  
} 
   else 
   { 
      NewT=new BiTNode; 
      NewT->data=T->data;            //复制根结点 
      Copy(T->lchild,NewT->lchild);  //递归复制左子树 
      Copy(T->rchild,NewT->rchild);  //递归复制右子树 
    }                                 //else 
}
```

#### 3.计算二叉树的深度

二叉树的深度为树中结点的最大层次，二叉树的深度为左右子树深度的较大者加1。算法5.5 计算二叉树的深度

###### 【算法步骤】

```
如果是空树，递归结束，深度为0，否则执行以下操作：
    递归计算左子树的深度记为m；
    递归计算右子树的深度记为n；
    如果m大于n，二叉树的深度为m+1，否则为n+1。
```

###### 【算法描述】

```c
int Depth(BiTree T)
{//计算二叉树T的深度
   if(T==NULL) return 0;                                //如果是空树，深度为0，递归结束
   else
   {
     m=Depth(T->lchild);                                //递归计算左子树的深度记为m
     n=Depth(T->rchild);                                //递归计算右子树的深度记为n
     if(m>n) return(m+1);                               //二叉树的深度为m与n的较大者加1
     else return(n+1);
   }
}
```

显然，计算二叉树的深度是在后序遍历二叉树的基础上进行的运算。
#### 4.统计二叉树中结点的个数
如果是空树，则结点个数为0；否则，结点个数为左子树的结点个数加上右子树的结点个数再加上1。
**算法5.6 统计二叉树中结点的个数**
###### 【算法描述】
```
int NodeCount(BiTree T)
{//统计二叉树T中结点的个数
   if(T==NULL) return 0;                //如果是空树，则结点个数为0，递归结束
   else return NodeCount(T->lchild)+NodeCount(T->rchild)+1;
                                       //否则结点个数为左子树的结点个数+右子树的结点个数+1
}
```
## 2 线索二叉树

### 1)．线索二叉树的基本概念

遍历二叉树是以一定规则将二叉树中的结点排列成一个线性序列，得到二叉树中结点的先序序列、中序序列或后序序列。这实质上是对一个非线性结构进行线性化操作，使每个结点（除第一个和最后一个外）在这些线性序列中有且仅有一个直接前驱和直接后继（在不至于混淆的情况，后续描述中省去“直接”二字）。例如在图5.5所示的二叉树结点的中序序列a+b*c-d-e/f中，“c”的前驱是“*”，后继是“-”。

但是，当以二叉链表作为存储结构时，只能找到结点的左、右孩子信息，而不能直接得到结点在任一序列中的前驱和后继信息，这种信息只有在遍历的动态过程中才能得到，为此引入线索二叉树来保存这些在动态过程中得到的有关前驱和后继的信息。

虽然可以在每个结点中增加两个指针域来存放在遍历时得到的有关前驱和后继信息，但这样做使得结构的存储密度大大降低。由于有n个结点的二叉链表中必定存在n+1个空链域，因此可以充分利用这些空链域来存放结点的前驱和后继信息。

试做如下规定：若结点有左子树，则其lchild域指示其左孩子，否则令lchild域指示其前驱；若结点有右子树，则其rchild域指示其右孩子，否则令rchild域指示其后继。为了避免混淆，尚需改变结点结构，增加两个标志域，其结点形式如图5.15所示。

![image-20240904114031238](D:\文档\笔记\技术\算法\image-20240904114031238.png)

​				图5.15 线索二叉树的结点形式

其中：

![image-20240904114113360](D:\文档\笔记\技术\算法\image-20240904114113360.png)

二叉树的二叉线索类型定义如下：

```c
//- - - - -二叉树的二叉线索存储表示- - - - -
typedef struct BiThrNode
{
   TElemType data；
   struct BiThrNode *lchild,*rchild；            //左右孩子指针
   int LTag,RTag；                               //左右标志
}BiThrNode,*BiThrTree；
```

以这种结点结构构成的二叉链表作为二叉树的存储结构，叫做线索链表，其中指向结点前驱和后继的指针，叫做线索。加上线索的二叉树称之为线索二叉树（Threaded Binary Tree）。对二叉树以某种次序遍历使其变为线索二叉树的过程叫做线索化。

例如图5.16（a）所示为中序线索二叉树，与其对应的中序线索链表如图5.16（b）所示。其中实线为指针（指向左、右子树），虚线为线索（指向前驱和后继）。为了方便起见，仿照线性表的存储结构，在二叉树的线索链表上也添加一个头结点，并令其lchild域的指针指向二叉树的根结点，其rchild域的指针指向中序遍历时访问的最后一个结点；同时，令二叉树中序序列中第一个结点的lchild域指针和最后一个结点rchild域的指针均指向头结点。这好比为二叉树建立了一个双向线索链表，既可从第一个结点起顺后继进行遍历，也可从最后一个结点起顺前驱进行遍历。

### 2)．构造线索二叉树

由于线索二叉树构造的实质是将二叉链表中的空指针改为指向前驱或后继的线索，而前驱或后继的信息只有在遍历时才能得到，因此线索化的过程即为在遍历的过程中修改空指针的过程，可用递归算法。对二叉树按照不同的遍历次序进行线索化，可以得到不同的线索二叉树，包括先序线索二叉树、中序线索二叉树和后序线索二叉树。下面重点介绍中序线索化的算法。

为了记下遍历过程中访问结点的先后关系，附设一个指针pre始终指向刚刚访问过的结点，而指针p指向当前访问的结点，由此记录下遍历过程中访问结点的先后关系。算法5.7是对树中任意一个结点p为根的子树中序线索化的过程，算法5.8通过调用算法5.7来完成整个二叉树的中序线索化。

![image-20240904114213966](D:\文档\笔记\技术\算法\image-20240904114213966.png)

​			图5.16 线索二叉树及其存储结构
**算法5.7 以结点p为根的子树中序线索化**

###### 【算法步骤】

```
1.如果p非空，左子树递归线索化。

2.如果p的左孩子为空，则给p加上左线索，将其LTag置为1，让p的左孩子指针指向pre（前驱）；否则将p的LTag置为0。

3.如果pre的右孩子为空，则给pre加上右线索，将其RTag置为1，让pre的右孩子指针指向p（后继）；否则将pre的RTag置为0。

4.将pre指向刚访问过的结点p，即pre=p。

5.右子树递归线索化
```

###### 【算法描述】

```c
void InThreading(BiThrTree p)
{//pre是全局变量，初始化时其右孩子指针为空，便于在树的最左点开始建线索 
   if(p) 
   { 
      InThreading(p->lchild);      //左子树递归线索化 
      if(!p->lchild)               //p的左孩子为空 
      { 
         p->LTag=1;                //给p加上左线索 
         p->lchild=pre;            //p的左孩子指针指向pre（前驱） 
      }                            //if 
      else p->LTag=0;     
      if(!pre->rchild)            //pre的右孩子为空 
      { 
         pre->RTag=1;             //给pre加上右线索 
         pre->rchld=p;            //pre的右孩子指针指向p（后继） 
      }                           //if 
      else p->RTag=0;     
      pre=p;                      //保持pre指向p的前驱 
      InThrending(p->rchild);    //右子树递归线索化 
   } 
}
```

算法5.8 带头结点的二叉树中序线索化

###### 【算法描述】

```c
void InOrderThreading(BiThrTree &Thrt,BiThrTree T)
{//中序遍历二叉树T，并将其中序线索化，Thrt指向头结点 
   Thrt=new BiThrNode；           //建头结点 
   Thrt->LTag=0;                  //头结点有左孩子，若树非空，则其左孩子为树根 
   Thrt->RTag=1;                  //头结点的右孩子指针为右线索 
   Thrt->rchild=Thrt;             //初始化时右指针指向自己 
   if(!T)  Thrt->lchild=Thrt;     //若树为空，则左指针也指向自己 
   else 
   { 
      Thrt->lchild=T;  pre=Thrt; //头结点的左孩子指向根，pre初值指向头结点  
      InThreading(T);            //调用算法5.7，对以T为根的二叉树进行中序线索化 
      pre->rchild=Thrt;         //算法5.7结束后，pre为最右结点，pre的右线索指向头结点   
      pre->RTag=1; 
      Thrt->rchild=pre;         //头结点的右线索指向pre 
   } 
}
```

### 3)．遍历线索二叉树

由于有了结点的前驱和后继信息，线索二叉树的遍历和在指定次序下查找结点的前驱和后继算法都变得简单。因此，若需经常查找结点在所遍历线性序列中的前驱和后继，则采用线索链表作为存储结构。下面分3种情况讨论在线索二叉树中如何查找结点的前驱和后继。

#### 1.在中序线索二叉树中查找

```
1.查找p指针所指结点的前驱：
    若p->LTag为1，则p的左链指示其前驱；
    若p->LTag为0，则说明p有左子树，结点的前驱是遍历左子树时最后访问的一个结点（左子树中最右下的结点）。
    
2.查找p指针所指结点的后继：
    若p->RTag为1，则p的右链指示其后继，以图5.16所示的中序线索树为例来看，结点b的后继为结点*；
    若p->RTag为0，则说明p有右子树。根据中序遍历的规律可知，结点的后继应是遍历其右子树时访问的第一个结点，即右子树中最左下的结点。例如在找结点*的后继时，首先沿右指针找到其右子树的根结点-，然后顺其左指针往下直至其左标志为1的结点，即为结点*的后继，在图中是结点c。
```

#### 2.在先序线索二叉树中查找

```
1.查找p指针所指结点的前驱：
    若p->LTag为1，则p的左链指示其前驱；
    若p->LTag为0，则说明p有左子树。此时p的前驱有两种情况：若*p是其双亲的左孩子，则其前驱为其双亲结点；否则应是其双亲的左子树上先序遍历最后访问到的结点。

2.查找p指针所指结点的后继：
	若p->RTag为1，则p的右链指示其后继；
	若p->RTag为0，则说明p有右子树。按先序遍历的规则可知，*p的后继必为其左子树根（若存在）或右子树根。
```

#### 3.在后序线索二叉树中查找

```
1.查找p指针所指结点的前驱：
    若p->LTag为1，则p的左链指示其前驱；
    若p->LTag为0，当p->RTag也为0时，则p的右链指示其前驱；若p->LTag为0，而p->RTag为1时，则p的左链指示其前驱。

2.查找p指针所指结点的后继情况比较复杂，分以下情况讨论：
    若*p是二叉树的根，则其后继为空；
    若*p是其双亲的右孩子，则其后继为双亲结点；
    若*p是其双亲的左孩子，且*p没有右兄弟，则其后继为双亲结点；
    若*p是其双亲的左孩子，且*p有右兄弟，则其后继为双亲的右子树上按后序遍历列出的第一个结点（即右子树中“最左下”的叶结点）。

例如，图5.17所示为后序线索二叉树，结点B的后继为结点C，结点C的后继为结点D，结点F的后继为结点G，而结点D的后继为结点E。
```
![image-20240904114343087](D:\文档\笔记\技术\算法\image-20240904114343087.png)
​						图5.17 后序后继线索二叉树

可见，在先序线索化树上找前驱或在后序线索化树上找后继时都比较复杂，此时若需要，可直接建立含4个指针的线索链表。

由于有了结点的前驱和后继的信息，线索二叉树的遍历操作无需设栈，避免了频繁的进栈、出栈，因此在时间和空间上都较遍历二叉树节省。如果遍历某种次序的线索二叉树，则只要从该次序下的根结点出发，反复查找其在该次序下的后继，直到叶子结点。下面以遍历中序线索二叉树为例介绍该算法。

**算法5.9 遍历中序线索二叉树**

###### 【算法步骤】

```
1.指针p指向根结点。

2.p为非空树或遍历未结束时，循环执行以下操作：
    沿左孩子向下，到达最左下结点*p，它是中序的第一个结点；
    访问*p；
    沿右线索反复查找当前结点*p的后继结点并访问后继结点，直至右线索为0或者遍历结束；
    转向p的右子树。
```

###### 【算法描述】

```c
void InOrderTraverse_Thr(BiThrTree T)
{//T指向头结点，头结点的左链lchild指向根结点，可参见线索化算法5.8。 
 //中序遍历二叉线索树T的非递归算法，对每个数据元素直接输出 
   p=T->lchild;                       //p指向根结点 
   while(p!=T)                        //空树或遍历结束时，p==T 
   { 
      while(p->LTag==0) p=p->lchild; //沿左孩子向下 
      cout<<p->data;                 //访问其左子树为空的结点 
      while(p->RTag==1&&p->rchild!=T) 
      { 
         p=p->rchild;cout<<p->data;  //沿右线索访问后继结点 
      } 
      p=p->rchild;                   //转向p的右子树 
   } 
}
```

###### 【算法分析】

遍历线索二叉树的时间复杂度为O(n)，空间复杂度为O(1)，这是因为线索二叉树的遍历不需要使用栈来实现递归操作。

# 五、树和森林

## 1.树的存储结构

### 1)．双亲表示法

这种表示方法中，以一组连续的存储单元存储树的结点，每个结点除了数据域data外，还附设一个parent域用以指示其双亲结点的位置，其结点形式如图所示。

![image-20240904174411803](D:\文档\笔记\技术\算法\image-20240904174411803.png)

例如，下图所示为一棵树及其双亲表示的存储结构。

![image-20240904174451136](D:\文档\笔记\技术\算法\image-20240904174451136.png)
​					图5.19 树的双亲表示法示例

### 2)．孩子表示法
由于树中每个结点可能有多棵子树，则可用多重链表，即每个结点有多个指针域，其中每个指针指向一棵子树的根结点，此时链表中的结点可以有如图5.20所示的两种结点格式。
![image-20240904174545684](D:\文档\笔记\技术\算法\image-20240904174545684.png)
​								图5.20 孩子表示法的两种结点

若采用第一种结点格式，则多重链表中的结点是同构的，其中d为树的度。由于树中很多结点的度小于d，所以链表中有很多空链域，空间较浪费，不难推出，在一棵有n个结点度为k的树中必有n(k−1)+1个空链域。

若采用第二种结点格式，则多重链表中的结点是不同构的，其中d为结点的度，degree域的值同d。此时，虽能节约存储空间，但操作不方便。

另一种办法是，把每个结点的孩子结点排列起来，看成是一个线性表，且以单链表做存储结构，则n个结点有n个孩子链表（叶子的孩子链表为空表）​。而n个头指针又组成一个线性表，为了便于查找，可采用顺序存储结构。

图5.21（a）所示为图5.19中的树的孩子表示法。与双亲表示法相反，孩子表示法便于那些涉及孩子的操作的实现。可以把双亲表示法和孩子表示法结合起来，即将双亲表示和孩子链表合在一起。图5.21（b）所示的就是这种存储结构的一例，它和图5.21（a）表示的是同一棵树。

![image-20240904174700588](D:\文档\笔记\技术\算法\image-20240904174700588.png)
​							图5.21 图5.19的树的另外两种表示法

### 3)．孩子兄弟法
又称二叉树表示法，或二叉链表表示法，即以二叉链表做树的存储结构。链表中结点的两个链域分别指向该结点的第一个孩子结点和下一个兄弟结点，分别命名为firstchild域和nextsibling域，其结点形式如图5.22所示。
![image-20240904174751283](D:\文档\笔记\技术\算法\image-20240904174751283.png)
​							图5.22 孩子兄弟表示法的结点

```c
//- - - - - -树的二叉链表（孩子－兄弟）存储表示- - - - -
typedef struct CSNode{
    ElemType data;
    struct CSNode *firstchild,*nextsibling;
}CSNode,*CSTree;
```

图5.23所示为图5.19中的树的孩子兄弟链表。利用这种存储结构便于实现各种树的操作。首先易于实现找结点孩子等的操作。例如，若要访问结点x的第i个孩子，则只要先从firstchild域找到第1个孩子结点，然后沿着孩子结点的nextsibling域连续走i−1步，便可找到x的第i个孩子。当然，如果为每个结点增设一个parent域，则同样能方便地实现查找双亲的操作。
![image-20240904174850663](D:\文档\笔记\技术\算法\image-20240904174850663.png)
​							图5.23 图5.19中树的二叉链表表示法

这种存储结构的优点是它和二叉树的二叉链表表示完全一样，便于将一般的树结构转换为二叉树进行处理，利用二叉树的算法来实现对树的操作。因此孩子兄弟表示法是应用较为普遍的一种树的存储表示方法。

## 2.森林与二叉树的转换
从树的二叉链表表示的定义可知，任何一棵和树对应的二叉树，其根结点的右子树必空。若把森林中第二棵树的根结点看成是第一棵树的根结点的兄弟，则同样可导出森林和二叉树的对应关系。
例如，图5.24所示为森林与二叉树之间的对应关系。
![image-20240904175009343](D:\文档\笔记\技术\算法\image-20240904175009343.png)
​						图5.24 森林与二叉树的对应关系示例

这个一一对应的关系说明森林或树与二叉树可以相互转换。
### 1)．森林转换成二叉树如果F={T1, T2,…, Tm}是森林，则可按如下规则转换成一棵二叉树B=(root, LB, RB)。
（1）若F为空，即m=0，则B为空树；
（2）若F非空，即m≠0，则B的根root即为森林中第一棵树的根ROOT(T1)；B的左子树LB是从T1中根结点的子树森林F1={T11, T12,…, T1m}转换而成的二叉树；其右子树RB是从森林F′={T2, T3, …, Tm}转换而成的二叉树。
### 2)．二叉树转换成森林
如果B=(root, LB, RB)是一棵二叉树，则可按如下规则转换成森林F={T1, T2，…, Tm}：（1）若B为空，则F为空；
（2）若B非空，则F中第一棵树T1的根ROOT(T1)即为二叉树B的根root；T1中根结点的子树森林F1是由B的左子树LB转换而成的森林；F中除T1之外其余树组成的森林F′={T2, T3,…, Tm}是由B的右子树RB转换而成的森林。

从上述递归定义容易写出相互转换的递归算法。同时，森林和树的操作亦可转换成二叉树的操作来实现。

## 3. 树和森林的遍历
### 1)．树的遍历
由树结构的定义可引出两种次序遍历树的方法：一种是先根（次序）遍历树，即：先访问树的根结点，然后依次先根遍历根的每棵子树；另一种是后根（次序）遍历，即先依次后根遍历每棵子树，然后访问根结点。
例如，对图5.19所示的树进行先根遍历，可得树的先根序列为：
```
R A D E B C F G H K
```
若对此树进行后根遍历，则得树的后根序列为：
```
D E A B G H K F C R
```
按照森林和树相互递归的定义，可以推出森林的两种遍历方法：先序遍历和中序遍历。
### 2)．森林的遍历
#### 1.先序遍历森林
若森林非空，则可按下述规则遍历：
① 访问森林中第一棵树的根结点；
② 先序遍历第一棵树的根结点的子树森林；
③ 先序遍历除去第一棵树之后剩余的树构成的森林。

#### 2.中序遍历森林
若森林非空，则可按下述规则遍历：
① 中序遍历森林中第一棵树的根结点的子树森林；
② 访问第一棵树的根结点；
③ 中序遍历除去第一棵树之后剩余的树构成的森林。

若对图5.24中所示的森林进行先序遍历和中序遍历，则分别得到森林的先序序列为：
```
A B C D E F G H I J
```
中序序列为：
```
B C D A F E H J I G
```
由5.6.2小节森林与二叉树之间转换的规则可知，当森林转换成二叉树时，其第一棵树的子树森林转换成左子树，剩余树的森林转换成右子树，则上述森林的先序和中序遍历即为其对应的二叉树的先序和中序遍历。若对图5.24中所示的和森林对应的二叉树分别进行先序和中序遍历，可得和上述相同的序列。
由此可见，当以二叉链表做树的存储结构时，树的先根遍历和后根遍历可借用二叉树的先序遍历和中序遍历的算法实现。
# 六、 哈夫曼树及其应用
## 1.哈夫曼树的基本概念
**哈夫曼**（Huffman）树又称最优树，是一类带权路径长度最短的树，在实际中有广泛的用途。哈夫曼树的定义，涉及路径、路径长度、权等概念，下面先给出这些概念的定义，然后再介绍哈夫曼树。

- （1）路径：从树中一个结点到另一个结点之间的分支构成这两个结点之间的路径。
- （2）路径长度：路径上的分支数目称作路径长度。
- （3）树的路径长度：从树根到每一结点的路径长度之和。
- （4）权：赋予某个实体的一个量，是对实体的某个或某些属性的数值化描述。在数据结构中，实体有结点（元素）和边（关系）两大类，所以对应有结点权和边权。结点权或边权具体代表什么意义，由具体情况决定。如果在一棵树中的结点上带有权值，则对应的就有带权树等概念。
- （5）结点的带权路径长度：从该结点到树根之间的路径长度与结点上权的乘积。
- （6）树的带权路径长度：树中所有叶子结点的带权路径长度之和，通常记作[插图]。
- （7）哈夫曼树：假设有m个权值{w1, w2,…, wm}，可以构造一棵含n个叶子结点的二叉树，每个叶子结点的权为wi，则其中带权路径长度WPL最小的二叉树称做最优二叉树或哈夫曼树。

例如，图5.25中所示的3棵二叉树，都含4个叶子结点a、b、c、d，分别带权7、5、2、4，它们的带权路径长度分别为

![image-20240904175557416](D:\文档\笔记\技术\算法\image-20240904175557416.png)
					图5.25 具有不同带权路径长度的二叉树

其中以（c）树的为最小。可以验证，它恰为哈夫曼树，即其带权路径长度在所有带权为7、5、2、4的4个叶子结点的二叉树中居最小。

哈夫曼树中具有不同权值的叶子结点的分布有什么特点呢？从上面的例子中，可以直观地发现，在哈夫曼树中，权值越大的结点离根结点越近。根据这个特点，哈夫曼最早给出了一个构造哈夫曼树的方法，称哈夫曼算法。

## 2.哈夫曼树的构造算法
### 1)．哈夫曼树的构造过程
（1）根据给定的n个权值{w1, w2,…, wn}，构造n棵只有根结点的二叉树，这n棵二叉树构成一个森林F。
（2）在森林F中选取两棵根结点的权值最小的树作为左右子树构造一棵新的二叉树，且置新的二叉树的根结点的权值为其左、右子树上根结点的权值之和。
（3）在森林F中删除这两棵树，同时将新得到的二叉树加入F中。
（4）重复（2）和（3）​，直到F只含一棵树为止。这棵树便是哈夫曼树。

在构造哈夫曼树时，首先选择权小的，这样保证权大的离根较近，这样一来，在计算树的带权路径长度时，自然会得到最小带权路径长度，这种生成算法是一种典型的贪心法。

例如，图5.26所示为图5.25（c）所示的哈夫曼树的构造过程。其中，根结点上标注的数字是所赋的权。

![image-20240904191718874](D:\文档\笔记\技术\算法\image-20240904191718874.png)
​					图5.26 哈夫曼树的构造过程

### 2)．哈夫曼算法的实现
哈夫曼树是一种二叉树，当然可以采用前面介绍过的通用存储方法，而由于哈夫曼树中没有度为1的结点，则一棵有n个叶子结点的哈夫曼树共有2n−1个结点，可以存储在一个大小为2n−1的一维数组中。树中每个结点还要包含其双亲信息和孩子结点的信息，由此，每个结点的存储结构设计如图5.27所示。
![image-20240904191813114](D:\文档\笔记\技术\算法\image-20240904191813114.png)
​								图5.27 哈夫曼树结点的形式

```c
//- - - - -哈夫曼树的存储表示 - - - - -
typedef struct{
    int weight;                         //结点的权值
    int parent,lchild,rchild;           //结点的双亲、左孩子、右孩子的下标
}HTNode,*HuffmanTree;                   //动态分配数组存储哈夫曼树
```

哈夫曼树的各结点存储在由HuffmanTree定义的动态分配的数组中，为了实现方便，数组的0号单元不使用，从1号单元开始使用，所以数组的大小为2n。将叶子结点集中存储在前面部分1～n个位置，而后面的n−1个位置存储其余非叶子结点。

#### 算法5.10 构造哈夫曼树

###### 【算法步骤】

构造哈夫曼树算法的实现可以分成两大部分。

① 初始化：首先动态申请2n个单元；然后循环2n-1次，从1号单元开始，依次将1至2n-1所有单元中的双亲、左孩子、右孩子的下标都初始化为0；最后再循环n次，输入前n个单元中叶子结点的权值。

② 创建树：循环n-1次，通过n−1次的选择、删除与合并来创建哈夫曼树。选择是从当前森林中选择双亲为0且权值最小的两个树根结点s1和s2；删除是指将结点s1和s2的双亲改为非0；合并就是将s1和s2的权值和作为一个新结点的权值依次存入到数组的第n+1之后的单元中，同时记录这个新结点左孩子的下标为s1，右孩子的下标为s2。

###### 【算法描述】

```c
void CreateHuffmanTree(HuffmanTree &HT,int n)
{//构造哈夫曼树HT 
   if(n<=1) return; 
   m=2*n-1; 
   HT=new HTNode[m+1];  //0号单元未用，所以需要动态分配m+1个单元，HT[m]表示根结点 
   for(i=1;i<=m;++i)    //将1~m号单元中的双亲、左孩子，右孩子的下标都初始化为0  
      {HT[i].parent=0;HT[i].lchild=0;HT[i].rchild=0;} 
   for(i=1;i<=n;++i)    //输入前n个单元中叶子结点的权值 
      cin>>HT[i].weight;  
/*- - - - - - - - - - -初始化工作结束，下面开始创建哈夫曼树－ - - -  - - - - - -*/ 
   for(i=n+1;i<=m;++i) 
   {//通过n-1次的选择、删除、合并来创建哈夫曼树 
      Select(HT,i-1, s1, s2); 
      //在HT[k](1≤k≤i-1)中选择两个其双亲域为0且权值最小的结点,并返回它们在HT中的序号s1和s2 
      HT[s1].parent=i;HT[s2].parent=i; 
      //得到新结点i，从森林中删除s1，s2，将s1和s2的双亲域由0改为i 
      HT[i].lchild=s1;HT[i].rchild=s2;             //s1,s2分别作为i的左右孩子 
      HT[i].weight=HT[s1].weight+HT[s2].weight;   //i的权值为左右孩子权值之和 
   }                                              //for 
}
```

【例5.2】 已知w=(5,29,7,8,14,23,3,11)，利用算法5.10试构造一棵哈夫曼树，计算树的带权路径长度，并给出其构造过程中存储结构HT的初始状态和终结状态。
n=8，则m=15，按算法5.10可构造一棵哈夫曼树，如图5.28所示。
![image-20240904191947897](D:\文档\笔记\技术\算法\image-20240904191947897.png)
​							图5.28 例5.2的哈夫曼树

树的带权路径长度计算如下：
![image-20240904192023368](D:\文档\笔记\技术\算法\image-20240904192023368.png)
其存储结构HT的初始状态如表5.2（a）所示，其终结状态如表5.2（b）所示。
表5.2 例5.2的存储结构

![image-20240904192052660](D:\文档\笔记\技术\算法\image-20240904192052660.png)

哈夫曼树在通信、编码和数据压缩等技术领域有着广泛的应用，下面讨论一个构造通信码的典型应用——哈夫曼编码。

## 3.哈夫曼编码

### 1)．哈夫曼编码的主要思想

在5.2节提出的案例5.1中已经讨论，在进行数据压缩时，为了使压缩后的数据文件尽可能短，可采用不定长编码。其基本思想是：为出现次数较多的字符编以较短的编码。为确保对数据文件进行有效的压缩和对压缩文件进行正确的解码，可以利用哈夫曼树来设计二进制编码。哈夫曼树的具体构造过程可以根据算法5.10，图5.26所示为图5.4所示的哈夫曼树的构造过程。在图5.4所示的哈夫曼树中，约定左分支标记为0，右分支标记为1，则根结点到每个叶子结点路径上的0、1序列即为相应字符的编码。

下面给出有关编码的两个概念。

（1）前缀编码：如果在一个编码方案中，任一个编码都不是其他任何编码的前缀（最左子串），则称编码是前缀编码。例如，案例5.1中的第2种编码方案（见表5.1（b））的编码0，10，110，111是前缀编码，而第3种编码方案（见表5.1（c））的编码0，01，010，111就不是前缀编码。前缀编码可以保证对压缩文件进行解码时不产生二义性，确保正确解码。

（2）哈夫曼编码：对一棵具有n个叶子的哈夫曼树，若对树中的每个左分支赋予0，右分支赋予1，则从根到每个叶子的路径上，各分支的赋值分别构成一个二进制串，该二进制串就称为哈夫曼编码。

**哈夫曼编码满足下面的两个性质。**

**性质1** 哈夫曼编码是前缀编码。

```
证明：哈夫曼编码是根到叶子路径上的编码序列，由树的特点知，若路径A是另一条路径B的最左部分，则B经过了A，则A的终点一定不是叶子。而哈夫曼编码对应路径的终点一定为叶子，因此，任一哈夫曼码都不会与任意其他哈夫曼编码的前缀部分完全重叠，因此哈夫曼编码是前缀编码。
```

**性质2** 哈夫曼编码是最优前缀编码。

对于包括n个字符的数据文件，分别以它们的出现次数为权值构造哈夫曼树，则利用该树对应的哈夫曼编码对文件进行编码，能使该文件压缩后对应的二进制文件的长度最短。证明：假设每种字符在数据文件中出现的次数为wi，其编码长度为li，文件中只有n种字符，则文件总长为<img src="D:\文档\笔记\技术\算法\image-20240904192409375.png" alt="image-20240904192409375" style="zoom:25%;" />。对应到二叉树上，若置wi为叶子结点的权，li恰为从根到叶子的路径长度，则<img src="D:\文档\笔记\技术\算法\image-20240904192434361.png" alt="image-20240904192434361" style="zoom:25%;" />恰为二叉树上带权路径长度。由此可见，设计文件总长最短的二进制前缀编码问题，就是以n种字符出现的频率作权设计一棵哈夫曼树的问题。而由哈夫曼树的构造方法可知，出现次数较多的字符对应的编码较短，这便直观地说明了该定理是成立的。下面给出根据哈夫曼树构造哈夫曼编码的算法。

### 2)．哈夫曼编码的算法实现

在构造哈夫曼树之后，求哈夫曼编码的主要思想是：依次以叶子为出发点，向上回溯至根结点为止。回溯时走左分支则生成代码0，走右分支则生成代码1。

由于每个哈夫曼编码是变长编码，因此使用一个指针数组来存放每个字符编码串的首地址。

```c
//- - - - -哈夫曼编码表的存储表示- - - - -
typedef char **HuffmanCode;  // 动态分配数组存储哈夫曼编码表
```

各字符的哈夫曼编码存储在由HuffmanCode定义的动态分配的数组HC中，为了实现方便，数组的0号单元不使用，从1号单元开始使用，所以数组HC的大小为n+1，即编码表HC包括n+1行。但因为每个字符编码的长度事先不能确定，所以不能预先为每个字符分配大小合适的存储空间。为不浪费存储空间，动态分配一个长度为n（字符编码长度一定小于n）的一维数组cd，用来临时存放当前正在求解的第i（1≤i≤n）个字符的编码，当第i个字符的编码求解完毕后，根据数组cd的字符串长度分配HC[i]的空间，然后将数组cd中的编码复制到HC[i]中。

因为求解编码时是从哈夫曼树的叶子出发，向上回溯至根结点。所以对于每个字符，得到的编码顺序是从右向左的，故将编码向数组cd存放的顺序也是从后向前的，即每个字符的第1个编码存放在cd[n-2]中（cd[n-1]存放字符串结束标志’\0’），第2个编码存放在cd[n-3]中，依此类推，直到全部编码存放完毕。

**算法5.11 根据哈夫曼树求哈夫曼编码**

###### 【算法步骤】

① 分配存储n个字符编码的编码表空间HC，长度为n+1；分配临时存储每个字符编码的动态数组空间cd，cd[n-1]置为’\0’。

② 逐个求解n个字符的编码，循环n次，执行以下操作：
- 设置变量start用于记录编码在cd中存放的位置，start初始时指向最后，即编码结束符位置n-1；
- 设置变量c用于记录从叶子结点向上回溯至根结点所经过的结点下标，c初始时为当前待编码字符的下标i，f用于记录i的双亲结点的下标；
- 从叶子结点向上回溯至根结点，求得字符i的编码，当f没有到达根结点时，循环执行以下操作：
	回溯一次start向前指一个位置，即--start；若结点c是f的左孩子，则生成代码0，否则生成代码1，生成的代码0或1保存在cd[start]中；继续向上回溯，改变c和f的值。
	根据数组cd的字符串长度为第i个字符编码分配空间HC[i]，然后将数组cd中的编码复制到HC[i]中。

③ 释放临时空间cd。

###### 【算法描述】

```c
void CreatHuffmanCode(HuffmanTree HT,HuffmanCode &HC,int n)
{//从叶子到根逆向求每个字符的哈夫曼编码，存储在编码表HC中 
   HC=new char*[n+1];                         //分配存储n个字符编码的编码表空间 
   cd=new char[n];                            //分配临时存放每个字符编码的动态数组空间 
   cd[n-1]=’\0’;                              //编码结束符 
   for(i=1;i<=n;++i)                          //逐个字符求哈夫曼编码 
   { 
      start=n-1;                              //start开始时指向最后，即编码结束符位置 
      c=i;f=HT[i].parent;                     //f指向结点c的双亲结点 
      while(f!=0)                             //从叶子结点开始向上回溯，直到根结点 
      {                             
         --start;                            //回溯一次start向前指一个位置 
         if(HT[f].lchild==c) cd[start]=’0’;  //结点c是f的左孩子，则生成代码0 
         else cd[start]=’1’;                 //结点c是f的右孩子，则生成代码1 
         c=f;f=HT[f].parent;                //继续向上回溯 
      }                                     //求出第i个字符的编码 
      HC[i]=new char[n-start];              //为第i个字符编码分配空间 
      strcpy(HC[i],&cd[start])；            //将求得的编码从临时空间cd复制到HC的当前行中 
}                                          //for 
delete cd;                                 //释放临时空间 
}
```

【例5.3】 已知某系统在通信联络中只可能出现8种字符，其概率分别为0.05，0.29，0.07，0.08，0.14，0.23，0.03，0.11，试设计哈夫曼编码。

根据其出现的概率可设8个字符的权值为：w=(5,29,7,8,14,23,3,11)，其对应的哈夫曼树如图5.28所示。将树的左分支标记为0，右分支标记为1，便得到其哈夫曼编码表如图5.29所示。

![image-20240904192224286](D:\文档\笔记\技术\算法\image-20240904192224286.png)

### 3)．文件的编码和译码
#### 1.编码
有了字符集的哈夫曼编码表之后，对数据文件的编码过程是：依次读入文件中的字符c，在哈夫曼编码表HC中找到此字符，将字符c转换为编码表中存放的编码串。

#### 2.译码
对编码后的文件进行译码的过程必须借助于哈夫曼树。具体过程是：依次读入文件的二进制码，从哈夫曼树的根结点（即HT[m]）出发，若当前读入0，则走向左孩子，否则走向右孩子。一旦到达某一叶子HT[i]时便译出相应的字符编码HC[i]。然后重新从根出发继续译码，直至文件结束