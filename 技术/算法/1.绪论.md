# 一、研究对象
**早期**的计算机主要用于**数值计算**; **现在**，计算机主要用于**非数值计算**，包括处理字符、表格和图像等具有一定结构的数据。这些数据内容存在着某种联系，只有分清楚数据的内在联系，合理地组织数据，才能对它们进行有效的处理，设计出高效的算法。如何合理地组织数据、高效地处理数据，这就是“数据结构”主要研究的问题
计算机主要用于数值计算时，一般要经过如下几个步骤：首先从具体问题抽象出数学模型，然后设计一个解此数学模型的算法，最后编写程序，进行测试、调试，直到解决问题。在此过程中寻求数学模型的实质是分析问题，从中提取操作的对象，并找出这些操作对象之间的关系，然后用数学语言加以描述，即建立相应的数学方程。例如，用计算机进行全球天气预报时，就需要求解一组球面坐标系下的二阶椭圆偏微分方程；预测人口增长情况的数学模型为常微分方程。求解这些数学方程的算法是计算数学研究的范畴，如高斯消元法、差分法、有限元法等算法。数据结构主要研究非数值计算问题，非数值计算问题无法用数学方程建立数学模型
目前，数据结构在计算机科学中是一门综合性的专业基础课。数据结构的研究不仅涉及计算机硬件（特别是编码理论、存储装置和存取方法等）的研究范围，而且和计算机软件的研究有着密切的关系，无论是编译程序还是操作系统都涉及数据元素在存储器中的分配问题。在研究信息检索时也必须考虑如何组织数据，以使查找和存取数据元素更为方便。因此，可以认为数据结构是介于数学、**计算机硬件**和**软件**三者之间的一门核心课程。有关“数据结构”的研究仍不断发展，一方面，面向各专门领域中特殊问题的数据结构正在研究和发展；另一方面，从抽象数据类型的观点来讨论数据结构，已成为一种新的趋势，越来越被人们所重视。

# 二、专业术语
## 1.对象概念
**数据**（Data）是**客观事物**的符号表示，是**所有能输入到计算机中并被计算机程序处理的**符号的总称。如数学计算中用到的整数和实数，文本编辑中用到的字符串，多媒体程序处理的图形、图像、声音及动画等通过特殊编码定义后的数据。
**数据元素**（Data Element）是数据的基本单位，在计算机中通常作为一个整体进行考虑和处理。在有些情况下，数据元素也称为元素、记录等。数据元素用于完整地描述一个对象，如一名学生记录，树中棋盘的一个格局（状态），以及图中的一个顶点等。
**数据项**（Data Item）是组成数据元素的、有独立含义的、不可分割的最小单位。例如，学生基本信息表中的学号、姓名、性别等都是数据项。
**数据对象**（Data Object）是性质相同的数据元素的集合，是数据的一个子集。例如：整数数据对象是集合N={0，±1，±2，…}，字母字符数据对象是集合C={‘A’，‘B’，…，‘Z’，‘a’，‘b’，…，‘z’}，学生基本信息表也可以是一个数据对象。由此可以看出，不论数据元素集合是无限集（如整数集），或是有限集（如字母字符集），还是由多个数据项组成的复合数据元素（如学生表）的集合，只要集合内元素的性质均相同，都可称之为一个数据对象。

## 2.数据结构
数据结构（Data Structure）是相互之间存在一种或多种特定关系的数据元素的集合。换句话说，数据结构是带“结构”的数据元素的集合，“结构”就是指数据元素之间存在的关系。
数据结构包括逻辑结构和存储结构两个层次。
### 1).逻辑结构
数据的**逻辑结构**是从逻辑关系上描述数据，它与数据的存储无关，是独立于计算机的。因此，数据的逻辑结构可以看作是从具体问题抽象出来的数学模型。数据的逻辑结构有两个要素：一是数据元素；二是关系。数据元素的含义如前所述，关系是指数据元素间的逻辑关系。根据数据元素之间关系的不同特性，通常有四类基本结构
![image-20240718190814301](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240718190814301.png)
#### a.集合结构
数据元素之间除了“属于同一集合”的关系外，别无其他关系。例如，确定一名学生是否为班级成员，只需将班级看做一个集合结构
#### b.线性结构
数据元素之间存在一对一的关系。例如，将学生信息数据按照其入学报到的时间先后顺序进行排列，将组成一个线性结构
#### c.树结构
数据元素之间存在一对多的关系。例如，在班级的管理体系中，班长管理多个组长，每位组长管理多名组员，从而构成树形结构
#### d.图结构或网状结构
数据元素之间存在多对多的关系。例如，多位同学之间的朋友关系，任何两位同学都可以是朋友，从而构成图状结构或网状结构
### 3).操作结构
#### a.线性结构

线性结构包括线性表（典型的线性结构，如例1.1中的学生基本信息表）、栈和队列（具有特殊限制的线性表，数据操作只能在表的一端或两端进行）、字符串（也是特殊的线性表，其特殊性表现在它的数据元素仅由一个字符组成）、数组（是线性表的推广，它的数据元素是一个线性表）、广义表（也是线性表的推广，它的数据元素是一个线性表，但不同构，即或者是单元素，或者是线性表）。非线性结构包括树（具有多个分支的层次结构）和二叉树（具有两个分支的层次结构）、有向图（一种图结构，边是顶点的有序对）和无向图（另一种图结构，边是顶点的无序对）
#### b.非线性结构
集合结构、树结构和图结构
![image-20240718191330121](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240718191330121.png)
### 4).存储结构
数据对象在计算机中的存储表示称为数据的存储结构，也称为物理结构。把数据对象存储到计算机时，通常要求既要存储各数据元素的数据，又要存储数据元素之间的逻辑关系，数据元素在计算机内用一个结点来表示。数据元素在计算机中有两种基本的存储结构，分别是顺序存储结构和链式存储结构。
#### a.顺序存储结构
顺序存储结构是借助元素在存储器中的相对位置来表示数据元素之间的逻辑关系，通常借助程序设计语言的数组类型来描述
#### b.链式存储结构
顺序存储结构要求所有的元素依次存放在一片连续的存储空间中，而链式存储结构，无需占用一整块存储空间。但为了表示结点之间的关系，需要给每个结点附加指针字段，用于存放后继元素的存储地址。所以链式存储结构通常借助于程序设计语言的指针类型来描述。
## 3.数据类型
```
数据类型（Data Type）是高级程序设计语言中的一个基本概念，前面提到过顺序存储结构可以借助程序设计语言的数组类型描述，链式存储结构可以借助指针类型描述，所以数据类型和数据结构的概念密切相关。一方面，在程序设计语言中，每一个数据都属于某种数据类型。类型明显或隐含地规定了数据的取值范围、存储方式以及允许进行的运算，数据类型是一个值的集合和定义在这个值集上的一组操作的总称。例如，C语言中的整型变量，其值集为某个区间上的整数（区间大小依赖于不同的机器），定义在其上的操作为加、减、乘、除和取模等算术运算；而实型变量也有自己的取值范围和相应运算，比如取模运算是不能用于实型变量的。程序设计语言允许用户直接使用的数据类型由具体语言决定，数据类型反映了程序设计语言的数据描述和处理能力。C语言除了提供整型、实型、字符型等基本类型数据外，还允许用户自定义各种类型数据，例如数组、结构体和指针等。
```
## 4.抽象数据类型
抽象就是抽取出实际问题的本质。在计算机中使用二进制数来表示数据，在汇编语言中则可给出各种数据的十进制表示，它们是二进制数据的抽象，使用者在编程时可以直接使用，不必考虑实现细节。在高级语言中，则给出更高一级的数据抽象，出现了数据类型，如整型、实型、字符型等，可以进一步利用这些类型构造出线性表、栈、队列、树、图等复杂的抽象数据类型
抽象数据类型（Abstract Data Type，ADT）一般指由用户定义的、表示应用问题的数学模型，以及定义在这个模型上的一组操作的总称，**具体包括三部分**：数据对象、数据对象上关系的集合以及对数据对象的基本操作的集合
定义格式如下：
```
ADT 抽象数据类型名{
   数据对象：〈数据对象的定义〉
   数据关系：〈数据关系的定义〉
   基本操作：〈基本操作的定义〉
}ADT 抽象数据类型名
```

其中，数据对象和数据关系的定义采用数学符号和自然语言描述
基本操作的定义格式为：
```
基本操作名（参数表）
   初始条件：〈初始条件描述〉
   操作结果：〈操作结果描述〉
   
基本操作有两种参数：
    赋值参数只为操作提供输入值；
    引用参数以“&”打头，除可提供输入值外，还将返回操作结果

“初始条件”描述了操作执行之前数据结构和参数应满足的条件，若初始条件为空，则省略
“操作结果”说明了操作正常完成之后，数据结构的变化状况和应返回的结果
```

# 三、抽象数据类型的表示与实现
运用抽象数据类型描述数据结构，有助于在设计一个软件系统时，不必首先考虑其中包含的数据对象，以及操作在不同处理器中的表示和实现细节，而是在构成软件系统的每个相对独立的模块上定义一组数据和相应的操作，把这些数据的表示和操作细节留在模块内部解决，在更高的层次上进行软件的分析和设计，从而提高软件的整体性能和利用率。抽象数据类型的概念与面向对象方法的思想是一致的。抽象数据类型独立于具体实现，将数据和操作封装在一起，使得用户程序只能通过抽象数据类型定义的某些操作来访问其中的数据，从而实现了信息隐藏。在C++中，我们可以用类的声明表示抽象数据类型，用类的实现来实现抽象数据类型。因此，C++中实现的类相当于数据的存储结构及其在存储结构上实现的对数据的操作。
抽象数据类型和类的概念实际上反映了程序或软件设计的两层抽象：抽象数据类型相当于在概念层（或称为抽象层）上描述问题，而类相当于在实现层上描述问题。此外，C++中的类只是一个由用户定义的普通类型，可用它来定义变量（称为对象或类的实例）。因此，在C++中，最终是通过操作对象来解决实际问题的，所以我们可将该层次看做是应用层。例如，main程序就可看做是用户的应用程序
## 1.操作
### 1).预定义常量及类型：
```c
//函数结果状态代码
#define OK 1
#define ERROR 0
#define OVERFLOW -2
//Status是函数返回值类型，其值是函数结果状态代码。
typedef int Status;
```
### 2).数据结构的表示（存储结构）

    用类型定义（typedef）描述；
    数据元素类型约定为ElemType，由用户在使用该数据类型时自行定义

### 3).基本操作的算法都用如下格式的函数来描述
```
函数类型 函数名（函数参数表）
{
   //算法说明
   语句序列
}//函数名

当函数返回值为函数结果状态代码时，函数定义为Status类型。
为了便于描述算法，除了值调用方式外，增加了C++语言引用调用的参数传递方式。
在形参表中，以“&”打头的参数即为引用参数。
传递引用给函数与传递指针的效果是一样的，形参变化实参也发生变化，但引用使用起来比指针更加方便、高效。
```
### 4).内存的动态分配与释放
```
分配空间 指针变量=new数据类型;
释放空间 delete指针变量;

new:动态分配
delete:释放内存空间
```
### 5).赋值语句
```c
简单赋值 变量名=表达式;
串联赋值 变量名1=变量名2=...=变量名n=表达式;
成组赋值 (变量名1, ..., 变量名n)=(表达式1, ..., 表达式n);
结构赋值 结构名1=结构名2;
        结构名=(值1, 值2, ..., 值n);
条件赋值 变量名=条件表达式 ? 表达式T：表达式F;
交换赋值 变量名1 <-->变量名2;
```
### 6).选择语句
```c
条件语句1 if (表达式) 语句;
条件语句2 if (表达式) 语句;
         else 语句;
开关语句 switch (表达式)
          {
             case 值1: 语句序列1 ;break;
             case 值2: 语句序列2 ;break;
             …
             case 值n: 语句序列n;break;
             default: 语句序列n+1;
          }
```
### 7).循环语句
```c
for语句        for (表达式1; 条件; 表达式2) 语句;
while语句      while (条件) 语句;
do-while语句   do {
                   语句序列;
                 } while (条件);
```
### 8).结束语句
```c
函数结束语句   return 表达式;
              return;
              case或循环结束语句 break;
              异常结束语句 exit (异常代码);
```
### 9).输入输出语句使用C++流式输入输出的形式
```c++
输入语句   cin >> 变量1>>…>>变量n;
输出语句   cout << 表达式1 <<…<< 表达式n;
```
### 10).基本函数
```
求最大值    Max (表达式1,...,表达式n)
求最小值    Min (表达式1,...,表达式n)
```
## 2.实例
### 1).定义部分
```c
ADT Complex {
   数据对象：D={e1,e2|e1,e2∈R,R是实数集}
   数据关系：S={<e1,e2>|e1是复数的实部，e2 是复数的虚部}
   基本操作：
     Creat(&C,x,y)
       操作结果：构造复数C，其实部和虚部分别被赋以参数x和y的值。
     GetReal(C)
       初始条件：复数C已存在。
       操作结果：返回复数C的实部值。
     GetImag(C)
       初始条件：复数C已存在。
       操作结果：返回复数C的虚部值。
     Add(C1,C2)
       初始条件：C1，C2是复数。
       操作结果：返回两个复数C1和C2的和。
     Sub(C1,C2)
       初始条件：C1，C2是复数。
       操作结果：返回两个复数C1和C2的差。
} ADT Complex
```
### 2).表示部分
```
typedef struct                  //复数类型
{
   float Realpart;              //实部
   float Imagepart;             //虚部
}Complex;
```
### 3).实现部分
```c
void Create( &Complex C, float x, float y)
{ //构造一个复数
   C.Realpart=x;
   C.Imagepart=y;
}
float GetReal(Complex C)
{ //取复数C=x+yi的实部
   return C.Realpart;
}
float GetImag(Complex C)
{ //取复数C=x+yi的虚部
   return C.Imagepart;
}
Complex Add(Complex C1, Complex C2)
{ //求两个复数C1和C2的和sum
   Complex sum;
   sum.Realpart=C1.Realpart+C2.Realpart;
   sum.Imagepart=C1.Imagepart+C2.Imagepart;
   return sum;
}
Complex Sub(Complex C1, Complex C2)
{ //求两个复数C1和C2的差difference
   Complex difference;
   difference.Realpart=C1.Realpart-C2.Realpart;
   difference.Imagepart=C1.Imagepart-C2.Imagepart;
   return difference;
}
```

# 四、算法
## 1.算法的定义及特性
算法（Algorithm）是为了解决某类问题而规定的一个有限长的操作序列。一个算法必须满足以下五个重要特性。（1）有穷性。一个算法必须总是在执行有穷步后结束，且每一步都必须在有穷时间内完成。（2）确定性。对于每种情况下所应执行的操作，在算法中都有确切的规定，不会产生二义性，使算法的执行者或阅读者都能明确其含义及如何执行。（3）可行性。算法中的所有操作都可以通过已经实现的基本操作运算执行有限次来实现。（4）输入。一个算法有零个或多个输入。当用函数描述算法时，输入往往是通过形参表示的，在它们被调用时，从主调函数获得输入值。（5）输出。一个算法有一个或多个输出，它们是算法进行信息加工后得到的结果，无输出的算法没有任何意义。当用函数描述算法时，输出多用返回值或引用类型的形参表示。
## 2.评价算法优劣的基本标准
正确性。在合理的数据输入下，能够在有限的运行时间内得到正确的结果。（2）可读性。一个好的算法，首先应便于人们理解和相互交流，其次才是机器可执行性。可读性强的算法有助于人们对算法的理解，而难懂的算法易于隐藏错误，且难于调试和修改。（3）健壮性。当输入的数据非法时，好的算法能适当地做出正确反应或进行相应处理，而不会产生一些莫名其妙的输出结果。（4）高效性。高效性包括时间和空间两个方面。时间高效是指算法设计合理，执行效率高，可以用时间复杂度来度量；空间高效是指算法占用存储容量合理，可以用空间复杂度来度量。时间复杂度和空间复杂度是衡量算法的两个主要指标。
## 3.算法的时间复杂度
算法效率分析的目的是看算法实际是否可行，并在同一问题存在多个算法时，可进行时间和空间性能上的比较，以便从中挑选出较优算法。衡量算法效率的方法主要有两类：事后统计法和事前分析估算法。事后统计法需要先将算法实现，然后测算其时间和空间开销。这种方法的缺陷很显然，一是必须把算法转换成可执行的程序，二是时空开销的测算结果依赖于计算机的软硬件等环境因素，这容易掩盖算法本身的优劣。所以我们通常采用事前分析估算法，通过计算算法的渐近复杂度来衡量算法的效率。
### 1).问题规模和语句频度
不考虑计算机的软硬件等环境因素，影响算法时间代价的最主要因素是问题规模。问题规模是算法求解问题输入量的多少，是问题大小的本质表示，一般用整数n表示。问题规模n对不同的问题含义不同，例如，在排序运算中n为参加排序的记录数，在矩阵运算中n为矩阵的阶数，在多项式运算中n为多项式的项数，在集合运算中n为集合中元素的个数，在树的有关运算中n为树的结点个数，在图的有关运算中n为图的顶点数或边数。显然，n越大算法的执行时间越长
一个算法的执行时间大致上等于其所有语句执行时间的总和，而语句的执行时间则为该条语句的重复执行次数和执行一次所需时间的乘积
一条语句的重复执行次数称作**语句频度**（Frequency Count）
由于语句的执行要由源程序经编译程序翻译成目标代码，目标代码经装配再执行，因此语句执行一次实际所需的具体时间是与机器的软、硬件环境（如机器速度、编译程序质量等）密切相关的。所以，所谓的算法分析并非精确统计算法实际执行所需时间，而是针对算法中语句的执行次数做出估计，从中得到算法执行时间的信息
设每条语句执行一次所需的时间均是单位时间，则一个算法的执行时间可用该算法中所有语句频度之和来度量

```c
							两个n阶矩阵的乘积算法
for(i=1;i<=n;i++)                              //频度为n+1
   for(j=1;j<=n;j++)                     //频度为n*(n+1)
   {
       c[i][j]=0;                                    //频度为n2
       for(k=1;k<=n;k++)                    //频度为n2 * (n+1)
       c[i][j]=c[i][j]+a[i][k]*b[k][j];        //频度为n3
   }

该算法中所有语句频度之和，是矩阵阶数n的函数，用f(n)表示之。换句话说，上例算法的执行时间与f(n)成正比。
								f(n)=2n3+3n2+2n+1
```
### 2.算法的时间复杂度定义
因此，为了客观地反映一个算法的执行时间，可以只用算法中的“基本语句”的执行次数来度量算法的工作量。所谓“基本语句”指的是算法中重复执行次数和算法的执行时间成正比的语句，它对算法运行时间的贡献最大。通常，算法的执行时间是随问题规模增长而增长的，因此对算法的评价通常只需考虑其随问题规模增长的趋势。这种情况下，我们只需要考虑当问题规模充分大时，算法中基本语句的执行次数在渐近意义下的阶。如例1.4矩阵的乘积算法，当n趋向无穷大时，显然有
![image-20240718193925461](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240718193925461.png)
即当n充分大时，f(n)和n3之比是一个不等于零的常数。即f(n)和n3是同阶的，或者说f(n)和n3的数量级（Order of Magnitude）相同。在这里，我们用“O”来表示数量级，记作T(n)=O(f(n))=O(n3)。由此我们可以给出下述算法时间复杂度的定义。一般情况下，算法中基本语句重复执行的次数是问题规模n的某个函数f(n)
##### 时间复杂度：T(n)=O(f(n))
它表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称做算法的渐近时间复杂度，简称时间复杂度（Time Complexity）。
```
数学符号“O”的严格定义为：

若T(n)和f(n)是定义在正整数集合上的两个函数，则T(n)=O(f(n))表示存在正的常数C和n0，使得当n≥n0时都满足0≤T(n)≤Cf(n)。
```
该定义说明了函数T(n)和f(n)具有相同的增长趋势，并且T(n)的增长至多趋向于函数f(n)的增长。符号“O”用来描述增长率的上限，它表示当问题规模n>n0时，算法的执行时间不会超过f(n)，其直观的含义如图1.6所示。
![image-20240718194018819](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240718194018819.png)
### 3．算法的时间复杂度分析举例
分析算法时间复杂度的基本方法为：找出所有语句中语句频度最大的那条语句作为基本语句，计算基本语句的频度得到问题规模n的某个函数f(n)，取其数量级用符号“O”表示即可。具体计算数量级时，可以遵循以下定理。
**定理1.1若f(n)=amnm+am-1nm-1+…+a1n+a0是一个m次多项式，则T(n)=O(nm)**
**说明: **在计算算法时间复杂度时，可以忽略所有低次幂项和最高次幂的系数，这样可以简化算法分析，也体现出了增长率的含义。若算法可用递归方法描述，则算法的时间复杂度通常可使用递归方程表示，此时将涉及递归方程求解问题。
#### a.常量阶示例
```c
{x++;s=0;}
```
两条语句频度均为1，算法的执行时间是一个与问题规模n无关的常数，所以算法的时间复杂度为T(n)=O(1)，称为常量阶。
实际上，如果算法的执行时间不随问题规模n的增加而增长，算法中语句频度就是某个常数。即使这个常数再大，算法的时间复杂度都是O(1)。例如，上面的程序作如下改动：
```c
for(i=0;i<10000;i++){x++;s=0;}
```
##### 算法的时间复杂度仍然为O(1)
#### b.线性阶示例
```
for(i=0;i<n;i++){x++;s=0;}

循环体内两条基本语句的频度均为f(n)=n，
```
##### 算法的时间复杂度为T(n)=O(n)
#### c.平方阶示例
```
(1)  x=0;y=0;
(2)  for(k=1;k<=n;k++)
(3)     x++;
(4)  for(i=1;i<=n;i++)
(5)     for(j=1;j<=n;j++)
(6)         y++;

对循环语句只需考虑循环体中语句的执行次数，以上程序段中频度最大的语句是（6），其频度为f(n)=n2。
```
##### 算法的时间复杂度为T(n)=O(n2)
**说明：多数情况下，当有若干个循环语句时，算法的时间复杂度是由最深层循环内的基本语句的频度f(n)决定的**
#### d.立方阶示例
```c
(1)  x=1;
(2)  for(i=1;i<=n;i++)
(3)     for(j=1;j<=i;j++)
(4)         for(k=1;k<=j;k++)
(5)             x++;

显见，该程序段中频度最大的语句是（5），这条最深层循环内的基本语句的频度，依赖于各层循环变量的取值，由内向外可分析出语句（5）的执行次数为：
```

![image-20240718194804001](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240718194804001.png)
**算法的时间复杂度为T(n)=O(n3)**
#### e.对数阶示例
```c
for(i=1;i<=n;i=i*2){x++;s=0;}
设循环体内两条基本语句的频度为f(n)，则有2f(n)≤n，f(n)≤log2n，所以算法的时间复杂度为T(n)=O(log2n)，称为对数阶。常见的时间复杂度按数量级递增排列依次为：常量阶O(1)、对数阶O(log2n)、线性阶O(n)、线性对数阶O(nlog2n)、平方阶O(n2)、立方阶O(n3)、……、k次方阶O(nk)、指数阶O(2n)等。不同数量级的时间复杂度性状如图1.7所示。一般情况下，随着n的增大，T(n)的增长较慢的算法为较优的算法。显然，时间复杂度为指数阶O(2n)的算法效率极低，当n值稍大时就无法应用。应该尽可能选择使用多项式阶O(nk)的算法，而避免使用指数阶的算法。
```
![image-20240718194946938](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240718194946938.png)
### 4）.最好、最坏和平均时间复杂度
最好、最坏和平均时间复杂度对于某些问题的算法，其基本语句的频度不仅仅与问题的规模相关，还依赖于其他因素。在此仅举一例说明之。【例1.10】 在一维数组a中顺序查找某个值等于e的元素，并返回其所在位置。[插图]容易看出，此算法中语句（2）的频度不仅与问题规模n有关，还与输入实例中数组a[i]的各元素值及e的取值有关。假设在数组a[i]中必定存在值等于e的元素，则查找必定成功，且for循环内的语句的频度将随被找到的元素在数组中出现的位置不同而不同，最好情况是，每次要找的值与e相同的元素恰好就是数组中的第一个元素，则不论数组的规模多大，语句（2）的频度f(n)=1，最坏情况是，每次待查找的都是数组中最后一个元素，则语句（2）的频度f(n)=n。而对于一个算法来说，需要考虑各种可能出现的情况，以及每一种情况出现的概率，一般情况下，可假设待查找的元素在数组中所有位置上出现的可能性均相同，则可取语句（2）的频度在最好情况与最坏情况下的平均值，即f(n)=n/2，作为它的度量。此例说明，算法的时间复杂度不仅与问题的规模有关，还与问题的其他因素有关。再如某些排序的算法，其执行时间与待排序记录的初始状态有关。因此，有时会对算法有最好、最坏以及平均时间复杂度的评价。称算法在最好情况下的时间复杂度为最好时间复杂度，指的是算法计算量可能达到的最小值；称算法在最坏情况下的时间复杂度为最坏时间复杂度，指的是算法计算量可能达到的最大值；算法的平均时间复杂度是指算法在所有可能情况下，按照输入实例以等概率出现时，算法计算量的加权平均值。对算法时间复杂度的度量，人们更关心的是最坏情况下和平均情况下的时间复杂度。然而在很多情况下，算法的平均时间复杂度难于确定。因此，通常只讨论算法在最坏情况下的时间复杂度，即分析在最坏情况下，算法执行时间的上界。在本书后面内容中讨论的时间复杂度，除特别指明外，均指最坏情况下的时间复杂度。

## 5.算法的空间复杂度
### a.概念
关于算法的存储空间需求，类似于算法的时间复杂度，我们采用渐近空间复杂度（Space Complexity）作为算法所需存储空间的量度，简称空间复杂度，它也是问题规模n的函数，
##### 空间复杂度：S(n)=O(f (n))
一般情况下，一个程序在机器上执行时，除了需要寄存本身所用的指令、常数、变量和输入数据外，还需要一些对数据进行操作的辅助存储空间。其中，对于输入数据所占的具体存储量取决于问题本身，与算法无关，这样只需分析该算法在实现时所需要的辅助空间就可以了。若算法执行时所需要的辅助空间相对于输入数据量而言是个常数，则称这个算法为原地工作，辅助空间为O(1)，本节中前面的示例都是如此。有的算法需要占用临时的工作单元数与问题规模n有关，如第8章介绍的归并排序算法就属于这种情况
### b.操作
数组逆序，将一维数组a中的n个数逆序存放到原数组中
```c
for(i=0;i<n/2;i++)
{   t=a[i];
    a[i]=a[n-i-1];
    a[n-i-1]=t;
}
```

```c
for(i=0;i<n;i++)
    b[i]=a[n-i-1];
for(i=0;i<n;i++)
    a[i]=b[i];
```
**算法1**：仅需要另外借助一个变量t，与问题规模n大小无关，所以其空间复杂度为O(1)
**算法2**：需要另外借助一个大小为n的辅助数组b，所以其空间复杂度为O(n)
对于一个算法，其时间复杂度和空间复杂度往往是相互影响的，当追求一个较好的时间复杂度时，可能会导致占用较多的存储空间，即可能会使空间复杂度的性能变差，反之亦然。不过，通常情况下，鉴于运算空间较为充足，人们都以算法的时间复杂度作为算法优劣的衡量指标