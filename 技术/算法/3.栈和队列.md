# 一、栈和队列的定义和特点

## 1.栈的定义和特点
**栈**（stack）是限定仅在表尾进行插入或删除操作的线性表。因此，对栈来说，表尾端有其特殊含义，称为**栈顶**（top），相应地，表头端称为**栈底**（bottom）。不含元素的空表称为**空栈**
假设栈S=(a1, a2, …, an)，则称a1为栈底元素，an为栈顶元素。栈中元素按a1, a2, …, an的次序进栈，退栈的第一个元素应为栈顶元素。换句话说，栈的修改是按后进先出的原则进行的，如图1（a）所示。因此，栈又称为**后进先出**（Last In First Out，LIFO）的线性表，它的这个特点可用图1（b）所示的铁路调度站形象地表示
![image-20240719181547349](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240719181547349.png)
在日常生活中，还有很多类似栈的例子。例如，洗干净的盘子总是逐个往上叠放在已经洗好的盘子上面，而用时从上往下逐个取用。栈的操作特点正是上述实际应用的抽象。在程序设计中，如果需要按照保存数据时相反的顺序来使用数据，则可以利用栈来实现。
## 2.队列的定义和特点
和栈相反，**队列**（queue）是一种**先进先出**（First In First Out，FIFO）的线性表。它只允许在表的一端进行插入，而在另一端删除元素。这和日常生活中的排队是一致的，最早进入队列的元素最早离开。在队列中，允许插入的一端称为**队尾**（rear），允许删除的一端则称为**队头**（front）。假设队列为q=(a1,a2,…, an)，那么，a1就是队头元素，an则是队尾元素。队列中的元素是按照a1, a2,…, an的顺序进入的，退出队列也只能按照这个次序依次退出，也就是说，只有在a1, a2,…, an−1都离开队列之后，an才能退出队列。图2所示为队列的示意图
![image-20240719181659507](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240719181659507.png)
队列在程序设计中也经常出现。一个最典型的例子就是操作系统中的作业排队。在允许多道程序运行的计算机系统中，同时有几个作业运行。如果运行的结果都需要通过通道输出，那就要按请求输入的先后次序排队。每当通道传输完毕可以接受新的输出任务时，队头的作业先从队列中退出做输出操作。凡是申请输出的作业都从队尾进入队列。
# 二、栈的表示和操作的实现
## 1.栈的类型定义
```
ADT Stack｛
  数据对象：D={ai|ai∈ElemSet,i=1,2,…,n,n≥0}
  数据关系：R={<ai-1,ai>|ai-1,ai∈D,i=2,…,n｝
            约定an端为栈顶，a1端为栈底。
  基本操作：
    InitStack(&S) 
      操作结果：构造一个空栈S。 
    DestroyStack(&S) 
      初始条件：栈S已存在。 
      操作结果：栈S被销毁。 
    ClearStack(&S) 
      初始条件：栈S已存在。 
      操作结果：将S清为空栈。 
    StackEmpty(S) 
      初始条件：栈S已存在。 
      操作结果：若栈S为空栈，则返回true，否则返回false。 
    StackLength(S) 
      初始条件：栈S已存在。 
      操作结果：返回S的元素个数，即栈的长度。 
    GetTop(S) 
      初始条件：栈S已存在且非空。 
      操作结果：返回S的栈顶元素，不修改栈顶指针。 
    Push(&S,e) 
      初始条件：栈S已存在。 
      操作结果：插入元素e为新的栈顶元素。 
    Pop(&S,&e) 
      初始条件：栈S已存在且非空。 
      操作结果：删除S的栈顶元素，并用e返回其值。 
    StackTraverse(S) 
      初始条件：栈S已存在且非空。 
      操作结果：从栈底到栈顶依次对S的每个数据元素进行访问。 
}ADT Stack
```
## 2.顺序栈的表示和实现
**顺序栈是指利用顺序存储结构实现的栈，**即利用一组地址连续的存储单元依次存放自栈底到栈顶的数据元素，同时附设指针top指示栈顶元素在顺序栈中的位置。通常习惯的做法是：以top=0表示空栈，鉴于C语言中数组的下标约定从0开始，则当以C语言作描述语言时，如此设定会带来很大不便，因此另设指针base指示栈底元素在顺序栈中的位置。当top和base的值相等时，表示空栈。
顺序栈的定义如下：
```c
//- - - - - 顺序栈的存储结构- - - - -
#define MAXSIZE 100             //顺序栈存储空间的初始分配量
typedef struct
{
   SElemType *base;             //栈底指针
   SElemType *top;              //栈顶指针
   int stacksize;               //栈可用的最大容量
}SqStack；
```
###### 说明
```
1).base为栈底指针，初始化完成后，栈底指针base始终指向栈底的位置，若base的值为NULL，则表明栈结构不存在。top为栈顶指针，其初值指向栈底。每当插入新的栈顶元素时，指针top增1；删除栈顶元素时，指针top减1。因此，栈空时，top和base的值相等，都指向栈底；栈非空时，top始终指向栈顶元素的上一个位置
2).stacksize指示栈可使用的最大容量，后面算法的初始化操作为顺序栈动态分配MAXSIZE大小的数组空间，将stacksize置为MAXSIZE。
```
![image-20240719182003392](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240719182003392.png)
​					栈中元素和栈指针之间的关系
### 1).初始化
顺序栈的初始化操作就是为顺序栈动态分配一个预定义大小的数组空间
###### 【算法步骤】
```
1).为顺序栈动态分配一个最大容量为MAXSIZE的数组空间，使base指向这段空间的基地址，即栈底。2).栈顶指针top初始为base，表示栈为空
3).stacksize置为栈的最大容量MAXSIZE
```
###### 【算法描述】
```c
Status InitStack(SqStack &S)
{//构造一个空栈S
   S.base=new SElemType[MAXSIZE]；  //为顺序栈动态分配一个最大容量为MAXSIZE的数组空间
   if(!S.base) exit(OVERFLOW);                  //存储分配失败
   S.top=S.base;                                //top初始为base，空栈
   S.stacksize=MAXSIZE;                         //stacksize置为栈的最大容量MAXSIZE
   return OK;
}
```
### 2).入栈
入栈操作是指在栈顶插入一个新的元素
###### 【算法步骤】
```
1).判断栈是否满，若满则返回ERROR
2).将新元素压入栈顶，栈顶指针加1
```
###### 【算法描述】
```c
Status Push(SqStack &S，SElemType e)
{//插入元素e为新的栈顶元素
   if(S.top-S.base==S.stacksize) return ERROR；         //栈满
   *S.top++=e；                                         //元素e压入栈顶，栈顶指针加1
   return OK；
}
```
### 3).出栈
出栈操作是将栈顶元素删除
###### 【算法步骤】
```
1).判断栈是否空，若空则返回ERROR
2).栈顶指针减1，栈顶元素出栈
```
###### 【算法描述】
```c
Status Pop(SqStack &S,SElemType &e)
{删除S的栈顶元素，用e返回其值
   if(S.top==S.base) return ERROR;              //栈空
   e=*--S.top;                                  //栈顶指针减1，将栈顶元素赋给e
   return OK;
}
```
### 4).取栈顶元素
当栈非空时，此操作返回当前栈顶元素的值，栈顶指针保持不变
###### 【算法描述】
```c
SElemType GetTop(SqStack S)
{//返回S的栈顶元素，不修改栈顶指针
   if(S.top！=S.base)                    //栈非空
      return *(S.top-1);                //返回栈顶元素的值，栈顶指针不变
}
```
由于顺序栈和顺序表一样，受到最大空间容量的限制，虽然可以在“满员”时重新分配空间扩大容量，但工作量较大，应该尽量避免。因此在应用程序无法预先估计栈可能达到的最大容量时，还是应该使用链栈
## 3.链栈的表示和实现
链栈是指采用链式存储结构实现的栈。通常链栈用单链表来表示，如图所示。链栈的结点结构与单链表的结构相同，在此用StackNode表示，定义如下：
![image-20240719182731108](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240719182731108.png)
```c
//- - - - - 链栈的存储结构- - - - -
typedef struct StackNode
{
   ElemType    data;
   struct StackNode *next;
}StackNode,*LinkStack;
```
由于栈的主要操作是在栈顶插入和删除，显然以链表的头部作为栈顶是最方便的，而且没必要像单链表那样为了操作方便附加一个头结点
### 1).初始化
链栈的初始化操作就是构造一个空栈，因为没必要设头结点，所以直接将栈顶指针置空即可
###### 【算法描述】
```c
Status InitStack(LinkStack &S)
{//构造一个空栈S，栈顶指针置空
   S=NULL;
   return OK;
}
```
### 2).入栈
和顺序栈的入栈操作不同的是，链栈在入栈前不需要判断栈是否满，只需要为入栈元素动态分配一个结点空间
![image-20240719183537329](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240719183537329.png)
###### 【算法步骤】
```
1).为入栈元素e分配空间，用指针p指向
2).将新结点数据域置为e
3).将新结点插入栈顶
4).修改栈顶指针为p
```
###### 【算法描述】
```c
Status Push(LinkStack &S, SElemType e)
{//在栈顶插入元素e
   p=new StackNode;                             //生成新结点
   p->data=e;                                   //将新结点数据域置为e
   p->next=S;                                   //将新结点插入栈顶
   S=p;                                         //修改栈顶指针为p
   return OK;
}
```
### 3).出栈
和顺序栈一样，链栈在出栈前也需要判断栈是否为空，不同的是，链栈在出栈后需要释放出栈元素的栈顶空间
![image-20240719183704374](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240719183704374.png)
###### 【算法步骤】
```
1).判断栈是否为空，若空则返回ERROR
2).将栈顶元素赋给e
3).临时保存栈顶元素的空间，以备释放
4).修改栈顶指针，指向新的栈顶元素
5).释放原栈顶元素的空间
```
###### 【算法描述】
```c
Status Pop(LinkStack &S,SElemType &e)
{//删除S的栈顶元素，用e返回其值
   if(S==NULL) return ERROR;                            //栈空
   e=S->data;                                           //将栈顶元素赋给e
   p=S;                                                 //用p临时保存栈顶元素空间，以备释放
   S=S->next;                                           //修改栈顶指针
   delete p;                                            //释放原栈顶元素的空间
   return OK;
}
```

### 4).取栈顶元素
与顺序栈一样，当栈非空时，此操作返回当前栈顶元素的值，栈顶指针S保持不变
###### 【算法描述】
```c
SElemType GetTop(LinkStack S)
{//返回S的栈顶元素，不修改栈顶指针
   if(S！=NULL)                  //栈非空
      return S->data;           //返回栈顶元素的值，栈顶指针不变
}
```
## 4).栈与递归
栈有一个重要应用是在程序设计语言中实现递归
### 1.采用递归算法解决的问题
所谓递归是指，若在一个函数、过程或者数据结构定义的内部又直接（或间接）出现定义本身的应用，则称它们是递归的，或者是递归定义的。在以下三种情况下，常常使用递归的方法

#### a.定义是递归的

有很多数学函数是递归定义的，如大家熟悉的阶乘函数
![image-20240719184116592](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240719184116592.png)
```c
long Fact(long n)
{
   if (n==0) return 1;                          //递归终止的条件
   else return n*Fact(n-1);                     //递归步骤
}
```
如图所示为主程序调用函数Fact (4)的执行过程。在函数过程体中，else语句以参数3、2、1、0执行递归调用。最后一次递归调用的函数因参数n为0执行if语句，递归终止，逐步返回，返回时依次计算1*1、2*1、3*2、4*6，最后将计算结果24返回给主程序
![image-20240719184320141](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240719184320141.png)

计算4!时先计算3!，然后再进一步分解进行求解，这种分解-求解的策略叫做“分治法”

二阶Fibonacci数列
![image-20240719184139369](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240719184139369.png)
```c
long Fib(long n)
{
   if(n==1||n==2) return 1;                     //递归终止的条件
   else return Fib(n-1)+Fib(n-2);               //递归步骤
}
```
##### 分治法：
ps:采取“分治法”进行递归求解的问题需要满足以下三个条件
```
（1）能将一个问题转变成一个新问题，而新问题与原问题的解法相同或类同，不同的仅是处理的对象，并且这些处理对象更小且变化有规律

（2）可以通过上述转化而使问题简化

（3）必须有一个明确的递归出口，或称递归的边界。
```

“分治法”求解递归问题算法的一般形式为：
```c
void p(参数表)
{
   if(递归结束条件成立)可直接求解;                   //递归终止的条件
   else p(较小的参数);                            //递归步骤
}
```

#### b.数据结构是递归的
某些数据结构本身具有递归的特性，则它们的操作可递归地描述

例如，对于链表，其结点LNode的定义由数据域data和指针域next组成，而指针域next是一种指向LNode类型的指针，即LNode的定义中又用到了其自身，所以链表是一种递归的数据结构

对于递归的数据结构，相应算法采用递归的方法来实现特别方便。链表的创建和链表结点的遍历输出都可以采用递归的方法。算法3.9是从前向后遍历输出链表结点的递归算法，调用此递归函数前，参数p指向单链表的首元结点，在递归过程中，p不断指向后继结点，直到p为NULL时递归结束。显然，这个问题满足上述给出的采用“分治法”进行递归求解的问题需要满足的三个条件

##### 遍历输出链表中各个结点的递归算法
###### 【算法步骤】
```
1).如果p为NULL，递归结束返回
2).否则输出p->data，p指向后继结点继续递归
```
###### 【算法描述】
```c
void TraverseList(LinkList p)
{
   if(p==NULL) return;                      //递归终止
   else
   {
     cout<<p->data<<endl;                   //输出当前结点的数据域
     TraverseList(p->next);                //p指向后继结点继续递归
   }
}

简化：
void TraverseList(LinkList p)
{
   if(p)
   {
     cout<<p->data<<endl;
     TraverseList(p->next);
   }
}
```
在递归算法中，如果当递归结束条件成立，只执行return操作时，“分治法”求解递归问题算法的一般形式可以简化为：
```
 void p(参数表)
{
   if(递归结束条件不成立)
     p(较小的参数);
}
```

#### c.问题的解法是递归的
##### n阶Hanoi塔问题
###### 【问题描述】
假设有3个分别命名为A、B和C的塔座，在塔座A上插有n个直径大小各不相同，依小到大编号为1，2，…，n的圆盘（如图3.8所示）。现要求将塔座A上的n个圆盘移至塔座C上，并仍按同样顺序叠排，圆盘移动时必须遵循下列规则：

![image-20240719184957489](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240719184957489.png)
（1）每次只能移动一个圆盘
（2）圆盘可以插在A、B和C中的任一塔座上
（3）任何时刻都不能将一个较大的圆盘压在较小的圆盘之上

###### 【问题分析】

如何实现移动圆盘的操作呢？可以用分治求解的递归方法来解决这个问题。设A柱上最初的盘子总数为n，则当n=1时，只要将编号为1的圆盘从塔座A直接移至塔座C上即可；否则，执行以下三步：

（1）用C柱做过渡，将A柱上的（n-1）个盘子移到B柱上

（2）将A柱上最后一个盘子直接移到C柱上

（3）用A柱做过渡，将B柱上的（n-1）个盘子移到C柱上

具体移动过程如上图所示，图中n=4。根据这种解法，如何将n−1个圆盘从一个塔座移至另一个塔座的问题是一个和原问题具有相同特征属性的问题，只是问题的规模小1，因此可以用同样的方法求解

为了便于描述算法，将搬动操作定义为move(A,n,C)，是指将编号为n的圆盘从A移到C，同时设一个初值为0的全局变量m，对搬动进行计数：

```c
int m=0;
void move(char A,int n,char C)
{   cout<<++m<<","<<n<<","<<A<<","<<C<<endl;}
```

###### 【算法步骤】

```
1).如果n=1，则直接将编号为1的圆盘从A移到C，递归结束。
2).否则：
	递归，将A上编号为1至n-1的圆盘移到B，C做辅助塔
	直接将编号为n的圆盘从A移到C
	递归，将B上编号为1至n-1的圆盘移到C，A做辅助塔
```

###### 【算法描述】

```c
void Hanoi(int n,char A,char B,char C)
{//将塔座A上的n个圆盘按规则搬到C上，B做辅助塔
   if(n==1) move(A,1,C);                //将编号为1的圆盘从A移到C
   else
   {
     Hanoi(n-1,A,C,B);                 //将A上编号为1至n-1的圆盘移到B，C做辅助塔
     move(A,n,C)；                     //将编号为n的圆盘从A移到C
     Hanoi(n-1,B,A,C);                //将B上编号为1至n-1的圆盘移到C，A做辅助塔
   }
}
```

### 2.递归过程与递归工作栈

一个递归函数，在函数的执行过程中，需多次进行自我调用。那么，这个递归函数是如何执行的？先看任意两个函数之间进行调用的情形

与汇编语言程序设计中主程序和子程序之间的链接及信息交换相类似，在高级语言编制的程序中，调用函数和被调用函数之间的链接及信息交换需通过栈来进行

通常，当在一个函数的运行期间调用另一个函数时，在运行被调用函数之前，系统需先完成3件事：
​		（1）将所有的实参、返回地址等信息传递给被调用函数保存
		（2）为被调用函数的局部变量分配存储区
		（3）将控制转移到被调函数的入口
而从被调用函数返回调用函数之前，系统也应完成3件工作：
		（1）保存被调函数的计算结果
		（2）释放被调函数的数据区
		（3）依照被调函数保存的返回地址将控制转移到调用函数
当有多个函数构成嵌套调用时，按照“后调用先返回”的原则，上述函数之间的信息传递和控制转移必须通过“栈”来实现，即系统将整个程序运行时所需的数据空间安排在一个栈中，每当调用一个函数时，就为它在栈顶分配一个存储区，每当从一个函数退出时，就释放它的存储区，则当前正运行的函数的数据区必在栈顶

例如，在下图（c）所示的主函数main中调用了函数first，而在函数first中又调用了函数second，则下图（a）所示为当前正在执行函数second中某个语句时栈的状态，而下图（b）展示从函数second退出之后正执行函数first中某个语句时栈的状态（图中以语句标号表示返回地址）。
![image-20240719185416061](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240719185416061.png)
​							主函数main执行期间运行栈的状态

一个递归函数的运行过程类似于多个函数的嵌套调用，只是调用函数和被调用函数是同一个函数，因此，和每次调用相关的一个重要概念是递归函数运行的“层次”。假设调用该递归函数的主函数为第0层，则从主函数调用递归函数为进入第1层；从第i层递归调用本函数为进入“下一层”，即第i+1层。反之，退出第i层递归应返回至“上一层”，即第i−1层。为了保证递归函数正确执行，系统需设立一个“递归工作栈”作为整个递归函数运行期间使用的数据存储区。每一层递归所需信息构成一个工作记录，其中包括所有的实参、所有的局部变量，以及上一层的返回地址。每进入一层递归，就产生一个新的工作记录压入栈顶。每退出一层递归，就从栈顶弹出一个工作记录，则当前执行层的工作记录必是递归工作栈栈顶的工作记录，称这个记录为**“活动记录”**
下面以下图的阶乘函数Fact(4)为例，介绍递归过程中递归工作栈和活动记录的使用。主函数调用Fact(4)，当函数运行结束后，控制返回到RetLoc1，在此处n被赋为24（即4!）：
![image-20240719185449350](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240719185449350.png)
为说明方便起见，将阶乘函数算法改写为：
![image-20240719185500375](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240719185500375.png)
这里暂忽略局部变量temp的入栈和出栈情况。RetLoc2是递归调用Fact (n-1)的返回地址，当Fact(n-1)结束后，返回到RetLoc2，在此处计算n*(n-1)!，然后将结果赋给临时变量temp。主函数执行后依次启动了5个函数调用。下图所示为每次函数调用时活动记录的进栈情况。主程序外部调用Fact(4)的活动记录在栈底，Fact (1)调用Fact (0)进栈的活动记录在栈顶。
![image-20240719185521318](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240719185521318.png)
​								求解4!活动记录进栈过程
递归结束条件出现于函数Fact(0)的内部，执行Fact(0)引起了返回语句的执行。退出栈顶的活动记录，返回地址返回到上一层Fact(1)的调用递归处RetLoc2，继续执行语句temp=1*1，接着执行return temp又引起新的退栈操作。此退栈过程直至Fact(4)执行完毕后，将控制权转移给main为止，其过程如下图所示
![image-20240719185618041](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240719185618041.png)

​								求解4!活动记录退栈过程

### 3.递归算法的效率分析
#### a.时间复杂度的分析
在算法分析中，当一个算法中包含递归调用时，其时间复杂度的分析可以转化为一个递归方程求解。实际上，这个问题是数学上求解渐近阶的问题，而递归方程的形式多种多样，其求解方法也不一而足。迭代法是求解递归方程的一种常用方法，其基本步骤是迭代地展开递归方程的右端，使之成为一个非递归的和式，然后通过对和式的估计来达到对方程左端（即方程的解）的估计。
下面以阶乘的递归函数Fact(n)为例，说明通过迭代法求解递归方程来计算时间复杂度的方法。设Fact(n)的执行时间是T(n)。此递归函数中语句if(n==0) return 1;的执行时间是O(1)，递归调用Fact(n-1)的执行时间是T(n-1)，所以else return n*Fact(n-1);的执行时间是O(1)+T(n-1)。其中，设两数相乘和赋值操作的执行时间为O(1)，则对某常数C、D有如下递归方程：
![image-20240719185701147](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240719185701147.png)
设n>2，利用上式对T(n-1)展开，即在上式中用n-1代替n得到
```
T(n-1)=C+T(n-2)
```
再代入T(n)=C+T(n-1)中，有
```
T(n)=2C+T(n-2)
```
同理，当n>3时有
```
T(n)=3C+T(n-3)
```
依次类推，当n>i时有
```T(n)=iC+T(n-i)
```
最后，当i=n时有
```T(n)=nC+T(0)=nC+D
```
求得递归方程的解为：T(n)=O(n)
采用这种方法计算Fibonacci数列和Hanoi塔问题递归算法的***时间复杂度均为O(2n)**

#### b.空间复杂度的分析
递归函数在执行时，系统需设立一个“递归工作栈”存储每一层递归所需的信息，此工作栈是递归函数执行的辅助空间，因此，分析递归算法的空间复杂度需要分析工作栈的大小
对于递归算法，空间复杂度
###### S(n)=O(f (n))
其中，f(n)为“递归工作栈”中工作记录的个数与问题规模n的函数关系.
根据这种分析方法不难得到，前面讨论的阶乘问题、Fibonacci数列问题、Hanoi塔问题的递归算法的空间复杂度均为O(n)

### 4.利用栈将递归转换为非递归的方法
通过上述讨论，可以看出递归程序在执行时需要系统提供隐式栈这种数据结构来实现，对于一般的递归过程，仿照递归算法执行过程中递归工作栈的状态变化可直接写出相应的非递归算法。这种利用栈消除递归过程的步骤如下
		（1）设置一个工作栈存放递归工作记录（包括实参、返回地址及局部变量等）
		（2）进入非递归调用入口（即被调用程序开始处）将调用程序传来的实在参数和返回地址入栈（递归程序不可以作为主程序，因而可认为初始是被某个调用程序调用）。			（3）进入递归调用入口：当不满足递归结束条件时，逐层递归，将实参、返回地址及局部变量入栈，这一过程可用循环语句来实现——模拟递归分解的过程
		（4）递归结束条件满足，将到达递归出口的给定常数作为当前的函数值
		（5）返回处理：在栈不空的情况下，反复退出栈顶记录，根据记录中的返回地址进行题意规定的操作，即逐层计算当前函数值，直至栈空为止——模拟递归求值过程
通过以上步骤，可将任何递归算法改写成非递归算法。但改写后的非递归算法和原来比较起来，结构不够清晰，可读性差，有的还需要经过一系列的优化，这里不再举例详述，具体示例参见5.5.1节中二叉树中序遍历的非递归算法。
由于递归函数结构清晰，程序易读，而且其正确性容易得到证明，因此，利用允许递归调用的语言（如C语言）进行程序设计时，给用户编制程序和调试程序带来很大方便。因为对这样一类递归问题编程时，不需用户自己而由系统来管理递归工作栈

# 三、队列的表示和操作的实现

## 1).队列的类型定义

队列的操作与栈的操作类似，不同的是，删除是在表的头部（即队头）进行。

```
ADT Queue {
  数据对象：D={ai|ai∈ElemSet,i=1,2,…,n,n≥0}
  数据关系：R={<ai−1,ai>|ai−1,ai∈D,i=2,…,n}
            约定其中a1端为队列头，an端为队列尾。
  基本操作：
    InitQueue(&Q) 
      操作结果：构造一个空队列Q。 
    DestroyQueue(&Q) 
      初始条件：队列Q已存在。 
      操作结果：队列Q被销毁，不再存在。 
    ClearQueue(&Q) 
      初始条件：队列Q已存在。 
      操作结果：将Q清为空队列。 
    QueueEmpty(Q) 
      初始条件：队列Q已存在。 
      操作结果：若Q为空队列，则返回true，否则返回false。 
    QueueLength(Q) 
      初始条件：队列Q已存在。 
      操作结果：返回Q的元素个数，即队列的长度。 
    GetHead(Q) 
      初始条件：Q为非空队列。 
      操作结果：返回Q的队头元素。 
    EnQueue(&Q,e) 
      初始条件：队列Q已存在。 
      操作结果：插入元素e为Q的新的队尾元素。 
    DeQueue(&Q,&e) 
      初始条件：Q为非空队列。 
      操作结果：删除Q的队头元素，并用e返回其值。 
    QueueTraverse(Q) 
      初始条件：Q已存在且非空。 
      操作结果：从队头到队尾，依次对Q的每个数据元素访问。 
}ADT Queue
```

## 2).循环队列——队列的顺序表示和实现

队列也有两种存储表示，顺序表示和链式表示。

和顺序栈相类似，在队列的顺序存储结构中，除了用一组地址连续的存储单元依次存放从队列头到队列尾的元素之外，尚需附设两个整型变量front和rear分别指示队列头元素及队列尾元素的位置（后面分别称为头指针和尾指针）。队列的顺序存储结构表示如下：

```c
//- - - - - 队列的顺序存储结构- - - - -
#define MAXQSIZE 100            //队列可能达到的最大长度
typedef struct
{
   QElemType *base;             //存储空间的基地址
   int front;                   //头指针
   int rear;                    //尾指针
}SqQueue;
```

为了在C语言中描述方便起见，在此约定：初始化创建空队列时，令front=rear=0，每当插入新的队列尾元素时，尾指针rear增1；每当删除队列头元素时，头指针front增1。因此，在非空队列中，头指针始终指向队列头元素，而尾指针始终指向队列尾元素的下一个位置

![image-20240719190657630](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240719190657630.png)

​					 顺序分配的队列中头、尾指针和元素之间的关系

假设当前队列分配的最大空间为6，则当队列处于图3.12（d）所示的状态时不可再继续插入新的队尾元素，否则会出现溢出现象，即因数组越界而导致程序的非法操作错误。事实上，此时队列的实际可用空间并未占满，所以这种现象称为“假溢出”。这是由“队尾入队，队头出队”这种受限制的操作造成的。

怎样解决这种“假溢出”问题呢？一个较巧妙的办法是将顺序队列变为一个环状的空间，如图所示，称之为**循环队列**

![image-20240719190740683](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240719190740683.png)

头、尾指针以及队列元素之间的关系不变，只是在循环队列中，头、尾指针“依环状增1”的操作可用“模”运算来实现。通过取模，头指针和尾指针就可以在顺序表空间内以头尾衔接的方式“循环”移动

在图（a）中，队头元素是J5，在元素J6入队之前，在Q.rear的值为5，当元素J6入队之后，通过“模”运算，Q.rear=(Q.rear+1)%6，得到Q.rear的值为0，而不会出现图（d）的“假溢出”状态。

![image-20240719190823901](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240719190823901.png)

​						循环队列中头、尾指针和元素之间的关系

在图（b）中，J7、J8、J9、J10相继入队，则队列空间均被占满，此时头、尾指针相同。在图（c）中，若J5和J6相继从图（a）所示的队列中出队，使队列此时呈“空”的状态，头、尾指针的值也是相同的。

由此可见，对于循环队列不能以头、尾指针的值是否相同来判别队列空间是“满”还是“空”。在这种情况下，如何区别队满还是队空呢？

通常有以下两种处理方法:
```
（1）少用一个元素空间，即队列空间大小为m时，有m-1个元素就认为是队满。这样判断队空的条件不变，即当头、尾指针的值相同时，则认为队空；而当尾指针在循环意义上加1后是等于头指针，则认为队满。因此，在循环队列中队空和队满的条件是：
		队空的条件：Q.front==Q.rear
		队满的条件：(Q.rear+1)%MAXQSIZE==Q.front
如图（d）所示，当J7、J8、J9进入图（a）所示的队列后，(Q.rear+1)%MAXQSIZE的值等于Q.front，此时认为队满
（2）另设一个标志位以区别队列是“空”还是“满”
```

### 1).初始化
循环队列的初始化操作就是动态分配一个预定义大小为MAXQSIZE的数组空间
###### 【算法步骤】
```
1).为队列分配一个最大容量为MAXQSIZE的数组空间，base指向数组空间的首地址
2).头指针和尾指针置为零，表示队列为空
```
###### 【算法描述】
```c
Status InitQueue(SqQueue &Q)
{//构造一个空队列Q
   Q.base=new QElemType[MAXQSIZE];              //为队列分配一个最大容量为MAXQSIZE的数组空间
   if(!Q.base) exit(OVERFLOW);                  //存储分配失败
   Q.front=Q.rear=0;                            //头指针和尾指针置为零，队列为空
   return OK;
}
```

### 2).求队列长度
对于非循环队列，尾指针和头指针的差值便是队列长度，而对于循环队列，差值可能为负数，所以需要将差值加上MAXQSIZE，然后与MAXQSIZE求余
###### 【算法描述】
```c
int QueueLength(SqQueue Q)
{//返回Q的元素个数，即队列的长度
   return(Q.rear-Q.front+MAXQSIZE)%MAXQSIZE;
}
```

### 3).入队
入队操作是指在队尾插入一个新的元素
###### 【算法步骤】
```
1).判断队列是否满，若满则返回ERROR
2).将新元素插入队尾
3).队尾指针加1
```
###### 【算法描述】
```c
Status EnQueue(SqQueue &Q,QElemType e)
{//插入元素e为Q的新的队尾元素
   if((Q.rear+1)%MAXQSIZE==Q.front)             //尾指针在循环意义上加1后等于头指针，表明队满
     return ERROR;
   Q.base[Q.rear]=e;                           //新元素插入队尾
   Q.rear=(Q.rear+1)%MAXQSIZE;                 //队尾指针加1
   return OK；
}
```
### 4).出队
出队操作是将队头元素删除
###### 【算法步骤】
```
1).判断队列是否为空，若空则返回ERROR
2).保存队头元素
3).队头指针加1
```
###### 【算法描述】
```c
Status DeQueue(SqQueue &Q,QElemType &e)
{//删除Q的队头元素，用e返回其值
   if(Q.front==Q.rear) return ERROR;            //队空
   e=Q.base[Q.front];                           //保存队头元素
   Q.front=(Q.front+1)%MAXQSIZE;                //队头指针加1
   return OK;
}
```
### 5).取队头元素
当队列非空时，此操作返回当前队头元素的值，队头指针保持不变
###### 【算法描述】
```
SElemType GetHead(SqQueue Q)
{//返回Q的队头元素，不修改队头指针
   if(Q.front!=Q.rear)                   //队列非空
     return Q.base[Q.front];             //返回队头元素的值，队头指针不变
}
```
由上述分析可见，如果用户的应用程序中设有循环队列，则必须为它设定一个最大队列长度；若用户无法预估所用队列的最大长度，则宜采用链队

## 3).链队——队列的链式表示和实现
链队是指采用链式存储结构实现的队列。通常链队用单链表来表示，如图所示
![image-20240719192552504](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240719192552504.png)
一个链队显然需要两个分别指示队头和队尾的指针（分别称为头指针和尾指针)才能唯一确定。这里和线性表的单链表一样，为了操作方便起见，给链队添加一个头结点，并令头指针始终指向头结点。队列的链式存储结构表示如下：

```c
//- - - - - 队列的链式存储结构- - - - -
typedef struct QNode
{
   QElemType data;
   struct QNode *next;
}QNode, *QueuePtr;
typedef struct
{
   QueuePtr  front;                             //队头指针
   QueuePtr  rear;                              //队尾指针
}LinkQueue;
```

### 1).初始化

链队的初始化操作就是构造一个只有一个头结点的空队,如图（a）所示

![image-20240719192658449](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240719192658449.png)

​								队列运算指针变化状况

###### 【算法步骤】
```
1).生成新结点作为头结点，队头和队尾指针指向此结点
2).头结点的指针域置空
```
###### 【算法描述】
```c
Status InitQueue(LinkQueue &Q)
{//构造一个空队列Q
   Q.front=Q.rear=new QNode;            //生成新结点作为头结点，队头和队尾指针指向此结点
   Q.front->next=NULL;                  //头结点的指针域置空
   return OK;
}
```
### 2).入队
和循环队列的入队操作不同的是，链队在入队前不需要判断队是否满，需要为入队元素动态分配一个结点空间，如图（b）和（c）所示。
###### 【算法步骤】
```c
Status EnQueue(LinkQueue &Q,QElemType e)
{//插入元素e为Q的新的队尾元素
   p=new QNode;                                 //为入队元素分配结点空间，用指针p指向
   p->data=e;                                   //将新结点数据域置为e
   p->next=NULL; Q.rear->next=p;                //将新结点插入到队尾
   Q.rear=p;                                    //修改队尾指针
   return OK;
}
```
### 3).出队
和循环队列一样，链队在出队前也需要判断队列是否为空，不同的是，链队在出队后需要释放出队头元素的所占空间，如图（d）所示
###### 【算法步骤】
```
1).判断队列是否为空，若空则返回ERROR
2).临时保存队头元素的空间，以备释放
3).修改头结点的指针域，指向下一个结点
4).判断出队元素是否为最后一个元素，若是，则将队尾指针重新赋值，指向头结点
5).释放原队头元素的空间
```
###### 【算法描述】
```c
Status DeQueue(LinkQueue &Q,QElemType &e)
{//删除Q的队头元素，用e返回其值
   if(Q.front==Q.rear) return ERROR;               //若队列空，则返回ERROR
   p=Q.front->next;                                //p指向队头元素
   e=p->data;                                      //e保存队头元素的值
   Q.front->next=p->next;                          //修改头结点的指针域
   if(Q.rear==p) Q.rear=Q.front;                  //最后一个元素被删，队尾指针指向头结点
   delete p;                                      //释放原队头元素的空间
   return OK;
}
```
需要注意的是，在链队出队操作时还要考虑当队列中最后一个元素被删后，队列尾指针也丢失了，因此需对队尾指针重新赋值（指向头结点）。
### 4).取队头元素
与循环队列一样，当队列非空时，此操作返回当前队头元素的值，队头指针保持不变
###### 【算法描述】
```c
SElemType GetHead(LinkQueue Q)
{//返回Q的队头元素，不修改队头指针
   if(Q.front!=Q.rear)                                   //队列非空
     return Q.front->next->data;        //返回队头元素的值，队头指针不变
}
```

![image-20240719195123697](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/image-20240719195123697.png)
