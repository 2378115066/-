# 一、 数组

## 1.一维数组

### 定义

```
类型说明符 数组名[常量表达式];
```

说明：

```
数组名的书写应符合标识符命名规则；

数组的类型指数组元素的取值类型。同一个数组，其所有元素数据类型都是相同的；

数组名不能与其它变量名相同；
```

### 初始化

```
类型说明符 数组名[常量表达式]={值，值……值}；

先定义数组，再用赋值语句或输入语句给数组中的元素赋值
定义数组的同时为数组元素设置初始值（数组初始化赋值）
```

```
部分赋值
逐个赋值
全部赋值
```

### 引用

```
数组名[下标表达式];

“下标表达式”可以是整型常量或整型表达式，也可以使用变量，表达式的值一般为任何非负整型数据，取值范围是0~（元素个数-1）;不可越界
```

数组元素是组成数组的基本单元，也是一种变量，称为下标变量，使用规则等同于相同类型的普通变量，可以读取其值参与表达式运算、对其赋值、以及其他运算。

## 2. 二维数组

### 定义

```
类型说明符  数组名[整型常量表达式1] [整型常量表达式2]；
```

说明

```
二维数组中的每个数组元素都有两个下标，且必须分别放在单独的“[]”内。

二维数组定义中的第1个下标表示该数组具有的行数，第2个下标表示该数组具有的列数，两个下标之积是该数组元素的总个数。

二维数组中的每个数组元素的数据类型均相同。二维数组中各个元素的存放规律是“按行排列”。

二维数组可以看作是数组元素为一维数组的数组。例如：上例中的数组array [2][3]，可以看作是由三个一维数组array [0]、array [1]组成的。
```

### 初始化

```
类型说明符 数组名[常量表达式x] [常量表达式y]={值，值……值}；

先定义数组，再用赋值语句或输入语句给数组中的元素赋值
定义数组的同时为数组元素设置初始值（数组初始化赋值）
```

```
部分赋值
逐个赋值
全部赋值
```

### 引用

```
数组名[下标1] [下标2]；

引用二维数组元素时，下标表达式1和下标表达式2一定要分别放在两个方括号
不可越界
```

## 3.**字符数组**

### 定义

```
char 数组名[常量表达式];
```

### 初始化

```
char 数组名[常量表达式]={值，值……值}；

先定义数组，再用赋值语句或输入语句给数组中的元素赋值
定义数组的同时为数组元素设置初始值（数组初始化赋值）
```

```
字符常量的形式
字符串的形式
全部赋值
```

一般以字符常量的形式对字符数组的各个元素赋初值，系统不会自动在最后一个字符后加结束标志’\0’。如果要加结束标志，必须明确指定 。

如果是对部分元素赋初值，对未赋值的元素由系统自动赋予空字符’\0’值，相当于有字符结束标志。 

以字符串常量形式对字符数组初始化，系统会自动在该字符串的最后加入字符串结束标志’\0’， 它的ASCII码为0。

### 字符串和字符串结束标志

```
字符串是用双引号括起来的若干有效的字符序列，可以包含字母、数字、符号、转义符。

字符数组是存放字符型数据的数组，其中的元素可以是字符串，也可以是字符序列。

C语言没有提供字符串变量，对字符串的处理常常采用字符数组来实现，多字符串处理库函数既可以使用字符串，也可以使用字符数组。
```

字符串和字符数组的区别在于

**字符串是存放在字符数组中的，字符串和字符数组的长度可以不一样；字符串以'\0'作为结束标志，而字符数组并不要求它的最后一个字符一定为'\0'。**

### 字符数组的输入输出

#### 逐个字符输入/输出

```
通常采用循环语句来实现，不同之处在于格式说明符为“%c”。

使用说明：
	格式化输入是缓冲读。必须在接受到“回车”时，scanf才开始读取数据。
	读字符数据时，空格、回车都保存进字符数组。
	如果按“回车”键时，输入的字符少于scanf循环读取的字符时，scanf继续等待用户将剩下的字符输入；如果“回车”键时，输入的字符多于scanf循环读取的字符时，scanf循环只读入前面的字符。
	逐个读入字符结束后，不会自动在末尾加’\0’。所以输出时，最好也使用逐个字符输出
```

#### 整个字符串输入/输出

```
可采用“%s”格式符来实现

使用说明：
	格式化输入输出字符串，参数要求字符数组的首地址，即字符数组名。
	输入的字符串中不能有空格（空格，Tab），否则空格后面的字符不能读入，scanf函数认为输入的是两个字符串。如果要输入含有空格的字符串可以使用gets()函数。
	按照%s格式格式化输入字符串时，并不检查字符数组的空间是否够用。如果输入长字符串，可能导致数组越界，应当保证字符数组分配了足够的空间。
	按照%s格式格式化输入字符串时，自动在最后加“字符串结束标志”。
	按照%s格式格式化输入字符串时，可以用“%c”或“%s”格式逐个输出。
	对于不是按照“%s”格式化输入的字符串在输出时，应该确保末尾有“字符串结束标志”。

```

### 常用字符串处理函数

​										1.字符串输入/输出函数(<stdio.h>)

```
							字符串输入gets(str);
功能：
从键盘输入一个字符串（可包含空格），直到遇到回车符，并将字符串存放到由str指定的字符数组（或内存区域）中。

参数：
str是存放字符串的字符数组（或内存区域）的首地址。函数调用完成后，输入的字符串存放在str开始的内存空间中。
```

```
							字符串输出puts(str);
功能：从str指定的地址开始，依次将存储单元中的字符输出到显示器，直到遇到“字符串”结束标志。
```

**注意：puts将字符串最后的’\0’转化为’\n’并输出。**



​										2.字符串处理函数(<string.h>))

```
							求字符串的长度strlen(str)
功能：统计str为起始地址的字符串的长度（不包括“字符串结束标志”），并将其作为函数值返回。
```

```
							字符串连接函数strcat(str1,str2)
功能：将str2首地址的字符串连接到str1字符串的后面。从str1原来的’\0’（字符串结束标志）处开始连接。 

str1-一般为字符数组，要有足够的空间，以确保连接字符串后不越界；
str2-可以是字符数组名，字符串常量或指向字符串的字符指针（地址）。
```

```
							字符串复制函数strcpy(str1,str2)
功能：将str2为首地址的字符串复制到str1为首地址的字符数组中。

注意事项：
str1-一般为字符数组，要有足够的空间，以确保复制字符串后不越界；
str2-可以是字符数组名，字符串常量或指向字符串的字符指针（地址）。
字符串（字符数组）之间不能赋值，但是通过此函数，可以间接达到赋值的效果。
```

```
							字符串比较函数strcmp(str1,str2)
功能：将str1,str2为首地址的两个字符串进行比较，比较的结果由返回值表示。

当str1=str2，函数的返回值为：0；
当str1<str2，函数的返回值为：负整数；（绝对值是ASCII码的差值）
当str1>str2，函数的返回值为：正整数；（绝对值是ASCII码的差值）

字符串之间的比较规则：从第一个字符开始，对两个字符串对应位置的字符按ASCII码的大小进行比较，直到出现第一个不同的字符。
字符串（字符数组）之间不能直接比较，但是通过此函数，可以间接达到比较的效果。
```

# 二、 函数

## 1.函数概述

### 	模块化程序设计

函数的本质是一段可以实现特定功能且被重复使用的代码，它单独编写并封装为模块，使用时直接调用即可。

函数机制有以下优点：

（1）降低代码规模，使程序更加简短清晰；

（2）提高代码的重复性；

（3）有利于程序维护；

（4）提高程序开发的效率。

**注意：**

1）一个源程序文件可由一个或多个函数组成。一个源程序文件是一个编译单位，即以源程序文件为单位进行编译，而不是以函数为单位进行编译。

2）一个C语言程序可由一个或多个源程序文件组成。一个源程序文件可以被多个C语言程序公用。

3）一个C语言程序有且只能有一个主函数main( )，程序从main函数开始执行，调用其他函数后，最终仍需回到main函数结束整个程序的运行。main函数是系统定义的。

4）所有函数在定义时都是相互独立的，一个函数不可从属于另一个函数，即函数不能嵌套定义，但可以相互调用。main函数不能被调用。

5）函数被调用后，通过return语句返回函数值，若无return语句则执行被调用函数但不返回函数值。若函数类型为void，则函数无返回值。

### 	函数的分类

#### 1).从函数定义的角度

```
								（1）库函数
由Ｃ系统提供，用户无须定义，也不必在程序中作类型说明，只需在程序前包含有该函数原型的头文件即可在程序中直接调用。例如在前面各章的例题中反复用到的printf，scanf，getchar，putchar，gets，puts，sqrt等函数均属于此类型。

在程序中调用某个库函数时，需要用预处理命令#include将该函数所在的头文件包含到程序中，以便编译系统找到该函数的目标代码，生成可执行文件。例如：要使用数学函数，需要用#include<math.h>将数学头文件包含到程序中，要使用字符串处理函数，则需要用#include<string.h>将字符串处理头文件包含到程序中。

								（2）用户定义函数
由用户按需要编写的函数。对于用户自定义函数，不仅要在程序中定义函数本身， 而且在主调函数模块中还必须对该被调函数进行类型说明，然后才能使用。
```

#### 2).从功能上区分

```
								（1）有返回值函数
此类函数被调用执行完后将向调用者返回一个执行结果，称为函数返回值。由用户定义的这种要返回函数值的函数，必须在函数定义和函数说明中明确返回值的类型。

								（2）无返回值函数
此类函数用于完成某项特定的处理任务，执行完成后不向调用者返回函数值。这类函数类似于其它语言的过程。由于函数无须返回值，用户在定义此类函数时可指定它的返回为“空类型”，空类型的说明符为“void”。
```

#### 3). 从数据传递角度

```
								（1）无参函数
无参函数在函数定义、函数说明及函数调用中均不带参数。主调函数和被调函数之间不进行参数传送。此类函数通常用来完成一组指定的功能，可以返回或不返回函数值。

								（2）有参函数
有参函数也称为带参函数。在函数定义及函数说明时都有参数，称为形式参数(简称为形参)。在函数调用时也必须给出参数，称为实际参数(简称为实参)。进行函数调用时，主调函数将把实参的值传送给形参，供被调函数使用。
```

## 2.函数定义与调用

### 定义

​									**无参函数定义**

```
类型标识符  函数名 ( )
{
    声明部分
    语句
}

说明：
1）函数定义格式中的第一行称为函数首部，又称为函数原型。
2）类型标识符指明了本函数的类型，函数的类型实际上是函数返回值的类型。
3）函数名是由用户定义的标识符，函数名后有一对空括号( )，其中无参数，但是括号是不能省略的。
4）函数首部下面花括号{ }中的内容称为函数体。
```

​									**无返回值函数定义**

```
void  display( )
{   
    printf("C programming.\n"); 
}

注意：
此处的void是C语言中的一个关键字，表示“空类型”或“无类型”。
上例中的display函数是一个无参函数，当被其他函数调用时，其功能为输出字符串“C programming.”。
```

​									**有参函数定义**

```
类型标识符  函数名 (类型名 形式参数1, 类型名 形式参数2, … )
{
    声明部分
    语句
}
```

​									**空函数定义**

```
函数名( ) {  }

说明：
1）函数定义的各个部分都可以缺省。没有任何内容的函数称为空函数，空函数什么也不做，什么也不返回。
2）无参函数或空函数，函数名后面的圆括号不能省略。
3）在程序开发期间，空函数可以用做占位符，后期程序功能扩充时再填入所需功能。空函数的有效使用，有利于对于较大程序编写、调试和功能扩充。
```

##### 总结

```
1）C语言规定，不能在一个函数的内部再定义其它函数，即函数不能嵌套定义。
2）函数首部中的圆括号后不要加分号。
3）在有参函数定义中，每个形式参数应分别进行类型的定义，即上面的有参函数定义的第一行不能写成：
	int max(int x, y)   /* 错误原因：省略了形式参数y之前的类型说明int  */
```

### 函数的参数及参数传递

函数参数的作用：在主调函数和被调用函数之间传递数据。

在定义函数时，函数名后面括号中的变量名称为“形式参数”（简称“**形参**”）；

在调用函数时，函数名后面括号中的表达式称为“实际参数”（简称“**实参**”）。

C语言规定，实参变量对形参变量的数据传递是“**值传递**”，即**单向传递**，即只能把实参的值传递给形参，而不能把形参的值反向地传递给实参。

实际上，实参变量所占用的存储单元与形参变量所占用的存储单元是不同的存储单元。因此，在函数调用过程中，形参变量的值如果发生改变，并不会改变主调函数中实参变量的值。

说明

```
1．形参只有在函数内部有效，函数调用结束后则不能再使用形参变量。
	
2．在进行函数定义时，必须指定形参的类型。

3．实参可以是常量、变量、表达式或函数。例如：
    total = sum(10, 98);  //将常量作为实参
    total = sum(a+10, b-3);  //将表达式作为实参
    total = sum( pow(2,2), abs(-100) );  //将函数返回值作为实参

4．实参和形参在数量上，顺序上必须一致。而实参和形参在类型上应保持一致或兼容，否则会发生“类型不匹配”的语法错误。
如果能够进行自动类型转换，或者进行了强制类型转换，那么实参类型也可以不同于形参类型，例如将int类型的实参传递给float类型的形参就会发生自动类型转换。

5．形参和实参虽然可以同名，但它们之间是相互独立的，互不影响。因为实参在函数外部有效，而形参在函数内部有效。
```

### 函数的返回值

函数的返回值是指函数被调用之后，执行函数体中的语句所得到的结果，这个结果通过return语句返回给主调函数。

```
（1）函数的值只能通过return语句返回到主调函数。
return语句的一般形式为：
          return  表达式 ;
或者： return  (表达式 ) ;

return语句的功能是中止函数的执行，并计算表达式的值，将其返回到主调函数。
在函数中允许有多个return语句，可以出现在函数体的任意位置，但每次调用只能有一个return 语句被执行，因此只能返回一个函数值。
函数一旦遇到return语句就立即返回，即return后面的所有语句都不会被执行到。因此，return语句有强制结束函数执行的作用。
```

注意：如果一个有返回值的函数中无return语句，那么，此函数并不是不返回值，而是返回一个不确定的值。

```
（2）函数返回值的类型和函数定义中函数的类型应保持一致。如果两者不一致，则以函数类型为准，自动进行类型转换。
```

```
（3）C语言规定，凡不加类型说明的函数，一律按整型（int型）处理。也就是说，若一个函数的返回值为整型，可以省去函数的类型说明。
```

```
（4）不返回函数值的函数，可以明确定义为“无类型”（或称为“空类型”），类型说明符为“void”。例如：
void display()
{
  printf("C Programming.\n");
}

一旦函数被定义为空类型后，就不能在主调函数中接收被调函数的函数值了。例如，下面语句是错误的：
    int a = func();
为了减少程序出错，保证程序正确调用，凡不要求有返回值的函数，一般应将函数的类型定义为“void”类型。
```

## 3.函数调用与参数传递

```
函数名([实际参数列表]);
```

其中，在实参列表中，实参的个数与顺序必须和形参的个数与顺序相同，实参的数据类型必须和对应的形参数据类型相同或兼容。实参是有确定值的变量或表达式，各实参之间需要用逗号作为间隔。

```
函数名( );
```

在C程序当中，所有的函数定义，包括主函数main在内都是平行的。在一个函数的函数体内，不能再定义另一个函数，**即不能嵌套定义**。但是，函数之间允许相互调用，也允许嵌套调用。习惯上把调用者称为主调函数，被调用者称为被调函数。

### 函数的调用

#### 1. 函数语句

当函数调用不要求有返回值时，可由函数调用加上分号来实现，即该函数调用作为一个独立的语句使用。例如：

```c
printf ( "%d" , a ) ;
scanf ( "%d" , &b ) ;
```

#### 2．函数表达式

函数调用作为表达式中的一个运算对象出现在表达式中。以函数返回值来参与表达式的运算，因此要求函数必须是有返回值的。例如：

```c
y = sqrt ( x ) ;
r = max ( a , b ) + max ( c , d ) ;
```

这两个表达式中都包含了函数调用，每个函数调用都是表达式的一个运算对象。因此，要求函数应带回一个确定的值参加表达式的运算。

#### 3．函数参数

函数作为调用另一个函数时的实际参数。这种情况是把该函数的返回值作为实参进行传递，因此要求该函数必须是有返回值的。例如：

```c
printf ( "%d" , max ( x , y ) ) ;
x = max ( max ( a , b ) , max ( c , d ) ) ;
printf ( "%d" , max ( max ( a , b ) , max ( c , d ) ) ;
```

### 函数声明与函数原型

C语言代码由上到下依次执行，原则上函数定义要出现在函数调用之前，否则就会报错。但在实际开发中，经常会在函数定义之前使用它们，这个时候就需要提前声明。

所谓声明（Declaration），即向编译系统声明将要调用此函数，并将此函数的有关信息（即被调用函数的函数类型、参数的个数、类型和顺序等）通知编译系统。

在一个函数中要调用另一个函数时，需要具备以下条件：

```
1．被调用的函数必须是已经存在的函数（库函数或用户自己定义的函数）。
2．如果调用的是库函数，一般应该在本源程序文件的开始用预处理命令#include将此库函数所需用到的有关信息包含到本文件来。例如：
			#include  <stdio.h>
其中“stdio.h”是一个头文件。在stdio.h文件中存放了有关输入输出库函数的相关信息。
3．如果调用的是用户自己定义的函数，而且该函数与主调函数在同一个文件中，一般应该在主调函数中对被调用函数进行函数声明。
```

函数声明的格式与函数首部类似，最后加一个分号。函数声明中的形参列表里，可以只写形参类型，而参数名可以写，也可以不写。

```
函数声明的一般形式为：
类型标识符    函数名（ 形参类型1  形参名1 , 形参类型2  形参名2 , … ）;
或者为：
类型标识符    函数名（ 形参类型1 , 形参类型2 , … ）;
```

函数声明给出了函数类型（返回值类型）、函数名、形参列表（重点是参数类型）等与该函数有关的信息，称为**函数原型**。

函数原型的作用是告诉编译器与该函数有关的信息，让编译器知道函数的存在，以及存在的形式，即使函数暂时没有定义，编译器也知道该如何使用它。

**注意：**

①   函数定义是指对函数功能的确立，包括指定函数名、函数的类型、形参及其类型、函数体等，它是一个完整的、独立的函数单位。

②  函数声明是对已定义的函数进行声明，它只包括函数名、函数的类型、以及形参类型，不包括函数体。对被调用函数进行声明的作用就是要告诉编译系统被调用函数的有关信息，以便于编译系统进行语法检查。

**说明：**

**正常情况下的函数调用，都应该对所调用的函数进行函数声明。**

Ｃ语言中又规定在以下几种情况**可以省去主调函数中对被调函数的函数声明**：

（1）当被调函数的函数定义出现在主调函数定义之前时，在主调函数中可以不对被调函数进行函数声明而直接调用；

（2）如果已在所有函数定义之前，在文件的开始处，在函数的外部（例如源程序文件开始处）已预先进行了函数声明，则在各个主调函数中不必对所调用的函数再作声明；

（3）对库函数的调用不需要进行函数声明，但必须把该函数对应的头文件（.h）用预处理命令#include包含在源程序文件的前部。

## 4.数组作为函数参数

数组可以作为函数的参数使用，进行数据传递。

数组用作函数参数有两种形式，

```
用数组元素作为实参
用数组名作为函数的形参和实参
```

用数组元素作实参时，只要数组类型和函数的形参类型一致即可，并不要求函数的形参也是下标变量。换句话说，对数组元素的处理是按普通变量对待的。

在普通变量或下标变量作函数参数时，形参变量和实参变量是由编译系统分配的两个不同的内存单元。在函数调用时发生的值传送，是把实参变量的值赋予形参变量。

**注意：**

实际上形参数组并不存在自己所谓独自的空间，形参数组和实参数组为同一数组，共同拥有一段内存空间。所以它们之间的数据传递是双向的。

用数组名作函数参数时，则要求形参和相对应的实参都必须是类型相同的数组，都必须有明确的数组说明。当形参和实参二者不一致时，即会发生错误。

## 5.  变量的作用域及其存储类型

变量在程序里的有效范围称变量的作用域。

在讨论函数的形参变量时曾经提到，形参变量只在函数被调用的时候才分配内存单元，函数调用结束后立即释放形参变量所占用的内存单元。这一点表明形参变量只有在函数内才是有效的，离开该函数就不能再使用了。这种变量的有效性范围称为变量的作用域。

不仅对于形参变量，Ｃ语言中所有的变量都有自己的作用域。变量说明的方式不同，其作用域也不同。Ｃ语言中的变量，按作用域范围可分为两种，即局部变量和全局变量。

变量的存储方式可分为“静态存储”和“动态存储”两种。

### 局部变量

局部变量是指在程序块（或函数）内部定义的变量，只能被定义它的函数或程序块访问，因此也称为内部变量。这种变量一经定义，系统就为其分配相应的内存空间，在本程序块（或函数）执行结束时，系统就会收回其占用的空间。

在C程序中，出现在以下各位置定义的变量均属于局部变量：

```
1)在函数体内定义的变量，在本函数范围内有效，作用域局限于函数体内。

2)在复合语句内定义的变量，在本复合语句范围内有效，作用域局限于复合语句内。

3)有参函数的形式参数也是局部变量，只在其所在的函数范围内有效。
```

**说明**

```
1．main函数中定义的变量也只有在main函数中有效，而不因为是在main函数中定义的变量，就可以在整个文件或程序中都有效。main函数也不能使用其它函数中定义的变量。因为main函数也是一个函数，main函数与其它函数是平行关系。这一点是与其它语言不同的，应予以注意。
2．允许在不同的函数中使用相同的变量名而互不干扰，也不会发生混淆，因为它们代表不同的对象，分配不同的内存单元。
3．形参变量是被调函数的局部变量，实参变量是主调函数的局部变量。
4．在一个函数内部，可以在复合语句中定义变量，这些变量只在复合语句中有效，这种复合语句也可称为“分程序”或“程序块”。
```

### 全局变量

程序的编译单位是源程序文件，一个源程序文件可以包含一个或若干个函数。在函数内定义的变量是局部变量，而在函数外部定义的变量称为外部变量。以此类推，在函数外部定义的数组就称为外部数组。

外部变量不属于任何一个函数，其作用域是：从外部变量的定义位置开始，到本文件结束为止。外部变量可被作用域内的所有函数直接引用，所以外部变量又称全局变量。

实际上，要限制使用全局变量，建议不在必要时不要使用全局变量。这是因为使用全局变量也会带来很多缺点：

```
1）全局变量的使用，使函数的移植性、通用性、可读性降低。模块化程序设计的原则要求把C程序中的函数看作成一个封闭的整体，除了可以通过实参与形参之间传递数据的渠道以外，没有其它渠道可以函数与外界发生联系。全局变量不符合这个原则。

2）使用全局变量过多，会降低程序的清晰性，人们往往难以清楚地判断出每个瞬间各个外部变量的值。在各个函数执行时都可能改变外部变量的值，因而容易产生错误。

3）全局变量长时间占用存储单元。全局变量在程序的整个执行过程中都占用存储单元，而不是仅在需要时才分配存储单元。
```

如果外部变量在源程序文件开始处定义，则在整个源程序文件范围内都可以使用该外部变量，如果不在源程序文件开始处定义，按上面的规定，外部变量的作用范围只限于外部变量定义点到文件终了。

如果在外部变量定义点之前的函数想要引用该外部变量，则应该在该函数中用关键字extern作“外部变量说明”。表示该变量在函数的外部定义，这样就可以在函数内部可以使用它了。一般的做法是外部变量的定义放在引用它的所有函数之前，这样就避免了在这些函数中对外部变量进行**extern**说明。

外部变量定义和外部变量说明是不同的

```
1）位置和出现的次数不同。外部变量的定义只能有一次，它的位置在所有函数之外，而同一源程序文件中的外部变量的说明可以有多次，它的位置在函数之内，即在使用外部变量的函数中对该外部变量进行说明。

2）所起的作用不同。系统根据外部变量的定义（而不根据外部变量的说明）分配存储单元。对外部变量的初始化只能在外部变量“定义”的时候进行，而不能在外部变量“说明”的时候进行。所谓外部变量“说明”，其作用是声明该变量是一个已在外部定义过的变量，仅仅是为了引用该变量而作的“声明”。
```

原则上，所有函数都应当对所用的外部变量用extern进行说明，只是为简化起见，允许在外部变量的定义点之后的函数可以省略这个“说明”。

**在定义全局变量时如果使用修饰词static**，表示此全局变量作用域仅限于本源文件（模块）内部。

局部变量对全局变量具有屏蔽作用。如果在同一个源程序文件中，外部变量与局部变量同名，则在局部变量的作用范围内，外部变量不起作用。作用域范围发生重叠时，作用域范围小的变量起作用，而屏蔽作用域范围大的变量。

### 变量的存储类型

变量的存储方式可分为“静态存储”和“动态存储”两种。

​								静态存储变量:

存放于静态存储区,在程序整个运行过程中,始终占据固定的内存单元。全局变量就属于此类存储方式。

​								动态存储变量: 

存放于动态存储区,根据程序的运行状态(如：函数调用)而临时分配的单元，且单元并不固定。

典型的例子就是函数的形式参数，在程序开始执行时并不给形参变量分配存储单元，只有在函数被调用时，才为形参变量分配存储单元，而当函数调用结束后立即释放形参所占用的存储单元。如果一个函数被多次调用，则反复地为其形参变量分配、释放存储单元。

从以上分析可知，静态存储方式的变量是一直存在的，而动态存储方式的变量则时而存在时而消失。这种由于变量存储方式不同而产生的特性称为变量的生存期。

变量的生存期表示了变量存在的时间。变量的生存期和作用域是从时间和空间这两个不同的角度来描述变量的特性，这两者既有联系，又有区别。一个变量究竟属于哪一种存储方式，并不能仅从其作用域来判断，还应明确变量存储类型的说明。

在C语言中，对变量的存储类型说明有以下四种：

```
auto		自动变量
register	寄存器变量
extern		外部变量
static		静态变量
```

自动变量和寄存器变量属于动态存储方式，外部变量和静态变量属于静态存储方式。在介绍了变量的存储类型之后，可以知道对一个变量的说明不仅应说明其数据类型，还应说明其存储类型。因此变量说明的完整形式应为：

```
存储类型说明符  数据类型说明符  变量表列 ;
```

#### 1)．自动变量（auto变量）

这种存储类型是C语言程序中使用最广泛的一种类型。C语言规定，函数内凡未加存储类型说明的变量均作为自动变量，也就是说，自动变量的声明可省去说明符auto。在前面各章节的程序中所定义的变量凡未加存储类型说明符的都是自动变量。

**特点:**

```
（1）自动变量的作用域仅限于定义该变量的个体内。在函数中定义的自动变量，只在该函数内有效，在复合语句中定义的自动变量只在该复合语句中有效。

（2）自动变量属于动态存储方式，只有在使用它的时候，即定义该变量的函数被调用时，才给它分配存储单元，开始它的生存期。函数调用结束，释放存储单元，结束生存期。因此函数调用结束之后，自动变量的值不能保留。在复合语句中定义的自动变量，在退出复合语句后也不能再使用，否则将引起错误。

（3）由于自动变量的作用域和生存期都局限于定义它的个体内（函数或复合语句内），因此不同的个体中允许使用同名的变量而不会混淆。即使在函数内定义的自动变量也可与该函数内部的复合语句中定义的自动变量同名。
```

#### 2)．局部变量(static变量)

若希望函数中的局部变量的值在函数调用结束后不消失而保留原值，这时就应该指定该局部变量为“静态局部变量”，用关键字static进行声明。

**特点：**

```
（1）静态局部变量属于静态存储类别。在程序整个运行期间都不释放存储单元。而自动变量（即动态局部变量）属于动态存储类别，函数调用结束后立即释放存储单元。

（2）静态局部变量在编译时赋初值，即只赋初值一次；而对自动变量赋初值是在函数调用时进行的，每调用一次函数重新赋初值一次。

（3）如果在定义局部变量时不赋初值的话，则对静态局部变量来说，编译时自动将其赋初值为0（对数值型变量）或空字符（对字符变量）。而对自动变量来说，如果不对其赋初值，则它的值是一个不确定的值。
```

#### 3)．寄存器变量(register变量)

上述各类变量都存放在存储器内，因此当对一个变量频繁读写时，必须要反复访问内存储器，从而花费大量的存取时间。为此，C语言提供了另一种变量，即寄存器变量。这种变量存放在CPU的寄存器中，使用时，不需要访问内存，而直接从寄存器中读写，这样可提高存取效率。寄存器变量的说明符是register。对于循环次数较多的循环控制变量及循环体内反复使用的变量均可定义为寄存器变量。

**说明：**

```
1）只有局部自动变量和形式参数才可以定义为寄存器变量。因为寄存器变量属于动态存储方式。凡需要采用静态存储方式的变量都不能定义为寄存器变量。

2）由于计算机系统中寄存器的个数是有限的，因此使用寄存器变量的个数也是有限的。目前的优化编译系统能够识别使用频繁的变量，从而自动地将这些变量放在寄存器中，而不需要程序设计者指定。因此，实际上用register声明变量是不必要的。
```

#### 4)．全局变量及其存储类型

全局变量的存储类型可以有两种：

```
外部（extern）

静态（static）
```

没有说明为static的全局变量，其存储类型都是外部的，统称为外部变量。

如果在同一个源程序文件中，全局变量的定义位于使用它的函数之后的话，可以在要使用该全局变量的函数中，用extern来说明该变量是外部的，然后再使用该变量。

使用extern来说明变量的存储类型时需要注意：

```
1）extern只能用来说明变量，而不能用来定义变量，它只是说明其后的变量是已经在程序的其它地方定义的外部变量。

2）由于extern只能说明变量而不能定义变量，因此，不能用extern来初始化变量。如：
extern  int  x ＝ 100 ;
是错误的。
```

**注意：**

```
1）全局变量一经定义，系统就为其分配固定的存储单元，由于它与函数内定义的变量无关，因此，不会因为某个函数的返回而释放全局变量所占用的存储单元。

2）凡在函数外部定义的全局变量，按缺省规则可以不写说明符extern，但在函数体内说明其后所定义的全局变量时，一定要冠以extern说明符。

3）全局变量的作用域是其定义点之后的程序部分，若在全局变量定义之前的函数中引用它，或在同属一个程序系统中的其他源程序文件中引用它，则只需在相应的函数或源程序文件中用extern说明它就行了。

4）由于通过函数的return语句只能返回一个函数值，同时由于非数组名作函数参数时采用“值传递”方式，这样，要想在函数之间传递大量的数据，一般来讲就只能利用全局变量或数组参数。

5）所有全局变量都是静态存储方式，其默认的初值为0（对于数值型变量）或空字符（对于字符型变量）。
```

## 6.内部函数和外部函数

如果在一个源文件中定义的函数，只能被本文件中的函数调用，而不能被同一程序其它文件中的函数调用，这种函数称为内部函数。

内部函数也称为静态函数。但此处静态static 的含义已不是指存储方式，而是指对函数的调用范围只局限于本文件。

```
								内部函数	
static  函数类型  函数名(函数参数表)
                {……}                                /*函数体*/
                
 								外部函数 
在定义函数时，如果在函数名前加上关键字estern，则表示该函数是外部函数。其定义的一般形式为：
extern 类型说明符   函数名(形参表)
 {……}                      /*函数体*/       
```

## 7.排序

```c++
sort(start,end,排序方法);

(1)第1个参数是要排序的数组的起始地址（数组名）
(2)第2个参数是最后一个要排序的数组元素的地址（数组名加数组元素的个数）
(3)第3个参数是排序的方法，可以是从大到小，也可以是从小到大，还可以不写，默认的排序方法是从小到大。
```



# 三.  编译预处理

预处理是指在进行编译的第一遍扫描(词法扫描和语法分析)之前所作的工作。预处理是Ｃ语言的一个重要功能，它由预处理程序负责完成。当对一个源文件进行编译时，系统将自动引用预处理程序对源程序中的预处理部分作处理，处理完毕自动进入对源程序的编译。

## 1.宏定义

宏定义就是用标识符来代表一个字符串，即给字符串取个名字。C语言用“#define”进行宏定义。C编译系统在编译前将这些标识符替换成所定义的字符串。

C语言的宏定义有两种形式：不带参数的宏定义和带参数宏定义。

​								**1.不带参数的宏定义**

```
#define 标识符 字符串 {……}

其中“标识符”称之为“宏名”。宏名通常可用大写字母表示，以便与程序中的其它变量名相区别。字符串也称宏体，外面不加双引号，这与前面讲的字符串常量不同。各部分之间用空格分开，最后以换行结束。例如：
```

​								**2.带参数宏定义**

```
#define  宏名(参数表)  字符串
```

①函数调用，在程序运行时，先求表达式的值，然后将值传递给形参；带参宏展开只在编译时进行的简单字符置换。

②函数调用是在程序运行时处理的，在堆栈中给形参分配临时的内存单元；宏展开是在编译时进行，展开时不可能给形参分配内存，也不进行“值传递”，也没有“返回值”。

③函数的形参要定义类型，且要求形参、实参类型一致。宏不存在参数类型问题。



## 2.文件包含

**作用**：

一个大程序，通常分为多个模块，并由多个程序员分别编程。有了文件包含处理功能，就可以将多个模块共用的数据（如符号常量和数据结构）或函数，集中到一个单独的文件中。这样，凡是要使用其中数据或调用其中函数的程序员，只要使用文件包含处理功能，将所需文件包含进来即可，不必再重复定义它们，从而减少重复劳动。

文件包含命令的功能是把指定的文件插入该命令行位置取代该命令行，从而把指定的文件和当前的源程序文件连成一个源文件。

```
＃include  “包含文件名” 

＃include  <包含文件名>
```

**区别**

```
1）使用双引号：系统首先到当前目录下查找被包含文件，如果没找到，再到系统指定的“包含文件目录”（由用户在配置环境时设置）去查找。

2）使用尖括号：直接到系统指定的“包含文件目录”去查找。一般地说，使用双引号比较保险。 
```

## 3.条件编译

三种形式：

```
#ifdef  标识符  
        程序段1  
#else  
        程序段2  
#endif  

它的作用是：如果标识符已被#define命令定义过则对程序段1进行编译；否则对程序段2进行编译。
```

```
#ifndef  标识符  
        程序段1  
#else  
        程序段2  
#endif  

它的作用是：如果标识符未被#define命令定义过则对程序段1进行编译，否则对程序段2进行编译。这与第一种形式的功能正相反。
```

```
#if  常量表达式  
        程序段1  
#else  
        程序段2  
#endif  

它的作用是：如果常量表达式的值为真(非0)，则对程序段1 进行编译，否则对程序段2进行编译。它可以使程序在不同条件下，完成不同的功能。
```

# 四.   指针

**指针**是C语言提供的一种特殊而又非常重要的数据类型，是C语言的灵魂与精华。在C语言程序设计中，利用指针可以直接对内存中各种不同结构的数据进行快速处理，同时也为函数间各类数据的传递提供了便捷的方法。

## 1. 地址与指针概念



在定义变量时，系统就给这个变量分配内存单元一个变量在内存中占用一个存储空间，而存储空间的大小（字节数）是由变量的类型决定的。内存区的每一个字节有一个编号，这就是内存单元的地址。

根据一个内存单元的地址（编号）即可准确地找到该内存单元。

如果变量占用多个字节的内存单元将对应多个编号。为了能正确的访问变量所代表的存储空间，C语言规定将一个变量所占用的存储空间第1个字节的地址（即首地址）称为**该变量的地址**。

在C语言中，将地址形象化地称为“**指针**”。意思是通过它能找到以它为地址的内存单元。

按变量名来访问变量所对应的存储空间而存取变量值的方式称为**直接访问**

先访问指针的存储空间，其中存放的是变量a的地址值，再根据该地址值访问变量a的存储空间，这种访问方式称为**间接访问**。

​										指针和指针变量区别：

```
一个变量的地址称为该变量的指针
如果有一个变量专门用来存放另一变量的地址（即指针），则它称为指针变量

指针变量就是地址变量，用来存放地址的变量，指针变量的值是地址（即指针）
指针是一个地址，而指针变量是存放地址的变量
```



## 2.   变量与指针

### 定义

```
[存储类型] 数据类型   *指针变量名;
```

指针变量的地址值都是整型的，指向不同类型对象的指针变量存储空间大小相同

但还是要将指针变量按其指向的对象定义为不同的类型，为什么？

原因是计算机对于指针的运算是按照定义指针变量时所指向对象类型来进行的。指向不同类型对象的指针在内存中进行移动操作时，其移动的字节数是不一样的。

### 初始化

```
[存储类型] 数据类型   *指针变量名= 初始值;
```

### 引用

指针运算是以指针所存放的地址值为运算量进行的运算。

**指针运算的实质是地址的计算。**

​													**1.基本运算**

```
（1）取地址运算符& 
表达式一般格式为：
           &operand
 其功能是取得操作数的地址

注意：取地址运算符“&”不能作用到常量、表达式上


（2）间接访问运算符* 
表达式一般格式为：
           &add
其功能是用来获取指定地址中的数据。
```

​													**2. 指针的赋值运算**

```
指针赋值是将对象的地址存入指针变量。能够给指针赋值的只有：0或NULL、同类型的地址值。
例：int *p,n=10,*q,a[10];
       double d=2.5,*pd;
       p=0;p=NULL;
       p=&n;
       q=a;q=&a[0];q=&a[5];
       pd=&d; 
       
通过对指针赋予不同的地址值可以让指针指向不同的变量
多个指针也可赋相同的地址值，即同时指向同一目标变量。
指针是存放地址值的变量，C语言不支持把任何其它数据如整数（0除外）赋予指针，也不支持类型不同的指针之间相互赋值。
```

​													**3.在引用指针变量时**

```
给指针变量赋值。
引用指针变量指向的变量。
引用指针变量的值。
```

**注意：**

在使用指针变量之前，一定要给该指针赋予确定的地址值、0或NULL。一个没有赋值的指针其指向目标是不确定的，这种指针被称为悬空指针，将会出现指针乱指现象。

## 3.指针变量作为函数参数

使用指针类型做函数的参数，实际向函数传递的是**地址值**。

指针作为函数参数可以把实参的地址传入到被调函数中，被调函数中对形参的处理时，可以通过指针间接访问到实参，而实现对实参的处理。因此形参的改变能够影响实参。从而达到被调函数中形参的改变能够影响实参的目的。

 **指针作函数的参数，不仅能保留函数中对实参的修改，而且由于传递的是地址，不需要生成实参的副本，因此参数传递的效率较高，特别是传递体积较大的数据，如数组、结构体等。**

## 4.一维数组与指针

### 									 1).指针与一维数组的关系

数组在计算机中被存储在一个连续的内存空间。数组中的每一个元素都具有相同的数据类型并分配了相同大小的存储空间。

变量有地址，数组包含若干元素，每个数组元素都有相应的地址，**即该元素相对数组首地址的偏移量**。

所谓数组元素的指针就是数组元素的地址

可以用一个指针变量指向一个数组元素

**注意**：

```
当一个指针指向数组中的某个元素时，不但可以通过该指针访问被指数组元素，还可以通过它访问数组里的其他元素。

如果指针p已指向数组中的一个元素，则*p+1指向同一数组中的下一个元素。

数组名表示数组首地址（即数组第一个元素的地址），这个地址是在数组定义时就已确定的且不可更改，所以数组名可以看作是一个常量指针

当指针*p指向数组的首地址时：
            p+i和a+i:表示指向同一数组a中的第i个元素a[i]或者说它们就是a[i]的地址
            *(p+i)或*(a+i):表示指针p+i或a+i所指向的数组元素，即a[i]
            指针p也可以带下标表示数组元素，如p[i]即表示a[i]
```

### 2).指针的算术运行

指针的算术运算是指可以进行指针加/减整数运算，指针的自增/自减运算以及同类型指针之间的减法运算，而乘法、除法、求余运算以及指针之间的加法运算等，并无实际意义，也不支持。

```
								指针加、减整数运算 
如果指针变量p已指向数组中的一个元素，则p+1指向同一数组中的下一个元素，p-1指向同一数组中的上一个元素。
int a[10],*p=a;
     假设a[0]的地址为13ff78H，则p的值为13ff78H
		p+1的值为13ff7CH(13ff78H+4)。
     因为int型数据占4个字节。

对不同数据类型的指针p，p+n（n为整数）表示的实际地址值是： 
     p中的地址值+n×数据长度（字节数） 

注意：
   通常指针加/减整数运算与数组相联系才有具体的意义。


								指针的自增、自减运算 
p++:指针p指向下一个对象；
p--:指针p指向上一个对象。

注意：指针变量的自增、自减运算与普通变量规则一样。


								两个同类型指针相减 
两个同类型的指针可以相减，两个地址不能加，其运算结果是两个指针所指向的地址位置之间所包含的对象个数。两个指针相减也是地址计算，但结果值不是地址量，而是一个整数（对象个数）。
```

**注意：表达式p+n表达式*(p+n）是不同。**

设指针p和q是指向同类型的对象，则p-q运算的结果按下面公式计算得到： 

![image-20240703120044908](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/image-20240703120044908.png)

### 3). 指针的关系运算

   两个同类型的指针，或者一个指针和一个地址量之间可以进行比较，比较的结果**反映出两个地址位置的前后关系**。两个指针相等是指两个指针同时指向同一位置。   

注意：

```
要注意指针变量的当前值。

不同类型指针之间或指针与一般的整型数据之间的比较是没有实际意义的。

指针p与整数0可以进行等于或不等于的比较，即：
 p==0或p!=0
 (0也可以写成NULL)
```

引用数组元素，可用下面两种方法：

**下标法**：用数组名加下标 ，如a[i]；或用指针名加下标，如p[i]。

**指针法**：即地址法。*(a+i) 或*(p+i)



### 5.  指针访问数组元素的方法

1）数组名指针法，即通过**一维数组名+偏移量**的方式访问数组元素。 

2）指针名指针法，即通过指向数组首地址的指针名+偏移量的方式访问数组元素。

3）指针名下标法，即通过指针名+下标的方式访问数组元素。

**注意**：数组名a是一个常量指针，是不能修改的，任何企图修改它的操作（如赋值、自增/自减）都是非法的。而指针p则是可以任意赋值，可以通过指针运算在一个合法的地址范围内任意改变，指向数组中的任何一个元素。

​									     数组元素作函数参数

```
数组元素作函数参数时，与普通变量作函数参数的情况相同，属于值传递方式。即函数调用时，是将实参——数组元素的值传递给形参变量。
```

​									     数组名作函数参数

```
在C语言中，调用函数时采用“值传递”方式。当用变量作为函数参数时，传递的是变量的值，当用数组名作函数参数时，由于数组名代表的是数组起始地址，因此传递的是数组首地址，所以要求形参为指针变量。

在进行函数定义时，往往采用形参数组的形式，这是因为在C语言中用下标法和指针法都可以访问数组。但是，应该明确一点，形参数组本质就是一个指针变量，由此指针变量接收实参传递的数组首地址。那么，通过对形参指针所指向的存储单元的操作，实际上就是对实参数组元素的操作。
```

数组名作函数参数时，形参和实参的表示形式有以下4种情况：

```c
（1）形参和实参都用数组名。如：
int   main ( )                           void  func (int x[ ], int n)
{	int a[10] ;                     {
…                                                 …
func (a,10);                            }
…
}

（2）实参用数组名，形参用指针变量。如：
int   main ( )                          void  func (int *x, int n)
{	int a[10] ;                    {
…                                                …
func (a,10);                           }
…
}	

（3）形参和实参都用指针变量。如：
int  main ( )                            void  func (int *x, int n)
{	int a[10],*p=a ;           {
…                                                 …
func (p,10);                             }
…
}	

（4）实参用指针变量，形参用数组名。如：
int  main ( )                            void  func (int x[ ], int n)
{	int a[10],*p=a ;           {
…                                                 …
func (p,10);                             }
…
}	
```

 **处理方式：**

```
C语言中字符串是通过字符数组来处理的，同样也可以使用字符指针来处理字符串。通常用字符指针处理字符串时，是先将字符串存放到字符数组中，然后通过字符指针处理数组元素（字符）的方式处理字符串。
```

**注意**：在初始化或程序中向字符指针赋予字符串常量，并不是把该字符串本身复制到指针中。而是把存储字符串的首地址赋予指针，从而使指针指向该字符串的首字符位置。

**字符数组、字符串和字符指针的联系与区别：**

```
1)字符数组和字符指针都能实现对字符串的处理。

2)字符数组由元素组成，每个元素中存放一个字符。而字符指针中存放的是字符串的地址。

3)只能对字符数组中的各个元素赋值，而不能用赋值语句对整个字符数组赋值。

4)字符数组名虽然代表地址，但数组名的值不能改变。

5)可以用下标形式引用指针所指向的字符串中的字符

6)可以通过键盘输入字符串的方式为字符数组输入字符元素，但不能通过输入函数让字符指针变量指向一个字符串。因为由键盘输入的字符串，系统是不分配存储空间的

7)字符数组中各元素的值是可以改变的(可以对它们再赋值)；但将字符串常量通过赋值语句赋予字符指针后，其中的字符不能被修改。
```

字符串指针作函数参数时，在被调函数中可以改变字符串的内容，在主调函数中可以得到改变了的字符串。同样在函数调用时，实参传给形参的是字符串的首地址。

![image-20240703121400260](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/image-20240703121400260.png)

## 5.返回指针值的函数

一个函数可以返回一个int型数据，或一个float型数据，或一个char型数据等，也可以返回一个指针类型的数据。函数返回值的类型决定了函数的类型。返回指针值的函数（简称指针函数）的定义格式如下：

```
函数类型   * 函数名( 形参表 )
{  
   ：
}
```

定义函数时，函数名前的“*”表示函数的返回值是指针类型，即表示此函数是指针型函数。“类型标识符”表示返回的指针值的基类型，即所返回的指针指向的数据类型。

## 6.指针数组

一个数组，若其数组元素均为指针类型，称为*指针数组。指针数组是指针的集合，它的每一个数组元素都是一个指针变量，并且可以指向具有相同的数据类型的目标变量

一维指针数组的定义形式为:

```
[存储类型] 数据类型  *指针变量名[数组长度];
```

在程序中通常使用指针数组处理多维数组

##### 命令行参数

指针数组的一个重要应用是作为main()函数的形参。一般在程序中，主函数main()都使用其无参形式。实际上，主函数main()也是可以指定形参的。 
主函数main()的有参形式:

```
main(int argc, char *argv[])
{ … …}
```

运行带形参的主函数，必须在操作系统状态（一般在在DOS状态）下，输入带形参主函数所在的可执行文件名，以及所需的实参（字符串），然后回车即可

命令行的一般格式为：

```
可执行文件名    [实参1     实参2……]
```

##  7.指向指针的指针

指针是一个其数值为地址的变量，如果指针中存放的是数据对象如普通变量或数组元素的地址，被称为一级指针（通常简称为指针）。 

指针是变量，系统将为它分配相应大小的存储空间，也有其内存地址，则该地址也可以成为被处理的对象。如果有变量存放的是指针变量的地址，则该变量称为指向指针的指针，即二级指针。

![image-20240703122438239](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/image-20240703122438239.png)

**定义**:

```
[存储类型] 数据类型 **指针变量名;
```

**场景**

```
常用二级指针来处理二维数组和多个字符串
```

```
下面三条语句等价：
a=3       //直接请问
*pa=3    //一级间接请问
**ppa=3 //二级间接请问
```

int s[3][4];设二维数组的首行的首地址为2000，则：

| 表 示 形 式                       | 含义                                       | 地 址  |
| --------------------------------- | ------------------------------------------ | ------ |
| a                                 | 二维数组名，指向一维数组a[0］，即0行首地址 | 2000   |
| a[0],  *(a+0),  *a                | 0行0列元素地址                             | 2000   |
| a+1，&a[1]                        | 1行首地址                                  | 2012   |
| a[1],*(a+1)                       | 1行0列元素a[1][0]的地址                    | 2012   |
| a[1]+2,  *(a+1)+2,  &a[1][2]      | 1行2列元素a[1][2]的地址                    | 2020   |
| *(a[1]+2),  *(*(a+1)+2),  a[1][2] | 1行2列元素a[1][2]的值                      | 元素值 |

## 8.函数的指针和指向函数的指针变量

C语言规定函数的首地址即函数名，所以函数名就是函数的指针。**指向函数的指针变量**就是保存函数入口地址(函数指针)的变量，称这种变量为指向函数的指针变量。

**定义：** 

```
类型 (* 函数指针变量名) ( );			//两组括号( )都不能少
```

**例如：**

```
int (*p)();						//int表示被指向的函数的类型，即被指向的函数的返回值的类型
```

使用方法有两种：

```
指向函数的指针变量的赋值，指向某个函数： 函数指针变量名=函数名；

利用指向函数的指针变量调用函数：
	(* 函数指针变量名) (实参表)
```

## 9.有关指针的数据类型

| 定义          | 含  义                                            |
| ------------- | ------------------------------------------------- |
| int  i;       | 定义整型变量i                                     |
| int  *p       | p为指向整型数据的指针变量                         |
| int  a[n];    | 定义整型数组a，它有n个元素                        |
| int  *p[n];   | 定义指针数组p，它由n个指向整型数据的指针元素组成  |
| int  (*p)[n]; | p为指向含n个元素的一维数组的指针变量              |
| int  f();     | f为带回整型函数值的函数                           |
| int  *p();    | p为带回一个指针的函数，该指针指向整型数据         |
| int  (*p)();  | p为指向函数的指针，该函数返回一个整型值           |
| int  **p;     | P是一个指针变量，它指向一个指向整型数据的指针变量 |

## 10.指针运算

### 1）取地址运算符&

```
求变量的地址
```

### 2）取内容运算符*

```
表示指针所指的变量
```

### 3）赋值运算

```
        i. 把变量地址赋予指针变量 
        ii. 同类型指针变量相互赋值
        iii. 把数组，字符串的首地址赋予指针变量
        iv. 把函数入口地址赋予指针变量

具体定义及其含义如下：
        p=&a;    (将变量a的地址赋给p)
        p=array;   (将数组array的首地址赋给p)
        p=&array[i];  (将数组array第i个元素的地址赋给p)
        p=max;    (max为已定义的函数，将max的入口地址赋给p)
        p1=p2;    (p1和p2都是指针变量，将p2的值赋给p1)

注意：
	不能用以下形式对指针变量赋值：p=1000
	指针变量可以有空值，即该指针变量不指向任何变量：p=NULL
```

### 4). 指针变量加（减）一个整数

```
例如：p++、p--、p+i、p-i、p+=i、p-=i

一个指针变量加（减）一个整数并不是简单地将原值加（减）一个整数，而是将该指针变量的原值（是一个地址）和它指向的变量所占用的内存单元字节数加（减）。

两个指针变量可以相减：如果两个指针变量指向同一个数组的元素，则两个指针变量值之差是两个指针之间的元素个数。
```

### 5).两个指针变量比较

```
如果两个指针变量指向同一个数组的元素，则两个指针变量可以进行比较。指向前面的元素的指针变量“小于” 指向后面的元素的指针变量。
```

## 11.void指针类型

ANSI新标准增加了一种“void”指针类型，即可以定义一个指针变量，但不指定它是指向哪一种类型数据。

# 五.  结构体与共用体

## 1.结构体数据类型

### 结构体类型的定义

```
struct  结构体类型名
{
   	成员表列;
};	//不能省略，表示结构体类型说明的终止
```

```c
struct  student
{
       long		num ;
       char		name[20] ;
       char		sex ;
       long		score ;
} ;
```

**说明：**

```
结构体类型中的成员，既可以是基本数据类型，也可以是另一个已经定义的结构类型；
数据类型相同的成员，既可逐个、逐行分别定义，也可合并成一行定义。
例如上面日期结构体类型的定义可改写为如下形式：
	struct  date { int  year, month, day ; } ;

结构体类型中的成员名，可以与程序中的变量同名，但是它们代表不同的对象，互不影响。

结构体类型定义可以在函数的内部进行，也可以在函数的外部进行。在函数内部定义的结构体，其作用域仅限于该函数内部，而在函数外部定义的结构体，其作用域是从定义处开始到本源程序文件结束。

结构体类型的定义只是描述结构体类型数据的组织形式，规定这个结构体类型使用内存的模式，并没有分配一段内存单元来存放各数据项成员。只有定义了这种类型的变量，系统才为变量分配内存空间，占据存储单元。
```

## 2.结构体变量的定义

### 1).定义结构体类型变量的一般形式为：

```c
struct  结构体类型名  结构体变量名表 ;

struct  结构体类型名
{
成员表列
} 结构体类型变量表 ;

struct
{
成员表列
} 结构体类型变量表 ;
```

```c
				（1）先定义结构体类型再定义结构体类型变量
struct  student
{
   	long num ;
   	char name[20] ;
   	char sex ;
   	float score ;
} ;
struct  student  student1，student2；		//拥有结构体的全部类型的全部成员

						（2）在定义结构体类型的同时，定义结构体类型变量
struct  student
{
   	long num ;
   	char name[20] ;
   	char sex ;
   	float score ;			//直接在结构体类型定义的花括号后，分号前给出
} student1 , student2 ;

						（3）直接定义结构体类型变量（不出现结构体名）
struct					//没有结构体类型名，因此也就不能用它来定义其它的变量
{
   	long num ;
   	char name[20] ;
   	char sex ;
   	float score ;
} student1 , student2 ;
```

### 3).结构体类型与结构体类型变量区别：

```
结构体类型与结构体类型变量是两个不同的概念，其区别如同int类型与int型变量的区别，只能对变量进行赋值、存取或运算，而不能对类型进行赋值、存取或运算。编译时，对类型是不分配内存单元的，只对变量分配内存单元，存储单元的大小取决于变量的数据类型。当声明一个结构体类型变量时，系统为结构体类型变量分配一段连续的存储单元，依次存储各成员数据，其大小为该结构体类型变量的各个成员所占内存单元之和，在程序中使用结构体变量时，一般情况下，不把结构体变量作为一个整体参加数据处理，而是用结构体变量的各个成员来参加各种运算和操作。例如赋值、输入、输出、运算等操作都是通过结构体变量的成员来实现的。
```

### 4).引用结构体变量成员

```c
			结构体变量名.成员名
                
例如：
student1.num			/* 即student1的学号num */
student2.sex			/* 即student2的性别sex */
如果结构体变量的成员本身又是一个结构体类型的数据，那么，必须逐级找到最低级的成员才能使用。例如：student1.birthday.month = 12 ;
```

### 5).说明

```
1）结构体成员是结构体变量中的一个数据，成员项的数据类型是结构体类型定义时定义的，对结构体类型变量的成员可以进行何种运算是由其类型决定。允许参加运算的种类与相同类型的简单变量的种类相同。例如：
student2.score = student1.score + 10 ;
sum = student2.score + student1.score ;
           student1.num ++ ;

2）可以引用结构体变量的成员的地址，也可以引用结构体变量的地址。例如：
       scanf ( "%f", & student1.score ) ; 	/* 输入student1.score的值 */
       printf ( "%x", & student2 ) ; 		/* 输出student2的首地址 */

3）结构体变量的地址主要用作函数参数，传递的是结构体变量的地址。

4）一个结构体变量也可以作为一个整体来引用。   
允许两个相同类型的结构体变量之间相互赋值，这种结构体类型变量之间赋值的过程是将一个结构体变量的各个成员的值赋值给另一个结构体变量的相应成员。
student2 = student1 ;		合法
不允许用赋值语句将一组常量直接赋值给一个结构体变量。			不合法

5）结构体类型变量也可以进行初始化。
与一维数组的初始化相似，不同的是，如果结构体变量的某个成员本身又是结构体类型，则该成员的初值为一个初值表。
struct  student_type  stud = { 80511 , "Zhang San " , ‘M’, { 5 , 12 , 1980 } , 87.5 } ;
```

**注意：结构体变量的各个成员初值的数据类型，应该与结构体变量中相应成员的数据类型一致，否则会出错。**

```c
#include <stdio.h>
struct  student
{
      long  int  num ;
      char  name[20] ;
      char  sex ;
      char  addr[30] ;
} ;
int  main ( )
{
      struct  student  s1,s2 ;
      printf ( "Input  num : " ) ;
      scanf ( "%ld" , &s1.num ) ;
      printf ( "Input  name : " ) ;
      scanf ( "%s" , s1.name ) ;
      printf ( "Input  sex : " ) ;
      scanf ( "  %c" , &s1.sex ) ; /*在%c前面加一个空格，将存于缓冲区中的回车符读人*/
      printf ( "Input  address : " ) ;
      gets ( s1.addr ) ;
      s2=s1;		/*s1的所有成员的值整体赋予s2*/
      printf ( "\nOUTPUT : \n " ) ;
      printf ( "\tNO.:%ld\n" , s2.num ) ;
      printf ( "\tname:%s\n" , s2.name ) ;
      printf ( "\tsex:%c\n" , s2.sex ) ;
      printf ( "\taddress:%s\n" , s2.addr ) ;
      return  0;
}
```

###  6).结构体数组

当数组的元素是结构体类型时，就构成了结构体数组。结构体数组是具有相同结构体类型的变量集合。结构体数组的每一个元素都具有相同结构体类型。其定义的一般形式和前面定义结构体变量相同，只是把变量名改为数组名即可。

```c
1）先定义结构体类型，再定义结构体类型的数组，其一般形式为：
 struct 结构体类型名 结构体数组名[数组长度]；

2）在定义结构体类型的同时定义结构体数组，其一般形式为：
struct 结构体类型名
{
成员表列
} 结构体数组名[数组长度] ；

3）直接定义结构体类型数组，其一般形式为：
struct
{
成员表列
} 结构体数组名[数组长度] ；
```

### 7).引用结构数组元素的成员时的一般形式为：

```
结构数组名[下标].成员名
```

### 8).初始化

```c
struct  student  st[3] = { {…}, {…}, {…} } ;

编译时，系统会根据所给出初值的个数来确定数组元素的个数
```

### 9).结构体指针

**1．指向结构体变量的指针**

```
当一个指针变量用来指向一个结构体变量时，称之为结构体指针变量。结构体指针变量中的值是所指向的结构体变量的首地址。通过结构体指针即可访问该结构体变量，与数组指针和函数指针的情况相类似的。

结构体指针变量说明的一般形式为：
struct 结构体类型名 * 结构体指针变量名 ；//必须是已经被定义过的结构体类型

当一个结构体指针变量指向一个结构体类型变量时，以下三种形式是等价的：
1）结构体类型变量.成员名
2）( * 结构体指针变量 ) .成员名
3）结构体指针变量 -> 成员名		//"->"也是一种运算符，称为指向运算符，表示结构体指针变量所指向的结构体数据中的成员
```

**2．指向结构体数组的指针**

```
既然结构体类型指针变量可以指向一个结构体变量，那么，结构体类型指针变量也可以指向一个结构体数组，这时结构体指针变量的值是整个结构体数组的首地址。设ps为指向结构体数组的指针变量，则ps指向该结构体数组的0号元素，ps+1指向1号元素，ps+i则指向i号元素。这与普通数组的情况是一致的。
```

##### 注意：

```
1） 结构体指针变量ps的初值为st，即ps保存结构体数组st的首地址，ps指向数组st的第一个元素，即ps的值为&st[0]，则表达式ps+1指向数组下一个元素的起始地址，即&st[1]。 
(++ps)->num /* 使ps自加1，然后得到其所指元素的num成员值，即80602 */
(ps++)->num /* 得到ps->num的值，即80601，然后使ps自加1，指向st[1] */

2） ps已定义为指向struct student类型数据的指针变量，它只能指向一个此结构体类型数据，也就是说，ps只能用来保存st数组的某个元素的起始地址，而不能指向结构体类型数据的某一成员，即ps不能用来保存数组元素的某一成员的地址。例如：

3）但对于地址类型不相同的情况，若要实现赋值，可使用强制类型转换。例如：
ps = ( struct student * ) &st[0].num ;
```

**3.  用指向结构体类型数据的指针作函数参数**

在ANSI C标准中，允许用结构体变量作函数参数进行整体传递。但是这种传递要将全部成员逐个传递，特别是成员为数组时将会使传递的时间和空间开销很大，严重地降低了程序的效率。因此最好的办法就是使用指针，即用指向结构体类型数据的指针变量作函数参数进行传递。这时由实参传递给形参的只是结构体类型数据的地址，通过结构体指针形参来对结构体类型数据进行操作，从而减少了时间和空间的开销。

### 10).链表

动态数据结构最大的优点是数据的多少及其相互之间的逻辑关系可以在程序执行的过程中按具体需要进行改变。常用的动态数据结构有链表、树、图等。

**1．动态存储分配函数**

所需的内存空间取决于实际输入的数据，而输入数据的个数预先无法确定，对于这种问题，用数组的办法很难解决。为了解决上述问题，Ｃ语言提供了一些内存管理函数，这些内存管理函数可以按需要动态地分配内存空间，也可把不再使用的空间回收待用，为有效地利用内存资源提供了手段。

```
（1）求字节数运算符sizeof
格式：
sizeof ( 类型名或变量名 )		//功能是返回指定类型或变量的长度

（2）分配内存空间函数malloc
功能是在内存的动态存储区中分配一块长度为"size"字节的连续区域。函数的返回值为该区域的首地址
函数调用形式：
void * malloc ( size )		

（3）分配内存空间函数 calloc
功能是在内存动态存储区中分配n块长度为"size"字节的连续区域。函数的返回值为该区域的首地址
函数调用形式：
void * calloc ( n , size )

（4）释放内存空间函数free
功能是释放ptr所指向的一块内存空间
函数调用形式：
     void  free ( void * ptr ) ;
说明：ptr是一个任意类型的指针变量，它指向被释放区域的首地址。被释放区应是由malloc或calloc函数所分配的区域。



```

##### **说明：动态存储分配函数的原型在头文件<alloc.h>或<stdlib.h>中。**

**2.动态数据结构——链表**

将逻辑上相邻的数据分配在物理上相邻的存储单元中，数据之间的逻辑关系通过存储单元的邻接关系来体现，这样的存储方式称为"顺序存储"。

```
将逻辑上相邻的数据分配在物理上离散的存储单元中，然后在每一个存储单元中存入相邻者的存储地址，使数据之间的逻辑关系通过地址的链接关系来体现，这样的存储方式称为"链接存储"。

链表，就是指把存放在离散的存储单元中的数据用地址链接而成的数据链。

链表中有一个"头指针"(head)，该指针指向第一个元素，若head指针的值为"NULL"（空值），则表示此链表为空表，即链表中不包括任何元素。链表中的每一个元素称为一个"结点"，每个结点都包括两部分信息，一部分信息是数据域，存放各种实际的数据，如学号num，姓名name，性别sex和成绩score等。另一部分信息为指针域，存放下一个结点在内存中的起始地址。链表中的每一个结点都是同一种结构类型。也就是说，头指针保存第一个结点的内存地址，第一个结点的指针域保存第二个结点的内存地址，以此类推下去，直到最后一个结点，最后一个结点不再指向其它结点，此结点称为"表尾"，其指针域放了一个"NULL"，表示链表到此结束。

链表的各个元素在内存中可以不连续存放。要找到某一个结点，必须先找到上一个结点，根据其提供的地址，才能找到下一个结点。
```

**3.链表结点的结构描述**

```
链表的结点是一个结构类型，其指针域所指的对象是一个与其自身类型完全相同的结构体变量，形成了结构体类型的递归定义。

链表结点的类型定义：
struct 结构体类型名
{
   数据成员表列 ;
   struct 结构体名 * 指针成员名 ;
} ;
```

**4. 链表的基本操作**

对链表的基本操作有：创建、检索（查找）、插入、删除和修改等。

```
1）创建链表：指从无到有地建立起一个链表，即往空链表中依次插入若干结点，并保持结点之间的关系。

2）结点的查找和输出：指按给定的结点特征或检索条件，查找某个结点则输出。如果找到指定的结点，则称为查找成功；否则，称为查找失败。

3）结点插入：指在结点a与结点b之间插入一个新的结点x，使线性表的长度增1，且结点a与结点b的逻辑关系发生如下变化：

4）结点删除：指删除结点b，使线性表的长度减1，且结点a、结点b和结点c之间的逻辑关系发生如下变化：
删除前，结点b是结点c的前驱、结点a的后继；删除后，结点a成为结点c的前驱，结点c成为结点a的后继。
插入前，结点a是结点b的前驱，结点b是结点a的后继；插入后，新插入的结点x成为结点a的后继、结点b的前驱。
```

## 3.共用体数据类型

#### 1).共用体类型的定义

在某些应用场合中，需要一个变量在不同的时候具有不同类型的值，这些不同类型的值所占用的存储空间也可能不同的。例如，设计一个统一的结构用来保存学生和教师的信息。无论是学生还是教师，都包括编号、姓名、性别和出生日期等信息，此外，对于学生还有班级编号的信息，而对于教师则有所属部门的信息。显然，班级编号和所属部门是不同类型的数据。要使这两种不同类型的数据能存放在同一个地方且占据同样大小的存储空间，只有利用共用体（也称为联合）来解决这个问题。

共用体类型的定义及共用体变量的定义方法与结构体的相应定义是相同的：

```
union  共用体类型名
{
   	成员表列
} ;
```

**共用体与结构体区别：**

在结构体中各成员有各自的存储单元，一个结构体类型变量所占用存储单元的大小是各成员所占用存储单元大小之和。而在共用体中，各成员共享一段存储单元，一个共用体类型变量所占用存储单元的大小等于各成员中所占用存储单元最大的值。

### 2).引用共用体成员的一般形式为:

```
共用体变量名.成员名
```

**注意**

```
1．任一时刻共用体类型变量只有一个成员起作用。共用体类型变量中起作用的成员是最后一次存取的成员。

2．共用体变量各成员的内存起始地址是相同的，共用体变量的内存起始地址和其各成员的地址是相同的。
```

### 3)．共用体变量赋值时需要注意：

```
1.不能对共用体变量名赋值。例如：有共用体类型变量a
2.不能企图引用共用体变量来得到一个值。例如有共用体类型变量a、b
3.不能在定义共用体变量时进行初始化，例如：
4．共用体成员的数据类型可以是基本数据类型、数组、指针，也可以是结构体类型。
5．共用体变量不能用作函数的参数；但是共用体变量的成员可以用作函数的参数。
6．可以使用指向共用体变量的指针。
7．可以定义共用体数组。
8．共用体类型可以作为结构体成员的类型。
```

## 4.枚举数据类型

在实际问题中，有些变量的取值被限定在一个有限的范围内。例如：一个星期内只有七天，一年只有十二个月，一个班每周有六门课程等等。C语言提供了一种称为“枚举”的类型。在“枚举”类型的定义中列举出所有可能的取值，被说明为该“枚举”类型的变量，其取值不能超过定义的范围。枚举类型是一种基本数据类型，而不是一种构造类型，因为它不能再分解为任何基本数据类型。

#### 枚举类型定义的一般形式为：

```
enum 枚举类型名 { 枚举值表 } ;

枚举值表: 一一列出所有可用值，也称为枚举元素或枚举常量。枚举元素是用户定义的标识符
```

```
例如：
enum  weekday { sun , mon , tue , wed , thu , fri , sat } ;
声明了枚举类型就可以定义枚举类型变量。枚举类型变量在定义时，可以先定义枚举类型，然后定义变量，例如：
enum  weekday  workday , weekend ;

也可以在声明枚举类型的同时定义枚举类型变量，例如：
enum  weekday { sum , mon , tue , wed , thu , fri , sat } workday , weekend ;
```

#### 说明

```
（1）在进行编译的时候，将枚举元素按常数处理，故称枚举常量。枚举元素不是变量，不能对枚举元素赋值。
（2）枚举元素作为常量，是有值的，在进行编译的时候，按枚举元素定义的顺序使其值分别为0，1，2，…。
（3）枚举值可进行关系运算。
（4）一个整数不能直接赋值给一个枚举类型变量
```

## 5.自定义类型

Ｃ语言不仅提供了丰富的数据类型，而且还允许由用户自己定义类型说明符，也就是说允许由用户为数据类型取"别名"。类型定义符**typedef**即可用来完成此功能。

### typedef定义的一般形式为：

```
typedef  原类型名  新类型名

原类型名：已存在的数据类型名
新类型名：一般用大写表示，以便于区别
```

#### （1）用typedef定义数组

```c
typedef  int  NUM[50] ; 	/* 声明NUM为长度为50的整型数组类型 */
NUM  s1 , s2 ;		/* 定义s1、s2为整型数组变量 */
```

#### （2）用typedef定义指针

```c
typedef  char  *STRING ; 	/* 声明STRING为字符指针类型 */
STRING  p , st[6] ; 		/* 定义p为字符指针变量，st为字符指针数组 */
```

#### （3）用typedef定义结构体类型

```c
typedef  struct  student
{
   	long num ;
   	char *name ;
   	int age ;
   	char sex ;
} STUDENT ;
```

### 说明：

```
（1）用typedef可以声明各种类型名，但不能用来定义变量。
（2）用typedef只是对已经存在的类型增加一个别名，而没有创造出新的类型。
（3）typedef与#define有相似之处
```

# 六.文件

文件是程序设计中的一个重要概念，它是指存储在外部介质（如磁盘）上数据的集合。操作系统就是以文件为单位进行数据管理的。

## 1.文件概述

### 1).文件概念

```
文件是指一组相关数据的有序集合，这个数据集的名称就是文件名。

文件一般是存储在外部介质（如磁盘）上的，在使用时才调入内存。操作系统是以文件为单位对数据进行管理的，也就是说，如果想找存放在外部介质上的数据，必须先按文件名找到所指定的文件，然后再从该文件中读取数据。要向外部介质上存储数据也必须先建立一个文件（以文件名为标识），才能向它输出数据。

文件标识常被称为文件名，完整的文件名实际上包括文件路径、文件名主干和文件后缀3部分内容。其中，文件名主干的命名规则遵循标识符的命名规则。后缀用来表示文件的性质，一般不超过3个字母。
```

### 2).文件分类

```
从用户的角度看，文件可分为普通文件和设备文件两种。

普通文件是指驻留在磁盘或其它外部介质上的一个有序数据集，可以是源文件、目标文件、可执行文件；也可以是一组待输入处理的数据，或是一组输出的结果，如一批学生的成绩数据、货物交易的数据等。

设备文件是指与计算机主机相关联的各种外部设备，如显示器、打印机、键盘等。为简化用户对输入输出设备的操作，操作系统把各种外部设备都统一作为文件来处理，把它们的输入、输出等同于对磁盘文件的读和写。通常把显示器定义为标准输出文件，一般情况下，在屏幕上显示有关信息就是向标准输出文件输出，如printf、putchar函数就属于此类输出操作；键盘通常被定义为标准输入文件，从键盘上输入信息就相当于从标准输入文件输入数据，如scanf、getchar函数就用来实现此类输入操作。

根据数据的组织形式或编码方式，数据文件可分为ASCII码文件和二进制文件。

ASCII文件也称为文本文件，在文本文件中，一个字节存放一个ASCII代码，代表一个字符。ASCII码文件按字符显示，因此我们能读懂文件内容，便于检查或编辑，例如，C程序的源代码是存储在文本文件中的。但此种形式占用空间较大，读写操作要进行转换。例如，数字32767的存储形式为’3’、’2’、’7’、’6’、’7’，占用5个字节，如图：

二进制文件按照二进制码的编码方式来存放文件。例如，数字32767的存储形式为0111111111111111，只占两个字节，如图9-1。它节省了空间与转换时间，读写效率高，但不能直接输出字符。因此，作为中间数据暂时保存在磁盘上，之后又要输入到内存的数据，常用二进制文件保存。

然而，C语言在系统在处理这些文件时，并不区分文件类型，而是将数据看作是字节流，不考虑记录的界限。即C文件输入/输出数据流的开始和结束仅受程序控制而不受物理符号（如回车换行符）控制，在输出时不会自动增加回车换行符以作为记录结束的标志，输入时也不以回车换行符作为记录的间隔（C文件不由记录构成）。因此，也把这种文件称为流式文件。C语言允许对文件存取一个字符，增加了处理的灵活性。
```

### 3).文件系统

```
在C语言中，根据操作系统对文件的处理方式不同，文件系统分为 “缓冲文件系统”和“非缓冲文件系统”。ANSI C规定采用缓冲文件系统。

缓冲文件系统（又称标准I/O）是指操作系统自动在内存中为每个正在使用的文件开辟一个文件缓冲区。从计算机内存向磁盘输出数据必须先送到缓冲区，待缓冲区装满后才一起送到磁盘。类似的，如果从磁盘读入数据到计算机内存，则一次从磁盘文件将一批数据输入到内存缓冲区，然后再从缓冲区逐个地将数据送到程序数据区，赋给程序变量，如图：
```

![image-20240703141840855](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/image-20240703141840855.png)

```
缓冲区的大小由各个具体的C编译系统确定。缓冲文件系统解决了高速CPU与低速磁盘之间的数据读写问题，既提高了外村的使用寿命，也提高了整个系统的效率。

非缓冲文件系统（又称系统I/O）是指系统不自动开辟确定大小的内存缓冲区，而由各个程序分别为每个文件设定缓冲区。

标准I/O与系统I/O分别采用不同的输入输出函数对文件进行操作。由于ANSI C只采用缓冲文件系统，因此本章讨论的均为处理标准I/O的函数。
```

### 4).文件制造

如果要调用磁盘上的一个文件，则必须知道与该文件有关的信息，如文件名、文件的当前读写位置、文件缓冲区大小与位置、文件的操作方式等。

这些信息被C语言系统保存在一个称为FILE的结构体中，它是在头文件stdio.h中定义的，其文件类型声明为：

```c
typedef struct
{
int                    level;          /* 缓冲区“满”或“空”的程度 */
unsigned          flags;          /* 文件状态标志 */
char                 fd;               /* 文件描述符 */
unsigned char  hold;           /* 如无缓冲区，则不读取字符 */
int                    bsize;          /* 缓冲区大小 */
unsigned char  *buffer;       /* 数据缓冲区位置 */
unsigned char  *curp;          /* 文件定位指针 */
unsigned          istemp;        /* 临时文件指示器 */
short                 token;         /* 用于有效性检查 */
} FILE;
```

有了结构体FILE类型之后，可以用它来定义若干个FILE类型的变量，以便存放若干个文件的信息。例如：

```c
FILE f[4];
```

定义了一个结构体数组f，它有4个元素，可以用来存放4个文件的信息。对于每一个要操作的文件，都必须定义一个指针变量，并使它指向该文件的结构体变量，从而通过该结构体变量中的文件信息访问该文件。这个指针称为文件指针。通过文件指针，可找到被操作文件的描述信息，就可以对该文件指针所指向的文件进行各种操作。声明文件指针的一般形式为：

```c
FILE  * 指针变量标识符 ;
```

## 2.文件的基本操作

### 1).打开文件

打开文件是指建立用户程序与文件的联系，为文件开辟文件缓冲区，使文件指针指向该文件，以便进行其他操作。关闭文件是指切断文件与用户程序的联系，将文件缓冲区的内容写入磁盘，并释放文件缓冲区，禁止再对该文件进行操作。

文件在进行读写操作之前要先打开，使用完毕要关闭。

所谓打开文件，实际上是建立文件的各种有关信息，并使文件指针指向该文件，以便进行其它操作。ANSI C规定了用标准I/O函数fopen函数来实现文件的打开。fopen函数的调用方式一般为：

```c
FILE   * 文件指针名 ;
文件指针名 = fopen（ 文件名，使用文件方式 ）;
```

**注意：**

```
（1）“文件指针名”必须是被说明为FILE 类型的指针变量。
（2）“文件名”是被打开文件的文件名。必须是一个字符串常量组成的有效文件名，可能包含关于文件位置的信息，例如驱动器号或路径。
（3）“使用文件方式”是说明文件打开方式的字符串，以指定文件的类型和操作要求。
（4）函数返回值是文件首地址，显然文件指针指向了文件的首地址。
```

| **字符串** | **含义**                               |
| ---------- | -------------------------------------- |
| “r”        | 打开文件用于读                         |
| “w”        | 打开文件用于写(文件不需要存在)         |
| “a”        | 打开文件用于追加(文件不需要存在)       |
| “r+”       | 打开文件用于读和写，从文件头开始       |
| “w+”       | 打开文件用于读和写(如果文件存在就截去) |
| “a+”       | 打开文件用于读和写(如果文件存在就追加) |

| **字符串**     | **含义**                               |
| -------------- | -------------------------------------- |
| “rb”           | 打开文件用于读                         |
| “wb”           | 打开文件用于写(文件不需要存在)         |
| “ab”           | 打开文件用于追加(文件不需要存在)       |
| “r+b”或者“rb+” | 打开文件用于读和写，从文件头开始       |
| “w+b”或者“wb+” | 打开文件用于读和写(如果文件存在就截去) |
| “a+b”或者“ab+” | 打开文件用于读和写(如果文件存在就追加) |

### 2).关闭文件

文件使用完之后，一定要关闭文件，否则数据可能丢失。在关闭文件之前，先将缓冲区的数据输出到磁盘文件中，再释放文件指针变量。关闭文件后，文件指针变量不再指向该文件，即此后不能再通过该指针对其相连的文件进行读写操作。除非再次打开，使该指针变量重新指向该文件。用fclose函数关闭文件，其一般形式为：

```c
fclose ( 文件指针 ) ;
```

## 3.函数调用与参数传递**

```c
字符读写函数
    fgetc和fputc
    
字符串读写函数
    fgets和fputs
数据块读写函数
    freed和fwrite
    
格式化读写函数
    fscanf和fprinf
```

**注意：使用以上函数都要求包含头文件stdio.h**

### 1).文件的字符读写

字符读写函数是以字符(字节)为单位的读写函数。 每次可从文件读出或向文件写入一个字符。

```c
1. 读字符函数fgetc 
功能:
从“文件指针”所指向的文件中，读入一个字符，同时将读写位置指针向前移动1个字节（即指向下一个字符）。该函数无出错返回值。
    
调用的形式为：
字符变量 = fgetc ( 文件指针 ) ;

说明：
（1）在fgetc函数调用中，读取的文件必须是以读或读写方式打开的。
（2）读取字符的结果也可以不向字符变量赋值，例如：
		fgetc ( fp ) ;
     此时，读出的字符不能保存。
（3）在文件内部有一个位置指针。用来指向文件的当前读写字节。
在文件打开时，该指针总是指向文件的第一个字节。使用fgetc函数后，该位置指针将向后移动一个字节。因此可连续多次使用fgetc函数，读取多个字符。
应注意文件指针和文件内部的位置指针不是一回事。文件指针是指向整个文件的，须在程序中定义说明，只要不重新赋值，文件指针的值是不变的。
文件内部的位置指针用以指示文件内部的当前读写位置，每读写一次，该指针均向后移动，它不需在程序中定义说明，而是由系统自动设置的。
```

```c
2. 写字符函数fputc 
功能:
将字符数据输出到“文件指针”所指向的文件中去，同时将读写位置指针向前移动1个字节（即指向下一个写入位置）。如果输出成功，则函数返回值就是输出的字符数据；否则，返回一个符号常量EOF（其值在头文件stdio.h中，被定义为-1）。
    
函数调用的形式为：
fputc(字符数据，文件指针) ;

其中“字符数据”，既可以是字符常量，也可以是字符变量。

说明：
（1）被写入的文件可以用写、读写、追加方式打开，用写或读写方式打开一个已存在的文件时将清除原有的文件内容，写入字符从文件首开始。如需保留原有文件内容，希望写入的字符以文件末开始存放，必须以追加方式打开文件。被写入的文件若不存在，则创建该文件。
（2）每写入一个字符，文件内部位置指针向后移动一个字节。
```

### 2).文件的字符串读写

```
1. 读字符函数fgets 
功能:
从指定文件读入一个字符串，该文件必须是以读或读写方式打开的。操作成功时，返回str的值；若发生错误或到达文件尾时，则返回一个空指针NULL。

函数调用的形式为：
fgets ( str , n , fp ) ;
其中，参数str一般是作为缓冲区使用的字符型数组名，即为读取到的字符串的内存地址；参数n为读取字符的个数；参数fp为要读取文件的指针。

说明：
（1）该函数从fp指定的文件中读取一个字符串。当达到下列条件之一时，读取结束：已经读取了n-1个字符；当前读取到的字符为回车符；已读取到文件末尾。
（2）使用该函数时，从文件读取的字符个数不会超过n-1个，这是由于在字符串尾部还需自动追加一个'\0'字符，这样读取到的字符串在内存缓冲区正好占有n个字节。
（3）如果从文件中读取到回车符时，也作为一个字符送入由str所指的内存缓冲区，然后再向缓冲区送入一个'\0'字符。
```

```
2. 写字符函数fputs 
功能:
把一个字符串输出到磁盘文件上。如果操作成功,返回值为所输出的字符串中最后一个字符的ASCII值；否则，返回值为EOF。

函数调用的形式为：
fputs(str, fp);
其中，str可以是指向字符串的指针或字符数组名，也可以是字符串常量；fp为指向写入文件的指针。

说明：
(1) 该函数的功能是将由str指定的字符串写入fp所指向的文件中。
(2) 与fgets( )函数在输入字符串时末尾自动追加'\0'字符的特性相对应，fputs( )函数在将字符串写入文件时，其末尾的'\0'字符自动舍去。
```

### 3).文的数据块读写

```c
1. fread函数 
功能:
从指定文件中读取一个指定字节的数据块。从 fp 所指向文件的当前位置开始，一次读入size个字节，重复count次，并将读入的数据存放到从buffer开始的内存中；同时，将读写位置指针向前移动size*count个字节。函数操作成功时，返回实际读取的字段个数count（不是字节数）；到达文件尾或出现错误时，返回值小于count。

函数调用的形式为：
fread ( buf , size , count , fp ) ;
其中，buf为读入数据在内存中存放的起始地址；size为每次要读取的字符数；count为要读取的次数；fp为文件类型指针。
```

```c
2. fwrite函数 
功能:
从buffer开始，一次输出size个字节，重复count次，并将输出的数据存放到fp所指向的文件中；同时，将读写位置指针向前移动size*count个字节。函数操作成功时，返回实际所写的字段个数count（不是字节数）；返回值小于count，说明发生了错误。

函数调用的形式为：
fwrite ( buf , size , count , fp ) ;
其中，buf为输出数据在内存中存放的首地址；size为每次要输出到文件中的字节数；count为要输出的次数；fp为文件类型指针。
```



### 4）文件的格式化输入输出函数fscanf和fprintf

```c
同样，用以下fscanf函数可以从磁盘文件上读取ASCII码字符：
fprintf函数、fscanf函数与printf函数、scanf函数的作用相仿，都是格式化读写函数。只有一点不同：fprintf和fscanf函数的读写对象不是终端而是磁盘文件。这种函数的一般调用方式为：
        fprintf ( 文件指针 , 格式控制字符串 , 输出项表列 ) ;
        fscanf ( 文件指针 , 格式控制字符串 , 输入项表列 ) ;

fprintf函数操作成功，返回实际被写的字符个数；出现错误时，返回一个负数。fscanf函数操作成功，返回实际被赋值的参数个数；若返回EOF，则表示试图去读取超过文件末尾的部分。
        fscanf ( fp , " %d , %f " , &i , &t ) ;
```

### 5).文件的定位

```
1. fseek函数 
功能:
将文件位置指针移到由起始位置开始、位移量为offset的字节处

函数调用的形式为：
fseek ( fp , offset , from ) ;
fp:指向当前文件的指针；
offset:文件位置指针的位移量，指以起始位置为基准值向前移动的字节数，并要求offset为long型数据；
from:指针的起始位置，其值必须是0、1、2之一，它们分别表示在stdio.h中定义的三个符号常量，

如表9-4所示：
```

| **起始位置** | **符号常量** | 数值 |
| ------------ | ------------ | ---- |
| 文件起始处   | SEEK_SET     | 0    |
| 文件当前位置 | SEEK_COR     | 1    |
| 文件末尾处   | SEEK_END     | 2    |

##### 注意

```
通常情况下，fseek函数返回零。如果产生错误(例如：要求的位置不存在)，那么fseek函数就会返回非零值。
offset为负数时，表示向文件头方向移动（也称后移）；offset为正数时，表示向文件尾方向移动（也称前移）。
```

##### 举例

```c
fseek ( fp , 20L , 0 ) ; 	/* 将文件位置指针从文件头向文件尾移动20个字节 */
fseek ( fp , -30L , 1 ) ;       /* 将文件位置指针从当前位置向文件头移动30个字节 */
fseek ( fp , -10L , SEEK_END ) ; /*将文件位置指针从文件尾向文件头移动10个字节*/
```

```c
2. ftell函数 
功能：
以长整型返回当前文件位置。用相对于文件开头的位移量来表示。由于文件中的位置指针经常移动，人们往往不容易辨清其当前位置。

函数调用的形式为：
ftell ( fp ) ;

用ftell函数可以得到当前位置。函数返回值为长整型，如果发生错误，ftell函数会返回-1L（EOF）。ftell可能会存储返回的值并且稍后将其提供给fseek函数的调用，这也使返回前一个文件位置成为可能：
        long int file_pos;
        file_pos=ftell(fp);
        fseek (fp, file_pos, SEEK_SET);
```

```c
3. rewind函数 
功能：
将文件指针fp所指向的文件内部的位置指针移动至文件的开始处，调用rewind (fp) 函数几乎等价于fseek (fp, 0L, SEEK_SET)，两者的差异是rewind函数不返回值，但是会为fp清除掉错误指示器。
    
函数调用的形式为：
rewind ( fp ) ;
```

### 6).文件的出错检测与处理

在磁盘的输入、输出操作中，可能会出现各种各样的错误。例如，磁盘介质的缺陷或磁盘驱动器未准备就绪或引用文件的路径不正确都会造成文件读写的错误。为了避免出错，C语言又提供了几个用于检查、处理文件读写错误的函数。

```c
1. ferror函数 
功能：
测试文件操作是否有错误，若返回零值表示正确，否则表示出错
    
函数调用的形式为：
ferror ( fp ) ;

说明：调用fopen函数时，ferror的函数初值自动置为0。
对同一个文件，每次调用ferror函数都会产生一个新的ferror函数值与之对应，因此对文件每执行一次读、写操作以后，应及时检查ferror的函数值是否正确，以避免数据丢失。
```

```c
2. clearerr函数 
功能：
使由指针fp指向的文件出错标志连同文件结束标志一起复位成0。

函数调用的形式为：
clearerr ( fp ) ;

说明：
若对文件读写时出现了错误，ferror函数就返回一个非零值，而且该值一直保留到对文件执行下一次读、写为止。若及时调用本函数就能清除出错标志，使ferror的函数值复位为0。
```

```c
3. exit函数 
当文件操作出现错误时，为了避免数据丢失，正常返回操作系统，可以调用本函数关闭文件，终止程序的执行。

功能：
清除并关闭所有已打开的文件，写出文件缓冲区的所有数据，程序按正常情况由main函数结束并返回操作系统。
    
函数调用的形式为：
exit ( status ) ;

说明：
参数status为状态值，它被传递到调用函数。按照惯例，若status取零值，表示程序正常终止，否则表示有错误而终止。
```

```
4. feof函数 
功能：
在执行读文件操作时，如果遇到文件尾，则函数返回1；否则返回0。

函数调用的形式为：
feof ( fp ) ;
```

# 七.ASCII

## 1.基本ASCII码

前128个称为基本**ASCII码**，从二进制角度来看，它们的最高位bit[7]=0，只使用了低7位bit[6,0]来进行编码。
0~31 之间的**ASCII码**常用于控制像打印机一样的外围设备。

| 十进制 DEC | 八进制 OCT | 十六进制 HEX | 二进制 BIN | 符号 Symbol | 中文解释 Description |
| :--------: | :--------: | :----------: | :--------: | :---------: | :------------------: |
|     0      |    000     |      00      |  00000000  |     NUL     |    空字符 终止符     |
|     1      |    001     |      01      |  00000001  |     SOH     |       标题开始       |
|     2      |    002     |      02      |  00000010  |     STX     |       正文开始       |
|     3      |    003     |      03      |  00000011  |     ETX     |       正文结束       |
|     4      |    004     |      04      |  00000100  |     EOT     |       传输结束       |
|     5      |    005     |      05      |  00000101  |     ENQ     |         询问         |
|     6      |    006     |      06      |  00000110  |     ACK     |       收到通知       |
|     7      |    007     |      07      |  00000111  |     BEL     |          铃          |
|     8      |    010     |      08      |  00001000  |     BS      |         退格         |
|     9      |    011     |      09      |  00001001  |     HT      |      水平制表符      |
|     10     |    012     |      0A      |  00001010  |     LF      |      换行符 \n       |
|     11     |    013     |      0B      |  00001011  |     VT      |      垂直制表符      |
|     12     |    014     |      0C      |  00001100  |     FF      |        换页符        |
|     13     |    015     |      0D      |  00001101  |     CR      |      回车符 \r       |
|     14     |    016     |      0E      |  00001110  |     SO      |         移出         |
|     15     |    017     |      0F      |  00001111  |     SI      |         移入         |
|     16     |    020     |      10      |  00010000  |     DLE     |     数据链路转义     |
|     17     |    021     |      11      |  00010001  |     DC1     |      设备控制 1      |
|     18     |    022     |      12      |  00010010  |     DC2     |      设备控制 2      |
|     19     |    023     |      13      |  00010011  |     DC3     |      设备控制 3      |
|     20     |    024     |      14      |  00010100  |     DC4     |      设备控制 4      |
|     21     |    025     |      15      |  00010101  |     NAK     |       拒绝接收       |
|     22     |    026     |      16      |  00010110  |     SYN     |       同步空闲       |
|     23     |    027     |      17      |  00010111  |     ETB     |      传输块结束      |
|     24     |    030     |      18      |  00011000  |     CAN     |         取消         |
|     25     |    031     |      19      |  00011001  |     EM      |       介质中断       |
|     26     |    032     |      1A      |  00011010  |     SUB     |         替换         |
|     27     |    033     |      1B      |  00011011  |     ESC     |        换码符        |
|     28     |    034     |      1C      |  00011100  |     FS      |      文件分隔符      |
|     29     |    035     |      1D      |  00011101  |     GS      |       组分隔符       |
|     30     |    036     |      1E      |  00011110  |     RS      |      记录分离符      |
|     31     |    037     |      1F      |  00011111  |     US      |      单元分隔符      |

十进制 32~127 区间一共 **127-32+1=96** 个ASCII码表示的符号，在我们的键盘上都可以被找到。其中：32表示空格，127表示删除命令。

| 十进制 DEC | 八进制 OCT | 十六进制 HEX | 二进制 BIN | 符号 Symbol | 中文解释 Description |
| :--------: | :--------: | :----------: | :--------: | :---------: | :------------------: |
|     32     |    040     |      20      |  00100000  |             |         空格         |
|     33     |    041     |      21      |  00100001  |      !      |        感叹号        |
|     34     |    042     |      22      |  00100010  |      "      |        双引号        |
|     35     |    043     |      23      |  00100011  |      #      |         井号         |
|     36     |    044     |      24      |  00100100  |      $      |        美元符        |
|     37     |    045     |      25      |  00100101  |      %      |        百分号        |
|     38     |    046     |      26      |  00100110  |      &      |          与          |
|     39     |    047     |      27      |  00100111  |      '      |        单引号        |
|     40     |    050     |      28      |  00101000  |      (      |        左括号        |
|     41     |    051     |      29      |  00101001  |      )      |        右括号        |
|     42     |    052     |      2A      |  00101010  |      *      |         星号         |
|     43     |    053     |      2B      |  00101011  |      +      |         加号         |
|     44     |    054     |      2C      |  00101100  |      ,      |         逗号         |
|     45     |    055     |      2D      |  00101101  |      -      |     连字号或减号     |
|     46     |    056     |      2E      |  00101110  |      .      |     句点或小数点     |
|     47     |    057     |      2F      |  00101111  |      /      |         斜杠         |
|     48     |    060     |      30      |  00110000  |      0      |          0           |
|     49     |    061     |      31      |  00110001  |      1      |          1           |
|     50     |    062     |      32      |  00110010  |      2      |          2           |
|     51     |    063     |      33      |  00110011  |      3      |          3           |
|     52     |    064     |      34      |  00110100  |      4      |          4           |
|     53     |    065     |      35      |  00110101  |      5      |          5           |
|     54     |    066     |      36      |  00110110  |      6      |          6           |
|     55     |    067     |      37      |  00110111  |      7      |          7           |
|     56     |    070     |      38      |  00111000  |      8      |          8           |
|     57     |    071     |      39      |  00111001  |      9      |          9           |
|     58     |    072     |      3A      |  00111010  |      :      |         冒号         |
|     59     |    073     |      3B      |  00111011  |      ;      |         分号         |
|     60     |    074     |      3C      |  00111100  |      <      |         小于         |
|     61     |    075     |      3D      |  00111101  |      =      |         等号         |
|     62     |    076     |      3E      |  00111110  |      >      |         大于         |
|     63     |    077     |      3F      |  00111111  |      ?      |         问号         |
|     64     |    100     |      40      |  01000000  |      @      |     电子邮件符号     |
|     65     |    101     |      41      |  01000001  |      A      |      大写字母 A      |
|     66     |    102     |      42      |  01000010  |      B      |      大写字母 B      |
|     67     |    103     |      43      |  01000011  |      C      |      大写字母 C      |
|     68     |    104     |      44      |  01000100  |      D      |      大写字母 D      |
|     69     |    105     |      45      |  01000101  |      E      |      大写字母 E      |
|     70     |    106     |      46      |  01000110  |      F      |      大写字母 F      |
|     71     |    107     |      47      |  01000111  |      G      |      大写字母 G      |
|     72     |    110     |      48      |  01001000  |      H      |      大写字母 H      |
|     73     |    111     |      49      |  01001001  |      I      |      大写字母 I      |
|     74     |    112     |      4A      |  01001010  |      J      |      大写字母 J      |
|     75     |    113     |      4B      |  01001011  |      K      |      大写字母 K      |
|     76     |    114     |      4C      |  01001100  |      L      |      大写字母 L      |
|     77     |    115     |      4D      |  01001101  |      M      |      大写字母 M      |
|     78     |    116     |      4E      |  01001110  |      N      |      大写字母 N      |
|     79     |    117     |      4F      |  01001111  |      O      |      大写字母 O      |
|     80     |    120     |      50      |  01010000  |      P      |      大写字母 P      |
|     81     |    121     |      51      |  01010001  |      Q      |      大写字母 Q      |
|     82     |    122     |      52      |  01010010  |      R      |      大写字母 R      |
|     83     |    123     |      53      |  01010011  |      S      |      大写字母 S      |
|     84     |    124     |      54      |  01010100  |      T      |      大写字母 T      |
|     85     |    125     |      55      |  01010101  |      U      |      大写字母 U      |
|     86     |    126     |      56      |  01010110  |      V      |      大写字母 V      |
|     87     |    127     |      57      |  01010111  |      W      |      大写字母 W      |
|     88     |    130     |      58      |  01011000  |      X      |      大写字母 X      |
|     89     |    131     |      59      |  01011001  |      Y      |      大写字母 Y      |
|     90     |    132     |      5A      |  01011010  |      Z      |      大写字母 Z      |
|     91     |    133     |      5B      |  01011011  |      [      |       左中括号       |
|     92     |    134     |      5C      |  01011100  |      \      |        反斜杠        |
|     93     |    135     |      5D      |  01011101  |      ]      |       右中括号       |
|     94     |    136     |      5E      |  01011110  |      ^      |       音调符号       |
|     95     |    137     |      5F      |  01011111  |      _      |        下划线        |
|     96     |    140     |      60      |  01100000  |      `      |        重音符        |
|     97     |    141     |      61      |  01100001  |      a      |      小写字母 a      |
|     98     |    142     |      62      |  01100010  |      b      |      小写字母 b      |
|     99     |    143     |      63      |  01100011  |      c      |      小写字母 c      |
|    100     |    144     |      64      |  01100100  |      d      |      小写字母 d      |
|    101     |    145     |      65      |  01100101  |      e      |      小写字母 e      |
|    102     |    146     |      66      |  01100110  |      f      |      小写字母 f      |
|    103     |    147     |      67      |  01100111  |      g      |      小写字母 g      |
|    104     |    150     |      68      |  01101000  |      h      |      小写字母 h      |
|    105     |    151     |      69      |  01101001  |      i      |      小写字母 i      |
|    106     |    152     |      6A      |  01101010  |      j      |      小写字母 j      |
|    107     |    153     |      6B      |  01101011  |      k      |      小写字母 k      |
|    108     |    154     |      6C      |  01101100  |      l      |      小写字母 l      |
|    109     |    155     |      6D      |  01101101  |      m      |      小写字母 m      |
|    110     |    156     |      6E      |  01101110  |      n      |      小写字母 n      |
|    111     |    157     |      6F      |  01101111  |      o      |      小写字母 o      |
|    112     |    160     |      70      |  01110000  |      p      |      小写字母 p      |
|    113     |    161     |      71      |  01110001  |      q      |      小写字母 q      |
|    114     |    162     |      72      |  01110010  |      r      |      小写字母 r      |
|    115     |    163     |      73      |  01110011  |      s      |      小写字母 s      |
|    116     |    164     |      74      |  01110100  |      t      |      小写字母 t      |
|    117     |    165     |      75      |  01110101  |      u      |      小写字母 u      |
|    118     |    166     |      76      |  01110110  |      v      |      小写字母 v      |
|    119     |    167     |      77      |  01110111  |      w      |      小写字母 w      |
|    120     |    170     |      78      |  01111000  |      x      |      小写字母 x      |
|    121     |    171     |      79      |  01111001  |      y      |      小写字母 y      |
|    122     |    172     |      7A      |  01111010  |      z      |      小写字母 z      |
|    123     |    173     |      7B      |  01111011  |      {      |       左大括号       |
|    124     |    174     |      7C      |  01111100  |     \|      |        垂直线        |
|    125     |    175     |      7D      |  01111101  |      }      |       右大括号       |
|    126     |    176     |      7E      |  01111110  |      ~      |        波浪号        |
|    127     |    177     |      7F      |  01111111  |             |         删除         |

## 2.扩展ASCII码

后128个称为扩展**ASCII码**。许多基于x86的系统都支持使用扩展（或“高”）**ASCII**。扩展**ASCII码**允许将每个字符的第8 位用于确定附加的128 个特殊符号字符、外来语字母和图形符号。

| 十进制 DEC | 八进制 OCT | 十六进制 HEX | 二进制 BIN | 符号 Symbol |        中文解释 Description         |
| :--------: | :--------: | :----------: | :--------: | :---------: | :---------------------------------: |
|    128     |    200     |      80      |  10000000  |      €      |              欧盟符号               |
|    129     |    201     |      81      |  10000001  |             |                                     |
|    130     |    202     |      82      |  10000010  |      ‚      |             单低 9 引号             |
|    131     |    203     |      83      |  10000011  |      ƒ      |        带钩的 拉丁小写字母f         |
|    132     |    204     |      84      |  10000100  |      „      |             双低 9 引号             |
|    133     |    205     |      85      |  10000101  |      …      |             水平省略号              |
|    134     |    206     |      86      |  10000110  |      †      |                剑号                 |
|    135     |    207     |      87      |  10000111  |      ‡      |               双剑号                |
|    136     |    210     |      88      |  10001000  |      ˆ      |         修正字符 抑扬音符号         |
|    137     |    211     |      89      |  10001001  |      ‰      |               千分号                |
|    138     |    212     |      8A      |  10001010  |      Š      |      带弯音号的 拉丁大写字母 S      |
|    139     |    213     |      8B      |  10001011  |      ‹      |             左单书名号              |
|    140     |    214     |      8C      |  10001100  |      Œ      |           拉丁大写组合 OE           |
|    141     |    215     |      8D      |  10001101  |             |                                     |
|    142     |    216     |      8E      |  10001110  |      Ž      |      带弯音号的 拉丁大写字母 z      |
|    143     |    217     |      8F      |  10001111  |             |                                     |
|    144     |    220     |      90      |  10010000  |             |                                     |
|    145     |    221     |      91      |  10010001  |      ‘      |              左单引号               |
|    146     |    222     |      92      |  10010010  |      ’      |              右单引号               |
|    147     |    223     |      93      |  10010011  |      “      |              左双引号               |
|    148     |    224     |      94      |  10010100  |      ”      |              右双引号               |
|    149     |    225     |      95      |  10010101  |      •      |                                     |
|    150     |    226     |      96      |  10010110  |      –      |             半长破折号              |
|    151     |    227     |      97      |  10010111  |      —      |             全长破折号              |
|    152     |    230     |      98      |  10011000  |      ˜      |              小波浪线               |
|    153     |    231     |      99      |  10011001  |      ™      |                                     |
|    154     |    232     |      9A      |  10011010  |      š      |      带弯音号的 拉丁小写字母 s      |
|    155     |    233     |      9B      |  10011011  |      ›      |             右单书名号              |
|    156     |    234     |      9C      |  10011100  |      œ      |           拉丁小写组合 oe           |
|    157     |    235     |      9D      |  10011101  |             |                                     |
|    158     |    236     |      9E      |  10011110  |      ž      |      带弯音号的 拉丁小写字母 z      |
|    159     |    237     |      9F      |  10011111  |      Ÿ      |      带弯音号的 拉丁大写字母 Y      |
|    160     |    240     |      A0      |  10100000  |             |                                     |
|    161     |    241     |      A1      |  10100001  |      ¡      |             反向感叹号              |
|    162     |    242     |      A2      |  10100010  |      ¢      |              分币符号               |
|    163     |    243     |      A3      |  10100011  |      £      |              英磅符号               |
|    164     |    244     |      A4      |  10100100  |      ¤      |                                     |
|    165     |    245     |      A5      |  10100101  |      ¥      |             人民币符号              |
|    166     |    246     |      A6      |  10100110  |      ¦      |                                     |
|    167     |    247     |      A7      |  10100111  |      §      |              章节符号               |
|    168     |    250     |      A8      |  10101000  |      ¨      |            通用货币符号             |
|    169     |    251     |      A9      |  10101001  |      ©      |              版权符号               |
|    170     |    252     |      AA      |  10101010  |      ª      |          阴性顺序 指示符号          |
|    171     |    253     |      AB      |  10101011  |      «      |              左角引号               |
|    172     |    254     |      AC      |  10101100  |      ¬      |                                     |
|    173     |    255     |      AD      |  10101101  |      ­      |                                     |
|    174     |    256     |      AE      |  10101110  |      ®      |                                     |
|    175     |    257     |      AF      |  10101111  |      ¯      |                                     |
|    176     |    260     |      B0      |  10110000  |      °      |              温度符号               |
|    177     |    261     |      B1      |  10110001  |      ±      |               加/减号               |
|    178     |    262     |      B2      |  10110010  |      ²      |               上标 2                |
|    179     |    263     |      B3      |  10110011  |      ³      |               上标 3                |
|    180     |    264     |      B4      |  10110100  |      ´      |                                     |
|    181     |    265     |      B5      |  10110101  |      µ      |               微符号                |
|    182     |    266     |      B6      |  10110110  |      ¶      |         段落符号， pilcrow          |
|    183     |    267     |      B7      |  10110111  |      ·      |                中点                 |
|    184     |    270     |      B8      |  10111000  |      ¸      |                                     |
|    185     |    271     |      B9      |  10111001  |      ¹      |               上标 1                |
|    186     |    272     |      BA      |  10111010  |      º      |           阳性顺序 指示符           |
|    187     |    273     |      BB      |  10111011  |      »      |              右角引号               |
|    188     |    274     |      BC      |  10111100  |      ¼      |            分数四分之一             |
|    189     |    275     |      BD      |  10111101  |      ½      |            分数二分之一             |
|    190     |    276     |      BE      |  10111110  |      ¾      |                                     |
|    191     |    277     |      BF      |  10111111  |      ¿      |              反向问号               |
|    192     |    300     |      C0      |  11000000  |      À      |        带重音符 的大写字母 A        |
|    193     |    301     |      C1      |  11000001  |      Á      |       带尖锐重音 的大写字母 A       |
|    194     |    302     |      C2      |  11000010  |      Â      |       带音调符号 的大写字母 A       |
|    195     |    303     |      C3      |  11000011  |      Ã      |        带代字号 的大写字母 A        |
|    196     |    304     |      C4      |  11000100  |      Ä      | 带元音变音 (分音符号) 的大写字母 A  |
|    197     |    305     |      C5      |  11000101  |      Å      |         带铃声 的大写字母 A         |
|    198     |    306     |      C6      |  11000110  |      Æ      |        大写字母 AE 双重元音         |
|    199     |    307     |      C7      |  11000111  |      Ç      |       带变音符号 的大写字母 C       |
|    200     |    310     |      C8      |  11001000  |      È      |        带重音符 的大写字母 E        |
|    201     |    311     |      C9      |  11001001  |      É      |       带尖锐重音 的大写字母 E       |
|    202     |    312     |      CA      |  11001010  |      Ê      |       带音调符号 的大写字母 E       |
|    203     |    313     |      CB      |  11001011  |      Ë      | 带元音变音 (分音符号) 的大写字母 E  |
|    204     |    314     |      CC      |  11001100  |      Ì      |        带重音符 的大写字母 I        |
|    205     |    315     |      CD      |  11001101  |      Í      |       带尖锐重音 的大写字母 I       |
|    206     |    316     |      CE      |  11001110  |      Î      |       带音调符号 的大写字母 I       |
|    207     |    317     |      CF      |  11001111  |      Ï      | 带元音变音 (分音符号) 的大写字母 I  |
|    208     |    320     |      D0      |  11010000  |      Ð      |                                     |
|    209     |    321     |      D1      |  11010001  |      Ñ      |        带代字号 的大写字母 N        |
|    210     |    322     |      D2      |  11010010  |      Ò      |        带重音符 的大写字母 O        |
|    211     |    323     |      D3      |  11010011  |      Ó      |       带尖锐重音 的大写字母 O       |
|    212     |    324     |      D4      |  11010100  |      Ô      |       带音调符号 的大写字母 O       |
|    213     |    325     |      D5      |  11010101  |      Õ      |        带代字号 的大写字母 O        |
|    214     |    326     |      D6      |  11010110  |      Ö      | 带元音变音 (分音符号) 的大写字母 O  |
|    215     |    327     |      D7      |  11010111  |      ×      |          大写字母 OE 连字           |
|    216     |    330     |      D8      |  11011000  |      Ø      |         带斜杠 的大写字母 O         |
|    217     |    331     |      D9      |  11011001  |      Ù      |        带重音符 的大写字母 U        |
|    218     |    332     |      DA      |  11011010  |      Ú      |       带尖锐重音 的大写字母 U       |
|    219     |    333     |      DB      |  11011011  |      Û      |       带音调符号 的大写字母 U       |
|    220     |    334     |      DC      |  11011100  |      Ü      | 带元音变音 (分音符号) 的大写字母 U  |
|    221     |    335     |      DD      |  11011101  |      Ý      | 带元音变音 (分音符号) 的大写字母 Y  |
|    222     |    336     |      DE      |  11011110  |      Þ      |                                     |
|    223     |    337     |      DF      |  11011111  |      ß      |         德语高调 小写字母 s         |
|    224     |    340     |      E0      |  11100000  |      à      |        带重音符 的小写字母 a        |
|    225     |    341     |      E1      |  11100001  |      á      |       带尖锐重音 的小写字母 a       |
|    226     |    342     |      E2      |  11100010  |      â      |       带音调符号 的小写字母 a       |
|    227     |    343     |      E3      |  11100011  |      ã      |        带代字号 的小写字母 a        |
|    228     |    344     |      E4      |  11100100  |      ä      | 带元音变音 (分音符号) 的小写字母 a  |
|    229     |    345     |      E5      |  11100101  |      å      |         带铃声的 小写字母 a         |
|    230     |    346     |      E6      |  11100110  |      æ      |        小写字母 ae 双重元音         |
|    231     |    347     |      E7      |  11100111  |      ç      |       带变音符号 的小写字母 c       |
|    232     |    350     |      E8      |  11101000  |      è      |        带重音符 的小写字母 e        |
|    233     |    351     |      E9      |  11101001  |      é      |       带尖锐重音 的小写字母 e       |
|    234     |    352     |      EA      |  11101010  |      ê      |       带音调符号 的小写字母 e       |
|    235     |    353     |      EB      |  11101011  |      ë      | 带元音变音 (分音符号) 的小写字母 e  |
|    236     |    354     |      EC      |  11101100  |      ì      |        带重音符 的小写字母 i        |
|    237     |    355     |      ED      |  11101101  |      í      |       带尖锐重音 的小写字母 i       |
|    238     |    356     |      EE      |  11101110  |      î      |       带音调符号 的小写字母 i       |
|    239     |    357     |      EF      |  11101111  |      ï      | 带元音变音 (分音符号) 的小写字母 i  |
|    240     |    360     |      F0      |  11110000  |      ð      |                                     |
|    241     |    361     |      F1      |  11110001  |      ñ      |        带代字号 的小写字母 n        |
|    242     |    362     |      F2      |  11110010  |      ò      |        带重音符 的小写字母 o        |
|    243     |    363     |      F3      |  11110011  |      ó      |       带尖锐重音 的小写字母 o       |
|    244     |    364     |      F4      |  11110100  |      ô      |       带音调符号 的小写字母 o       |
|    245     |    365     |      F5      |  11110101  |      õ      |        带代字号 的小写字母 o        |
|    246     |    366     |      F6      |  11110110  |      ö      | 带元音变音 (分音符号) 的小写字母 o  |
|    247     |    367     |      F7      |  11110111  |      ÷      |          小写字母 oe 连字           |
|    248     |    370     |      F8      |  11111000  |      ø      |         带斜杠 的小写字母 o         |
|    249     |    371     |      F9      |  11111001  |      ù      |        带重音符 的小写字母 u        |
|    250     |    372     |      FA      |  11111010  |      ú      |       带尖锐重音 的小写字母 u       |
|    251     |    373     |      FB      |  11111011  |      û      |       带音调符号 的小写字母 u       |
|    252     |    374     |      FC      |  11111100  |      ü      | 带元音变音 (分音符号) 的小写字母 u  |
|    253     |    375     |      FD      |  11111101  |      ý      | 带元音变音 (分音符号) 的小写字母 y2 |
|    254     |    376     |      FE      |  11111110  |      þ      |                                     |
|    255     |    377     |      FF      |  11111111  |      ÿ      |                                     |

# 八.C语言函数库

## 1. ctype.h

| 函数原型        | 功能                                |
| --------------- | ----------------------------------- |
| iscntrl(int c)  | 判断字符c是否为控制字符。           |
| isalnum(int c)  | 判断字符c是否为字母或数字           |
| isalpha(int c)  | 判断字符c是否为英文字母             |
| isascii(int c)  | 判断字符c是否为ascii码              |
| isblank(int c)  | 判断字符c是否为TAB或空格            |
| isdigit(int c)  | 判断字符c是否为数字                 |
| isgraph(int c)  | 判断字符c是否为除空格外的可打印字符 |
| islower(int c)  | 判断字符c是否为小写英文字母         |
| isprint(int c)  | 判断字符c是否为可打印字符（含空格） |
| ispunct(int c)  | 判断字符c是否为标点符号             |
| isspace(int c)  | 判断字符c是否为空白符               |
| isupper(int c)  | 判断字符c是否为大写英文字母         |
| isxdigit(int c) | 判断字符c是否为十六进制数字         |
| toascii(int c)  | 将字符c转换为ascii码                |
| tolower(int c)  | 将字符c转换为小写英文字母           |
| toupper(int c); | 将字符c转换为大写英文字母           |

## 2.math.h

| 函数原型                        | 功能                                             |
| ------------------------------- | ------------------------------------------------ |
| float fabs(float x)             | 求浮点数x的绝对值                                |
| int abs(int x)                  | 求整数x的绝对值                                  |
| float acos(float x)             | 求x（弧度表示）的反余弦值                        |
| float asin(float x)             | 求x（弧度表示）的反正弦值                        |
| float atan(float x)             | 求x（弧度表示）的反正切值                        |
| float atan2(float y, float x)   | 求y/x（弧度表示）的反正切值                      |
| float ceil(float x)             | 求不小于x的最小整数                              |
| float cos(float x)              | 求x（弧度表示）的余弦值                          |
| float cosh(float x)             | 求x的双曲余弦值                                  |
| float exp(float x)              | 求e的x次幂                                       |
| float floor(float x)            | 求不大于x的最大整数                              |
| float fmod(float x, float y)    | 计算x/y的余数                                    |
| float frexp(float x, int *exp)  | 把浮点数x分解成尾数和指数                        |
| float ldexp(float x, int exp)   | 返回x*2^exp的值                                  |
| float modf(float num, float *i) | 将浮点数num分解成整数部分和小数部分              |
| float hypot(float x, float y)   | 对于给定的直角三角形的两个直角边，求其斜边的长度 |
| float log(float x)              | 计算x的自然对数                                  |
| float log10(float x)            | 计算x的常用对数                                  |
| float pow(float x, float y)     | 计算x的y次幂                                     |
| float pow10(float x)            | 计算10的x次幂                                    |
| float sin(float x)              | 计算x（弧度表示）的正弦值                        |
| float sinh(float x)             | 计算x（弧度表示）的双曲正弦值                    |
| float sqrt(float x)             | 计算x的平方根                                    |
| float tan(float x);             | 计算x（弧度表示）的正切值                        |
| float tanh(float x)             | 求x的双曲正切值                                  |

## 3.stdio.h

| 函数原型                                                     | 功能                                     |
| ------------------------------------------------------------ | ---------------------------------------- |
| int printf(char *format...)                                  | 产生格式化输出的函数                     |
| int getchar(void)                                            | 从键盘上读取一个键，并返回该键的键值     |
| int putchar(char c)                                          | 在屏幕上显示字符c                        |
| FILE *fopen(char *filename, char *type)                      | 打开一个文件                             |
| FILE *freopen(char *filename, char  *type,FILE *fp)          | 打开一个文件，并将该文件关联到fp指定的流 |
| int fflush(FILE *stream)                                     | 清除一个流                               |
| int fclose(FILE *stream)                                     | 关闭一个文件                             |
| int remove(char *filename)                                   | 删除一个文件                             |
| int rename(char *oldname, char *newname)                     | 重命名文件                               |
| FILE *tmpfile(void)                                          | 以二进制方式打开暂存文件                 |
| char *tmpnam(char *sptr)                                     | 创建一个唯一的文件名                     |
| int setvbuf(FILE *stream, char *buf, int  type, unsigned size) | 把缓冲区与流相关                         |
| int fprintf(FILE *stream, char *format[,  argument,...])     | 传送格式化输出到一个流中                 |
| int scanf(char *format[,argument,...])                       | 执行格式化输入                           |
| int fscanf(FILE *stream, char  *format[,argument...])        | 从一个流中执行格式化输入                 |
| int fgetc(FILE *stream)                                      | 从流中读取字符                           |
| char *fgets(char *string, int n, FILE  *stream)              | 从流中读取一字符串                       |
| int fputc(int ch, FILE *stream)                              | 送一个字符到一个流中                     |
| int fputs(char *string, FILE *stream)                        | 送一个字符到一个流中                     |
| int getc(FILE *stream)                                       | 从流中取字符                             |
| int getchar(void)                                            | 从 stdin 流中读字符                      |
| char *gets(char *string)                                     | 从流中取一字符串                         |
| int putchar(int ch)                                          | 在 stdout 上输出字符                     |
| int puts(char *string)                                       | 送一字符串到流中                         |
| int ungetc(char c, FILE *stream)                             | 把一个字符退回到输入流中                 |
| int fread(void *ptr, int size, int  nitems, FILE *stream)    | 从一个流中读数据                         |
| int fwrite(void *ptr, int size, int  nitems, FILE *stream)   | 写内容到流中 int fseek                   |
| (FILE *stream, long offset, int  fromwhere)                  | 重定位流上的文件指针                     |
| long ftell(FILE *stream)                                     | 返回当前文件指针                         |
| int rewind(FILE *stream)                                     | 将文件指针重新指向一个流的开头           |
| int fgetpos(FILE *stream)                                    | 取得当前文件的句柄                       |
| int fsetpos(FILE *stream, const fpos_t  *pos)                | 定位流上的文件指针                       |
| void clearerr(FILE *stream)                                  | 复位错误标志                             |
| int feof(FILE *stream)                                       | 检测流上的文件结束符                     |
| int ferror(FILE *stream)                                     | 检测流上的错误                           |
| void perror(char *string)                                    | 系统错误信息                             |

## 4.stdlib.h

| 函数原型                                                     | 功能                                 |
| ------------------------------------------------------------ | ------------------------------------ |
| char *itoa(int i)                                            | 把整数i转换成字符串                  |
| void exit(int retval)                                        | 结束程序                             |
| double atof(const char *s)                                   | 将字符串s转换为double类型            |
| int atoi(const char *s)                                      | 将字符串s转换为int类型               |
| long atol(const char *s)                                     | 将字符串s转换为long类型              |
| double strtod (const char*s,char **endp)                     | 将字符串s前缀转换为double型          |
| long strtol(const char*s,char **endp,int  base)              | 将字符串s前缀转换为long型            |
| unsinged long strtol(const char*s,char  **endp,int base)     | 将字符串s前缀转换为  unsinged long型 |
| int rand(void)                                               | 产生一个0~RAND_MAX之间的伪随机数     |
| void srand(unsigned int seed)                                | 初始化随机数发生器                   |
| void *calloc(size_t nelem, size_t elsize)                    | 分配主存储器                         |
| void *malloc(unsigned size)                                  | 内存分配函数                         |
| void *realloc(void *ptr, unsigned  newsize)                  | 重新分配主存                         |
| void free(void *ptr)                                         | 释放已分配的块                       |
| void abort(void)                                             | 异常终止一个进程                     |
| void exit(int status)                                        | 终止应用程序                         |
| int atexit(atexit_t func)                                    | 注册终止函数                         |
| char *getenv(char *envvar)                                   | 从环境中取字符串                     |
| void *bsearch(const void *key, const void  *base, size_t *nelem, size_t width, int(*fcmp)(const void *, const *)) | 二分法搜索函数                       |
| void qsort(void *base, int nelem, int  width, int (*fcmp)()) | 使用快速排序例程进行排序             |
| int abs(int i)                                               | 求整数的绝对值                       |
| long labs(long n)                                            | 取长整型绝对值                       |
| div_t div(int number, int denom)                             | 将两个整数相除 , 返回商和余数        |
| ldiv_t ldiv(long lnumer, long ldenom)                        | 两个长整型数相除 , 返回商和余数      |

## 5.time.h

| 函数原型                                                     | 功能                                                    |
| ------------------------------------------------------------ | ------------------------------------------------------- |
| clock_t clock(void)                                          | 确定处理器时间函数                                      |
| time_t time(time_t *tp)                                      | 返回当前日历时间                                        |
| double difftime(time_t time2, time_t  time1)                 | 计算两个时刻之间的时间差                                |
| time_t mktime(struct tm *tp)                                 | 将分段时间值转换为日历时间值                            |
| char *asctime(const struct tm *tblock)                       | 转换日期和时间为ASCII码                                 |
| char *ctime(const time_t *time)                              | 把日期和时间转换为字符串                                |
| struct tm *gmtime(const time_t *timer)                       | 把日期和时间转换为格林尼治标准时间                      |
| struct tm *localtime(const time_t *timer)                    | 把日期和时间转变为结构                                  |
| size_t strftime(char *s,size_t smax,const  char *fmt, const struct tm *tp) | 根据 fmt 的格式 要求将  *tp中的日期与时间转换为指定格式 |

## 6.string.h

| 函数原型                                                     | 功能                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| int bcmp(const void *s1, const void *s2,  int n)             | 比较字符串s1和s2的前n个字节是否相等                          |
| void bcopy(const void *src, void *dest,  int n)              | 将字符串src的前n个字节复制到dest中                           |
| void bzero(void *s, int n)                                   | 置字节字符串s的前n个字节为零                                 |
| void *memccpy(void *dest, void *src,  unsigned char ch, unsigned int count) | 由src所指内存区域复制不多于count个字节到dest所指内存区域，如果遇到字符ch则停止复制 |
| void *memcpy(void *dest, void *src,  unsigned int count)     | 由src所指内存区域复制count个字节到dest所指内存区域           |
| void *memchr(void *buf, char ch, unsigned  count)            | 从buf所指内存区域的前count个字节查找字符ch                   |
| int memcmp(void *buf1, void *buf2,  unsigned int count)      | 比较内存区域buf1和buf2的前count个字节                        |
| int memicmp(void *buf1, void *buf2,  unsigned int count)     | 比较内存区域buf1和buf2的前count个字节但不区分字母的大小写    |
| void *memmove(void *dest, const void  *src, unsigned int count) | 由src所指内存区域复制count个字节到dest所指内存区域           |
| void *memset(void *buffer, int c, int  count)                | 把buffer所指内存区域的前count个字节设置成字符c               |
| void setmem(void *buf, unsigned int  count, char ch)         | 把buf所指内存区域前count个字节设置成字符ch                   |
| void movmem(void *src, void *dest,  unsigned int count)      | 由src所指内存区域复制count个字节到dest所指内存区域           |
| char *stpcpy(char *dest,char *src)                           | 把src所指由NULL结束的字符串复制到dest所指的数组中            |
| char *strcpy(char *dest,char *src)                           | 把src所指由NULL结束的字符串复制到dest所指的数组中            |
| char *strcat(char *dest,char *src)                           | 把src所指字符串添加到dest结尾处(覆盖dest结尾处的’\0’)并添加’\0’ |
| char *strchr(char *s,char c)                                 | 查找字符串s中首次出现字符c的位置                             |
| int strcmp(char *s1,char * s2)                               | 比较字符串s1和s2                                             |
| int stricmp(char *s1,char * s2)                              | 比较字符串s1和s2，但不区分字母的大小写                       |
| int stricmp(char *s1,char * s2)                              | 比较字符串s1和s2，但不区分字母的大小写                       |
| int strcspn(char *s1,char *s2)                               | 在字符串s1中搜寻s2中所出现的字符                             |
| char *strdup(char *s)                                        | 复制字符串s                                                  |
| int strlen(char *s)                                          | 计算字符串s的长度                                            |
| char *strlwr(char *s)                                        | 将字符串s转换为小写形式                                      |
| char *strupr(char *s)                                        | 将字符串s转换为大写形式                                      |
| char *strncat(char *dest,char *src,int n)                    | 把src所指字符串的前n个字符添加到dest结尾处(覆盖dest结尾处的’\0’)并添加’\0’ |
| int strcmp(char *s1,char * s2，int n)                        | 比较字符串s1和s2的前n个字符                                  |
| int strnicmp(char *s1,char * s2，int n)                      | 比较字符串s1和s2的前n个字符但不区分大小写                    |
| char *strncpy(char *dest, char *src, int  n)                 | 把src所指由NULL结束的字符串的前n个字节复制到dest所指的数组中 |
| char *strpbrk(char *s1, char *s2)                            | 在字符串s1中寻找字符串s2中任何一个字符相匹配的第一个字符的位置，空字符NULL不包括在内 |
| char *strrev(char *s)                                        | 把字符串s的所有字符的顺序颠倒过来（不包括空字符NULL）        |
| char *strset(char *s, char c)                                | 把字符串s中的所有字符都设置成字符c                           |
| char *strstr(char *haystack, char  *needle)                  | 从字符串haystack中寻找needle第一次出现的位置（不比较结束符NULL) |
| char *strtok(char *s, char *delim)                           | 分解字符串为一组标记串。s为要分解的字符串，delim为分隔符字符串 |

##  7.alloch

| 函数类别 | 函数原型                                    | 功能                                                        |
| -------- | ------------------------------------------- | ----------------------------------------------------------- |
| 内存分配 | void  *malloc( size_t size )                | 分配一个大小为size的内存空间。并返回首地址                  |
| 内存分配 | void  *realloc( void   *block, size_t size) | 改变已分配内存的大小，由指针biock所指内存空间大小更新为size |
| 内存分配 | void *calloc( unsigned num, unsigned size ) | 分配num个长度为size的内存空间并返回所分配内存的首地址       |
| 内存释放 | void free( void *ptr )<br/>                 | 释放由指针变量p所指的内存空间                               |
