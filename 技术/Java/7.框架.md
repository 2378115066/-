# 一、集合框架

## 1.概述

### 1).Java集合框架概述

在Java语言中，Java语言的设计者对常用的数据结构和算法做了一些规范（接口）和实现（具体实现接口的类）。所有抽象出来的数据结构和操作（算法）统称为Java集合框架（Java Collection Framework）。集合框架是一个用来代表和操纵集合的统一架构。

### 2).Java集合框架内容

Java集合框架包含如下内容：

```
接口，代表集合的抽象数据类型。例如 Collection、List、Set、Map 等。
实现（类），是集合接口的具体实现。
算法，是实现集合接口的对象里的方法执行的一些有用的计算。
```

Java 集合框架提供了一套性能优良、使用方便的接口和类，其类图如图2-1所示。所有的集合都位于**java.util**包下，后来为了处理多线程环境下的并发安全问题，java5还在java.util.concurrent包下提供了一些多线程支持的集合类和接口。

![clip_image002](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/Java/clip_image002.jpg)

从Java集合框架图上来看，主要有以下几个部分：

```
1）Collection是一个接口，是高度抽象出来的集合，它包含了集合的基本操作和属性。Collection包含了List和Set两大分支。
    a. List代表有序可重复集合，可直接根据元素的索引来访问。List的实现类有LinkedList, ArrayList, Vector, Stack等。
    b. Set代表无序不可重复集合，只能根据元素本身来访问。Set的实现类有HastSet和TreeSet。HashSet依赖于HashMap，它实际上是通过HashMap实现的；TreeSet依赖于TreeMap，它实际上是通过TreeMap实现的。

2）Map是一个映射接口，即key-value键值对，可根据元素的key来访问value。Map不是Collection的子接口。Map的实现类有HashMap，LinkedHashMap,TreeMap等。

3）Iterator接口，即迭代器，它是遍历集合的工具，通常通过Iterator迭代器来遍历集合。ListIterator是专门为遍历List而存在的。

4）工具类Arrays和Collections。它们是操作数组、集合的工具。

5）Comparable是排序接口，Comparator是比较器接口。
```

### 3).Java集合框架适用场合

```
涉及到“栈”、“队列”、“链表”等操作时，应该考虑用List集合。
当需要存储唯一元素时，使用Set集合。
当存储的信息是键值对形式的时候，采用Map集合。
```

## 2.List接口

### 1).List接口概述

java.util.List接口继承自Collection接口，用于定义以列表形式存储的集合，List接口为集合中的每个对象分配了一个索引(index)，标记该对象在List中的位置，并可以通过index定位到指定位置的对象。List接口是单列集合的一个重要分支。人们习惯性地将实现了List接口的对象称为List集合。

List接口有如下的特点：

```
List集合中允许出现重复的元素。
List集合中所有的元素是以线性方式进行存储的。
List集合中的元素可以通过索引（顺序号：元素在集合中处于的位置信息）来访问。
List集合中的元素是有序的，即元素的存入顺序和取出顺序一致。
```

### 2). List接口的实现类

#### a.List接口的主要实现类

```
List接口的实现类主要有ArrayList，LinkedList，Vector，Stack等。

							   ArrayList
ArrayList是基于数组实现的非线程安全的集合。ArrayList集合中的元素可以重复，有序集合，可以通过其位置索引取得。ArrayList实现了Serializable接口，支持序列化。
其特点是元素增删慢，查找快。
ArrayList适合于经常查询数据、遍历数据的场合，是最常用的集合。由于ArrayList是线程不安全的，建议在单线程中使用。

							   LinkedList
LinkedList是基于链表实现的非线程安全的集合。LinkedList实现了Serializable接口，支持序列化。
其特点是元素增删快，查找慢
LinkedList适合于经常添加元素、删除元素的场合。在开发时，LinkedList集合也可以作为堆栈，队列或双端队列的结构使用

							   Vector
Vector是基于数组实现，是一个矢量队列。Vector实现了Serializable接口，表示支持序列化。Vectot的操作是线程安全的，建议使用在多线程操作中，在单线程中效率没有使用ArrayList高。

							   Stack
Stack是栈，它继承于Vector。它的特性是先进后出(FILO, First In Last Out)。
```

#### b.List接口的主要实现类的比较

```
List是一个"线性表接口"，ArrayList(基于数组的线性表)、LinkedList(基于链的线性表)是线性表的两种典型实现。内部以数组作为底层实现的集合在随机访问时性能最好。内部以链表作为底层实现的集合在执行插入、删除操作时有很好的性能。进行迭代操作时，以链表作为底层实现的集合比以数组作为底层实现的集合性能好。

ArrayList是一个数组，查询效率快，但是插入删除效率低，这是由于数组的特性决定的。LinkedList双链表，查询效率低，但是插入删除效率高，这是由于链表的特性决定的。Vector同ArrayList相似，只不过Vector是线程安全的。Stack继承Vector，有着先进后出的特性。
```

#### c.List主要实现类的适用场景

```
ArrayList适用场景：
    适合在声明时不知道数据结构大小时
    适合需要快速随机查找和遍历
    不适合经常需要插入和删除操作

LinkedList适用场景：
    适合需要随机插入、随机删除效率要求比较高时
    可以作为队列和栈使用

Vector适用场景：
    适合在集合中使用大数据量时
    适合多线程环境，Vector是线程安全的

Stack适用场景：
    Stack继承于Vector，适合先进后出(FILO, First In Last Out)
```

### 3). ArrayList类

List接口的实现类有很多，这里只介绍ArrayList类。其他类的基本使用与ArrayList相似，更为详细的介绍请查阅Java API帮助文档。

####  a. ArrayList构造函数

| 方法名                               | 说明                                                         |
| ------------------------------------ | ------------------------------------------------------------ |
| ArrayList()                          | 构造一个初始容量为十的空列表。                               |
| ArrayList(Collection<? extends E> c) | 构造一个包含指定集合的元素的列表，按照它们由集合的迭代器返回的顺序。 |
| ArrayList(int initialCapacity)       | 构造具有指定初始容量的空列表。                               |

####  b.ArrayList常用方法

| 返回值类型 | 方法名                     | 说明                                                         |
| ---------- | -------------------------- | ------------------------------------------------------------ |
| boolean    | add(E e)                   | 将指定的元素添加到此list集合的尾部                           |
| void       | add(int  index, E element) | 将指定的元素插入此list集合中的指定位置                       |
| Object     | remove(int  index)         | 移除此list集合中指定位置上的元素                             |
| boolean    | remove(Object  o)          | 移除此list集合中首次出现的指定元素（如果存在）               |
| Object     | set(int  index,Object obj) | 用指定的元素替代此list集合中指定位置上的元素                 |
| Object     | get(int  index)            | 返回此list集合中指定位置上的元素                             |
| int        | indexOf(Object  obj)       | 返回此list集合中首次出现的指定元素的索引，或如果此list集合不包含元素，则返回  -1 |
| int        | lastIndexOf(Object  obj)   | 返回此list集合中最后一次出现的指定元素的索引，或如果此list集合不包含索引，则返回  -1 |

### 4).ArrayList一般用法

List是接口，在使用List集合时，通常使用其实现类通过new来创建一个List集合对象。由于List使用了泛型，在实例化时是需传递类型参数的。

```java
1）创建一个List 接口的对象。
// 使用ArrayList类实例化List集合  
List<Student> studentList = new  ArrayList<Student>();   // 使用ArrayList类实例化List集合  
List<Teacher> teacherList = new ArrayList  <Teacher>();   

2）向List集合中存值。
studentList.add(“张三”);  teacherList.set(1, “李四”);// 将索引位置为1的对象e修改  

3）使用增强for循环遍历List集合。
for(String stu: studentList){System.out.println(stu.toString());  }  
```

## 3.Set接口

### 1).概述

Set 接口是继承于Collection的接口，用于存储不含重复元素的集合。

Java中的Set接口有如下的特点：

```
不允许出现重复元素。
集合中的元素位置无顺序（存取和读取的顺序可能不一样）。
Set集合没有索引。
有且仅有一个值为null的元素。
```

### 2). Set接口的实现类

#### a.Set接口的实现类

```
Set接口的实现类主要有HashSet、LinkedHashSet、TreeSet。

1. HashSet
HashSet 基于HashMap实现的，其不允许有重复元素，但允许有 null 值，HashSet 也是无序的，即不会记录插入的顺序。HashSet 不是线程安全的， 如果多个线程尝试同时修改 HashSet，则最终结果是不确定的。
HashSet采用HashCode算法来存取集合中的元素，具有比较好的读取和查找性能；其通过equals和HashCode来判断两个元素是否相等。

2. LinkedHashSet
LinkedHashSet继承自HashSet，本质是LinkedHashMap实现的。LinkedHashSet是有序的，根据HashCode的值来决定元素的存储位置，同时使用一个链表来维护元素的插入顺序。LinkedHashSet是非线程安全。

3. TreeSet
TreeSet是一种排序的Set集合，实现了SortedSet接口，底层是用TreeMap实现的，本质上是一个红黑树原理。相对HashSet来说，TreeSet提供了一些额外的按排序位置访问元素的方法，例如first(), last(), lower(), higher(), subSet(), headSet(), tailSet()等。

TreeSet中的排序分两种：自然排序（存储元素实现Comparable接口）和定制排序（创建TreeSet时，传递一个自己实现的Comparator对象）
```

#### b.Set接口的主要实现类的比较

```
HashSet基于HashMap，所以其对数据的访问基本都是用HashMap的方法。LinkedHashSet是HashSet的一个扩展版本，HashSet是无序的，LinkedHashSet会维护“插入顺序”,TreeSet是有序的Set集合。

HashSet的性能总是比TreeSet好，特别是最常用的添加、查询元素等操作。只有当需要一个保持排序的Set时，才应该使用TreeSet，否则都应该使用HashSet。对于普通的插入、删除操作，LinkedHashSet比HashSet要略慢一点，这是由维护链表所带来的开销造成的。不过，因为有了链表的存在，遍历LinkedHashSet会更快。HashSet、TreeSet、EnumSet都是"线程不安全"的。
```



#### c.Set接口主要实现类的适用场景

```
HashSet用于基本的添加、查询元素，适用于数据去重的场景。
LinkedHashSet适用于存取顺序一致的场景。
TreeSet适用于数据需要去重，且数据按照特定大小进行排序的场景。
```

### 3). HashSet类

Set接口的实现类有很多，这里只介绍HashSet，其他实现类的使用方法同HashSet类似，更为详细的请查阅Java API帮助文档。

#### a. HashSet构造函数

| 方法名                                          | 说明                                                         |
| ----------------------------------------------- | ------------------------------------------------------------ |
| HashSet()                                       | 构造一个新的空集合; 背景`HashMap`实例具有默认初始容量（16）和负载因子（0.75）。 |
| HashSet(Collection<?  extends E> c)             | 构造一个包含指定集合中的元素的新集合。                       |
| HashSet(int initialCapacity)                    | 构造一个新的空集合; 背景`HashMap`实例具有指定的初始容量和默认负载因子（0.75）。 |
| HashSet(int initialCapacity,  float loadFactor) | 构造一个新的空集合; 背景HashMap实例具有指定的初始容量和指定的负载因子。 |

#### b. HashSet常用方法

|             |                    |                                                  |
| ----------- | ------------------ | ------------------------------------------------ |
| 返回值类型  | 方法名             | 说明                                             |
| boolean     | add(E e)           | 如果此 set  中尚未包含指定元素，则添加指定元素。 |
| void        | clear()            | 从此 set  中移除所有元素。                       |
| boolean     | contains(Object o) | 如果此 set  包含指定元素，则返回 true。          |
| boolean     | isEmpty()          | 如果此 set  不包含任何元素，则返回 true。        |
| Iterator<E> | iterator()         | 返回对此 set 中元素进行迭代的迭代器。            |
| boolean     | remove(Object o)   | 如果指定元素存在于此 set 中，则将其移除。        |
| int         | size()             | 返回此 set 中的元素的数量（set 的容量）。        |

### 4). HashSet的一般用法

```java
Set是接口，在使用Set集合时，通常使用其实现类通过new来创建一个Set集合对象。由于Set使用了泛型，在实例化时是需传递类型参数的。

1）创建HashSet类的对象。
HashSet<String> stringSet=new  HashSet<String>();  

2）添加元素。
stringSet.add("abc");  

3）删除元素。
stringSet.clear(); // 从此 set 中移除所有元素  stringSet.remove(Object o); //从此 set 中删除指定的元素  

4）遍历Set集合。
	方法1：使用**iterator****迭代遍历**
        Set<String> stringSet = new  HashSet<String>();  
        Iterator<String> it = stringSet.iterator();  
        while (it.hasNext()) {     
            String str = it.next();     
            System.out.println(str);  
        }  
	方法2：使用增强for循环。
        for(String s: stringSet){     
            System.out.println(s);  
        }  
```

## 4.Map接口

### 1). 概述

Map是一个映射接口，提供了一种映射关系。Map中的每一个元素包含一个“key”以及和key对应的“value”，即key-value键值对。Map将key和value封装至一个叫做Entry的对象中，Map中存储的元素实际是Entry。Entry保存每个key-value对，以实现通过key快速定位到对象(value)。只有在keySet()和values()方法被调用时，Map才会将keySet和values对象实例化。

```
Map中包含两种类型参数：
    K - 此映射所维护的键的类型
    V - 映射值的类型
```

```
Map接口的特点：
        Map集合是一个双列集合，一个元素包含两个值(一个key,一个value)。
        Map集合中的元素，key和value的数据类型可以相同，也可以不同。
        Map集合中的元素，key不允许重复，value可以重复。
        Map集合中的元素，key和value是一一对应的。
```

### 2). Map接口实现类

#### a. Map接口的实现类

```
Map接口的实现类常用的有HashMap、LinkedHashMap、Hashtable、TreeMap。

1. HashMap
HashMap采用哈希表存储结构，根据键的hashCode值存储数据，元素的存取顺序不能保证一致。大多数情况下可以直接定位到它的值，因而具有很快的访问速度。其特点是线程不安全，效率高。HashMap一般用于单线程程序中，鉴于它可以满足大多数场景的使用条件，所以是使用频度最高的一个。

2. LinkedHashMap
LinkedHashMap是HashMap的一个子类，其存储数据采用哈希表+双向链表结构。LinkedHashMap是元素唯一、且有序，由哈希表保证元素唯一，由链表保证元素有序，但是它的有序主要体现在先进先出FIFO上。LinkedHashMap适用于一些特定应用场景。

3. Hashtable
Hashtable是线程安全的一个Map实现类，它实现线程安全的方法是在各个方法上添加了synchronized关键字。但是现在已经不再推荐使用HashTable，不需要线程安全的场合可以用HashMap替换，需要线程安全的场合可以用ConcurrentHashMap替换。

4.TreeMap
TreeMap实现SortedMap接口，能够把它保存的记录根据键排序，默认是按键值的升序排序。在使用TreeMap时，key必须实现Comparable接口或者在构造TreeMap传入自定义的Comparator。TreeMap一般用于单线程中，如果使用排序的映射，建议使用TreeMap。
```

#### b.Map接口的主要实现类的比较

```
LinkedHashMap是继承于HashMap。HashMap无序；LinkedHashMap有序；TreeMap是按Key的顺序排列，默认是升序，如果要改变其排序可以自己写一个Comparator。

HashMap和Hashtable的效率大致相同，因为它们的实现机制几乎完全一样。但Hashtable需要额外的线程同步控制。TreeMap通常比HashMap、Hashtable要慢(尤其是在插入、删除key-value对时更慢)，因为TreeMap底层采用红黑树来管理key-value对。
```

#### c. Map接口的主要实现类的适用场景

```
HashMap一般用于单线程程序中，常用来做统计。
LinkedHashMap一般用于存取顺序一致的场景。
Hashtable一般用于多线程程序中。
TreeMap一般用于单线程中存储Key有序的映射。
```

### 3). HashMap类

```
HashMap 是一个散列集合，它存储的内容是以键值对(key-value)映射的元组（Entry）。元组以键作为标记，键相同时，值覆盖。

HashMap 的实现不是同步的，这意味着它不是线程安全的。它的key、value都可以为null。
```

#### a.HashMap构造函数

| 方法名                                          | 说明                                                         |
| ----------------------------------------------- | ------------------------------------------------------------ |
| HashMap()                                       | 构造一个空的 HashMap ，默认初始容（16）和默认负载系数（0.75）。 |
| HashMap(int initialCapacity)                    | 构造一个空的 HashMap具有指定的初始容量和默认负载因子（0.75）。 |
| HashMap(int initialCapacity,  float loadFactor) | 构造一个空的 `HashMap`具有指定的初始容量和负载因子。         |
| HashMap(Map<? extends K,? extends  V> m)        | 构造一个新的 HashMap与指定的相同的映射 Map 。                |

#### b.HashMap常用方法

| 返回值类型    | 方法名                      | 说明                                                         |
| ------------- | --------------------------- | ------------------------------------------------------------ |
| v             | put(K key,V value)          | 在此映射中关联指定值与指定键。                               |
| v             | get(Object key)             | 返回指定键所映射的值；如果对于该键来说，此映射不包含任何映射关系，则返回null。 |
| Set<K>        | keySet()                    | 返回此映射中所包含的键的 Set 视图。                          |
| Collection<v> | values()                    | 返回此映射所包含的值的Collection视图。                       |
| v             | remove(Object key)          | 从此映射中移除指定键的映射关系（如果存在）。                 |
| Boolean       | containsValue(Object value) | 如果此映射将一个或多个键映射到指定值，则返回true。           |
| Boolean       | containsKey(Object key)     | 如果此映射包含对于指定键的映射关系，则返回true。             |
| Boolean       | isEmpty()                   | 如果此映射不包含键-值映射关系，则返回true。                  |
| int           | size()                      | 返回此映射中的键-值映射关系数。                              |

### 4). HashMap的一般用法

Map是接口，在使用Map集合时，通常使用其实现类通过new来创建一个Map集合对象。由于Map使用了泛型，在实例化时是需传递类型参数的。

```java
1.创建一个Map 的对象
// 使用Map接口的实现类HashMap创建Map对象。  
// Key表示教师的工号，V表示教师。  
Map<String,  Teacher> teacherMap = **new** HashMap<String, Teacher>();  

2.向Map中存值
Teacher teac1 = new  Teacher("张三", "男");  
Teacher teac2 = new  Teacher("李四", "女");  
Teacher teac3 = new  Teacher("王五", "男");  
teacherMap.put("001",  teac1);  
teacherMap.put("102",  teac2);  
teacherMap.put("201",  teac3);  

3.从Map中取值
Teacher teac = teacherMap.get("001");  

4.查找Map中是否存在某个key值或value值
teacherMap.containsKey("202");  teacherMap.containsValue(teac3)  

5.返回Map集合中所有的Key
System.out.println("所有的工号："); 
for (String s :  teacherMap.keySet()) 
{  System.*out.*println(s);  }  

6.返回Map集合中所有的Value
System.out.println("所有的教师：");  
for (Teacher t :  teacherMap.values()) 
{  System.*out.*println(t.toString());  }  

7.entrySet()的使用
此方法返回包含映射关系的Set集合。
Set<Map.Entry<String,  Teacher>> entrySet = teacherMap.entrySet();  
for (Entry<String, Teacher> entry :  entrySet)
{     
	String s = entry.getKey();     
	Teacher t = entry.getValue();     
	System.***out\***.println(s + "," +  t.getName() + "," + t.getSex());  
}  

8.遍历Map 
	
方法1：首先获取Map中所有的Key，再通过每一个Key获取其对应的Value值。
  System.out.println("通过Key获取Value进行遍历：");  
for (String s :  teacherMap.keySet()) 
{     
    Teacher t = teacherMap.get(s);     
 	System.*out*.println(t.toString());  }  
	
方法2：获取Map中所有的Value。
  System.out.println("通过获取Map中所有的Value进行遍历：");  
for (Teacher t :  teacherMap.values()) 
{     
    System.out.println(t.toString());  }  
	
方法3：首先通过HashMap.entrySet()得到键值对的集合，再通过entrySet()进行获得键和值。
System.out.println("通过entrySet()进行遍历:");  
for (Entry<String,  Teacher> teacEntry : teacherMap.entrySet()) 
{     
    String s = teac.getKey();     
    Teacher t = teac.getValue();     
    System.*out*.println(s + "," + t.toString());  
}  
```

## 5.Collection

### 1). 集合框架

一组Java对象需要存储，可以采用数组，但数组长度固定，不能达到动态扩展，其次数组存储元素不便于对数组进行添加、修改、删除操作，而且数组可以存储重复元素。这个时候就需要集合容器。集合容器因为内部的数据结构不同，有多种具体容器，不断的向上抽取，就形成了集合框架。集合框架分为Collection和Map两种体系。

```
集合的特点：
    集合是用于存储对象的容器
    集合的长度是可变的
    集合中不可以存储基本数据类型值
```

### 2). Collection

Collection接口(java.util.Collection)是Java集合类的顶级接口之一，整个集合框架就围绕一组标准接口而设计。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供最大化的统一操作方式。

![img](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/Java/clip_image002.png)

```
Collection接口有3种子类型集合
    List
    Set
    Queue

再下面是一些抽象类，最后是具体实现类，常用的有
    ArrayList
    LinkedList
    HashSet
    LinkedHashSet
    ArrayBlockingQueue
```

### 3). Collection的常见方法

Collection接口的API，包含了添加、删除、遍历以及判断是否为空等等操作，所有collection的直接子类和间接子类都必须实现。

```java
1.添加
　　booleanadd(Objectobj);--添加
　　booleanaddAll(Collectioncoll)--添加集合

2.删除
　　booleanremove(Oojectobj);--删除
　　booleanremove(Collectioncoll)--删除集合
　　voidclear()--移除所有内容

3.判断
　　booleancontains(objectobj);--判断些集合指定的元素，则返回true
　　booleancontainsAll(Collectioncoll)--判断些集合指定的合集，则返回true
　　booleanisEmpty():--判断集合中是否有元素。

4.获取：
　　intsize();--返回集合中的元素数
　　Iteratoriterator();--取出元素的方式：迭代器

5.其他：
　　booleanretainAll(Collectioncoll)--取交集（1，2，5;2，4;取2）
　　Object[]toArray():--将集合转成数组。
```

## 6.Iterator接口

### 1). Iterator接口概述

```
Iterator接口，是作为集合的迭代器，为各种不同的数据结构提供统一的访问机制，使得数据结构的成员能够按照某种次序排列。
通俗一点的说，所有实现了Collection接口的容器类都有一个iterator()方法用以返回一个实现了Iterator接口的对象，可以通过Iterator对象来遍历集合中的元素。
Iterator是一种接口，任何数据结构只要部署Iterator接口，就称这种数据结构是可遍历的。
原生具备Iterator接口的数据结构有：Array、Map、Set、TypedArray、函数的arguments对象和NodeList对象等
```

### 2). Iterator接口的方法

```
hasNext() 
    该方法会判断集合对象是否还有下一个元素，如果已经是最后一个元素则返回false
next()
    把迭代器的指向移到下一个位置，同时，该方法返回下一个元素的引用
remove() 
    从迭代器指向的集合中移除迭代器返回的最后一个元素

唯一需要注意的就是，循环中删除元素的做法一定要注意下标，多线程情况慎用删除元素，因为集合的改变以及序号的改变，会导致遍历集合的时候出现ConcurrentModificationException异常。
```

### 3). Iterator接口的使用

要想使用Iterator接口就必须通过collection接口中的iterator（）方法来获得一个Iterator的实例化对象，用这个Iterator的实例对象通过调用它的方法来遍历集合元素。

代码如下：

```java
String m="";  
//接口可以用子类来实例化，也可以用Lambda表达式（匿名实现类）来实例化   
Collection c=new LinkedList();   
c.add("123");   
c.add("car");   
c.add("sdc");   
c.remove("123");   
//调用iterator方法，返回一个迭代器对象，利用迭代器对象可以实现对集合的遍历   
Iterator it=c.iterator();   
while(it.hasNext()) {     
    m=(String)it.next();     
    System.out.println(m);   
} 
```

# 二、反射机制

### 1). Java反射机制的概念

```
在Java运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法；这种动态获取信息以及动态调用对象方法的功能称为Java反射机制。

java.lang.reflect包下提供了用于获取目标类和对象的反射信息的类和接口。
```

### 2). Java反射机制的功能

```
在运行时判定任意一个对象所属的类。
在运行时构造任意一个类的对象。
在运行时判定任意一个类所具有的成员变量和方法。
在运行时调用任意一个对象的方法。
生成动态代理。
```

### 3).Java反射机制的优缺点

```
Java反射机制可以实现动态创建对象和编译，体现出很大的灵活性（在J2EE的开发中它的灵活性就表现的十分明显）。通过反射机制我们可以获得类的各种内容，进行了反编译。对于Java这种先编译再运行的语言来说，反射机制可以使代码更加灵活，更加容易实现面向对象，总结如下：

优点：运行期类型的判断，动态类加载，动态代理需要使用反射。

缺点： 性能慢，反射相当于一系列解释操作，通知JVM要做的事情，性能比直接的Java代码要慢很多。
```

### 4). Java反射机制相关类和接口

**java.lang.reflect包**下提供了用于获取目标类和对象的反射信息的类和接口。

```
ClassLoader;//类加载器类
Class;//类的类        
Constructor;//构造方法类 
Field; //类的成员变量类    
Method;//类的方法类
Modifier;//访问权限类

```

```
						     ClassLoader类
ClassLoader是一个抽象类，它的实例是类加载器。磁盘上存在的.class文件需要被加载进JVM才能执行。类加载器则是负责加载.class文件的对象，然后在JVM中生成该类的Class对象。每一个Class对象都关联着定义它的类加载器。

						     Class类
Class类的对象用来描述一个运行状态的类。一个xxx.java文件编译后生成一个xxx.class文件，一个xxx.class文件被JVM加载后生成该类对应的Class对象，该对象包含了所加载的类的所有信息,比如，类中有属性、构造器、方法等信息。任何类都有一个对应的Class对象。Class类常用方法如表3-1所示。

						     Constructor类
Constructor构造器类，封装一个类的单个构造函数的信息和访问。
主要方法有：
Object newInstance(Object...arg)，用指定参数创建对象。

						     Field类
字段类，封装字段的有关信息。
主要方法有：
Object get(Object obj)，返回指定对象上由该字段表示的字段的值。
void set(Object obj , Object value)，将指定对象参数上此字段对象表示的字段设置为指定的新值。

						     Method类
方法类，封装类的方法的有关信息。
主要方法有：
Object invoke(Object obj, Object... args)，调用obj对象的Method对象代表的方法，args为参数。

						     Modifier类
Modifier类提供了static方法和常量来解码类和成员访问修饰符。修饰符集合被表示为具有表示不同修饰符的不同位位置的整数。
```

| 序号 | 获取内容         | 方法签名                                                     |
| ---- | ---------------- | ------------------------------------------------------------ |
| 1    | 构造器           | Constructor<T>  getConstructor(Class<?>... parameterTypes)   |
| 2    | 包含的方法       | Method  getMethod(String name, Class<?>... parameterTypes)   |
| 3    | 包含的属性       | Field  getField(String name)                                 |
| 4    | 包含的Annotation | <A  extends Annotation> A getAnnotation(Class<A> annotationClass) |
| 5    | 内部类           | Class<?>[]  getDeclaredClasses()                             |
| 6    | 外部类           | Class<?>  getDeclaringClass()                                |
| 7    | 所实现的接口     | Class<?>[]  getInterfaces()                                  |
| 8    | 修饰符           | int  getModifiers()                                          |
| 9    | 所在包           | Package getPackage()                                         |
| 10   | 类名             | String getName()                                             |
| 11   | 简称             | String getSimpleName()                                       |

### 5). Java反射机制的步骤

```
1.通过类加载器加载目标类（例如Person类），然后获取该类的Class对象；

2.使用Class对象调用其方法（如getDeclaredMethods）获取该类的相关信息，包括构造函数、成员属性、成员方法、访问控制符等；

3.使用反射API 来操作这些信息
```

### 6). Java反射机制的使用方法

```java
					1.运行时获取Person类的Class对象。有三种获取方式。
		第一种方式，通过对象的getClass方法。
Person person = new  Person("张", "男", "2010-09-10");  Class<?> clazz  = person.getClass();  
	第二种方式，通过类的Class属性。
Class <?> clazz  = com.daiinfo.javaadvanced.know3.example.Person.class;  
	第三种方式，通过Class类的静态方法forName()加载类。
Class<?> clazz  = null;  
try {  clazz = Class.forName("com.daiinfo.javaadvanced.know3.example.Person");  } catch  (ClassNotFoundException e) {  
    e.printStackTrace();  
}  

					2. 获取Person中的属性
System.out.println("====所有属性====");  
Field[] fieldList = clazz.getDeclaredFields();  
for (Field f :  fieldList) {  
    System.*out*.println(f);  
}  

					3. 获取Person中的方法
System.out.println("====所有方法=====");  
// Method[] methodList=clazz.getMethods();  
Method[] methodList = clazz.getDeclaredMethods();  
for (Method m : methodList) {  
    System.out.println(m);  
}  

					4. 获取Person中的构造函数
System.out.println("====所有构造函数=====");  
Constructor [] constructorList  = clazz.  getConstructors();  
for (Constructor c : constructorList)  {  
    System.out.println(c);  
}   
```

### 7).Class类和Class对象

Java有两种对象：**实例对象和Class对象**

**实例对象**是使用new通过类的构造器创建的类的一个具体实例。类是所有相同对象的抽象，也是一种数据结构，类里面封装有属性、方法、代码块、构造器等这些基本元素。

**Class对象**表示RTTI（Run-Time Type Identification）运行时识别类信息的对象，即class<?>类对象。class<?>描述的是类的结构，Class类对象无法直接创建。

每一个类都有一个Class对象，每个类都有实例对象。实例对象可以通过new创建，也可通过类的Class对象去创建。其过程如下：

![img](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/Java/clip_image001.png)

#### a.Class对象

```
Java虚拟机把描述类的数据通过类加载器从 Class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终在内存中堆内（heap）创建一个代表这个类的 java.lang.Class 对象，Class 对象封装了类在方法区内的数据结构，并且向开发者提供了访问方法区内的数据结构的接口。因此不能显式地声明一个Class对象。

类加载器是Java虚拟机（JVM）的一个子系统，所有的类都是在对其第一次使用时，动态加载到内存。一个类被加载到内存并供使用需要经历如下几个阶段：
			   
			   |连接(Linking)                           |
加载(Loading)-->|验证(verification)-->准备(preparation)-->|解析(resolution)-->初始化(Initialization)-->使用(using)-->卸载(unloading)
```

#### b.Class对象获取

目标类通过类加载器加载后在内存中会生成一个代表这个类的 java.lang.Class 对象，可以获取该Class对象。有三种获得Class对象的方式：

```
1）Class.forName(“类的全限定名”)
Class<?>  catClass=Class.forName("com.daiinfo.Cat")  

2）实例对象.getClass()
Cat cat=new Cat();  Class<?> catClass = cat.getClass();  

3）类字面常量，即：类名.class
Class<?>  catClass=Cat.class;  
```

####  c.Class对象引用

获取目标类的Class对象后就可通过Class类的常用方法获取该目标类的成员属性、成员方法、构造函数等信息。

Class类的方法

| **方法名**         | **说明**                                                     |
| ------------------ | ------------------------------------------------------------ |
| forName()          | (1)获取Class对象的一个引用，但引用的类还没有加载(该类的第一个对象没有生成)就加载了这个类。  (2)为了产生Class引用，forName()立即就进行了初始化。 |
| Object-getClass()  | 获取Class对象的一个引用，返回表示该对象的实际类型的Class引用。 |
| getName()          | 取全限定的类名(包括包名)，即类的完整名字。                   |
| getSimpleName()    | 获取类名(不包括包名)                                         |
| getCanonicalName() | 获取全限定的类名(包括包名)                                   |
| isInterface()      | 判断Class对象是否是表示一个接口                              |
| getInterfaces()    | 返回Class对象数组，表示Class对象所引用的类所实现的所有接口。 |
| getSupercalss()    | 返回Class对象，表示Class对象所引用的类所继承的直接基类。应用该方法可在运行时发现一个对象完整的继承结构。 |
| newInstance()      | 返回一个Oject对象，是实现“虚拟构造器”的一种途径。使用该方法创建的类，必须带有无参的构造器。 |
| getFields()        | 获得某个类的所有的公共（public）的字段，包括继承自父类的所有公共字段。 类似的还有getMethods和getConstructors。 |
| getDeclaredFields  | 获得某个类的自己声明的字段，即包括public、private和proteced，默认但是不包括父类声明的任何字段。类似的还有getDeclaredMethods和getDeclaredConstructors。 |

# 三、泛型机制

## 1.概念

### 1).Java泛型的概念

泛型（Generic type 或者 generics）是JDK 1.5的一项新特性，是对 Java 语言的类型系统的一种扩展，以支持创建可以按类型进行参数化的类。它的本质是参数化类型（Parameterized Type），也就是说所操作的数据类型将被指定为一个参数，在用到的时候再指定具体的类型。

```
例如：
public class GenericsClassName<T, S  extends T> {      ....   }  

其中，GenericsClassName是泛型类，<T, S extends T>是参数化类型。泛型的本质是将数据类型作为参数进行传递。
```

### 2). 泛型的作用

```
1）提高类型安全。
2）消除强制类型转换。
3）解决代码复用问题。
```

### 3). 泛型机制的使用场景

泛型是Java**1.5**提供的新特性，其作用主要是解决数据类型的安全性问题。在Java开发中,对象的引用传递是十分常见的, 需对常用操作进行封装，封装时需要对传进来的数据对象进行处理，此时就使用到泛型。

```
不想写多个重载函数的场景。
约束对象类型的场景，可以定义边界（T extends ...），如JDK集合List，Set。
用户希望返回他自定义类型的返回值场景，如Json返回Java bean。
应用反射的应用中，也经常会用到泛型，如Class<T>。
对网页、资源的分析，返回场景，一般都有泛型。

其实泛型的应用很广，简单来说，希望将数据类型参数化的地方，就可以用泛型。
```

##  2.**泛型类的使用**

### 1).定义

在定义带类型参数的类时，在紧跟类名之后的< >内,指定一个或多个类型参数的名字，同时也可以对类型参数的取值范围进行限定，多个类型参数之间用逗号分隔。

```java
定义语法格式：
访问修饰符 class 类名<泛型参数列表>{  …  }  

实例：
public class  Box<T>{  public boolean add(T  t){     }     
public String get(int  index){     }       
public <T> T show(){     }   }  

其中，Box为泛型类，<T>为参数化类型。泛型类Box<T>表示Box可以存放任意类型的数据。
```

### 2).泛型类的使用

```java
在使用泛型类创建对象的时候指定泛型。代码如下：
// 创建存放String类型数据的Box对象  
Box<String>  StringBox=new Box<>();     

// 创建存放Integer类型数据的Box对象  
Box<Integer>  intBox=new Box<>();     

//创建存放Double类型数据的Box对象  
Box<Double>  doubleBox=new Box<>();  
```

## 3. 泛型方法的使用

### 1). 泛型方法的定义

```java
在定义带类型参数的方法时，在紧跟访问修饰（例如public、private等）之后、返回值之前的< >内,指定一个或多个类型参数的名字，同时也可以对类型参数的取值范围进行限定，多个类型参数之间用逗号分隔。
Java中任何方法，包括静态的（注意，泛型类不允许在静态环境中使用）和非静态的，均可以用泛型来定义，而且和所在类是否是泛型没有关系。

定义语法格式：
访问修饰符 **<T , S>** 返回值类型 方法名(形参列表){  //方法体...  }  
定义泛型方法时，必须在返回值前边加一个<T>，来声明这是一个泛型方法，持有一个泛型T，然后才可以用泛型T作为方法的返回值。

实例代码如下：
public <T> boolean add(T t){    // 方法体  }   
```

### 2). 泛型方法的使用

```java
在调用泛型方法的时候确定泛型类型的参数值。
代码如下：
Box<String> box=new  Box<>();  box.add(“Jacket”);  box.add(“shoes”);  
如果此时调用add(123)在编译时则出现错误，因泛型方法参数是String，此时传入int型参数则出错。
```

##### 说明：

```
使用泛型方法时，返回值或参数至少有一个是泛型定义的，它应该和泛型类中的泛型参数类型保持一致，否则可能会受到各种限制，因此，这里建议保持一致。

如果定义类、接口是没有使用类型形参，也可以在定义方法时自己定义类型形参。

泛型方法的方法签名比普通方法的方法签名多了类型形参声明，类型形参声明以尖括号括起来，多个类型形参之间以逗号隔开，所有类型形参声明放在方法修饰符和方法返回值类型之间。

与类、接口中使用泛型参数不同的是，方法中的泛型参数无需显式传入实际类型参数，因为编译器根据实参推断类型形参的值。它通常推断出最直接的类型参数。
```

## 4.泛型接口的使用

### 1). 泛型接口的定义

```java
泛型接口的定义格式如下:
访问修饰符 interface 接口名<泛型参数列表>{   // 泛型方法  }  

实例代码如下：
public interface GenericInterface<T>  {      public <T> T print(T t);  }  

其中，GenericInterface为泛型接口，<T>为参数化类型。
```

### 2). 泛型接口的使用

```java
泛型接口的使用有两种使用方式。

第一种，定义泛型接口的实现类，但实现类不是泛型类，此时泛型接口需指定确定类型参数。代码如下：
public class GenericClass implements  GenericInterface<Person>
{   @Override      
    public Person print(Person p)
    {        
        p.setAge(p.getAge()+1);        
        p.setName("武汉"+p.getName());        
        return p;    
    }  
}   


第二种，定义泛型接口的实现类，但实现类也是泛型类。
有些时候在定义一个类去实现泛型接口时，并不确定这个类将要实现哪种类型的类，这时就不能确定接口中的泛型，那么接口中的泛型尚未确认，这时就要求这个类也必须定义泛型，而且泛型名称要一致。
实现接口的类GenericClass也是泛型类，
    代码如下：
public class GenericClass<T>  implements GenericInterface<T>
{    @Override      
    public <T> T print(T t) {        
        System.out.println(t.getClass());        
        return t;    
    }  
}  
在使用时，通过泛型类创建类对象，需传递类型参数，
    代码如下。
public static void main(String[] args) {        
    //实现Person类对象        
    GenericClass <Person> gc = new GenericClass<Person>();       
    Person p = new Person("林妹妹",18);        
    Person ps = gc.print(p);        
    System.out.println(ps);           
    
    //实现String类对象        
    GenericClass<String> gc1 = new GenericClass<String>();        
    String str = "林妹妹";       
    String s = gc1.print(str);        
    System.out.println(s);  
}  
```

## 5.数据访问层DAO模式

### 1). DAO模式

在使用Java开发企业级应用程序中都采用Java EE分层结构，如图4-1所示。

![image-20240705111935502](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/Java/image-20240705111935502.png)

Java EE分层结构一般分为表现层、业务层和持久层。

```
表现层与客户端交互，包括获取用户请求，传递数据，封装数据，展示数据。
业务层处理复杂的业务，包括各种实际的逻辑运算。
持久层与数据库进行交互。
```

典型的分层架构像SSH（Spring+ Struts+ Hibernate）或SSM（Spring+ SpringMVC+ MyBatis）一般都采用这种架构。

##### 在Java EE分层结构中，持久层即为数据访问层，称为DAO(Data Access Object，数据访问对象)层。DAO在实体类与数据库表之间起着转换器的作用，能够把实体类转换为数据库中的记录，实现对数据表的增加(Create)、查询(Retrieve)、更新(Update)和删除(Delete)，即CRUD操作。

### 2). DAO模式开发

在实际的项目开发中，通常写一个DAO接口，其中声明增删改查方法，再设计DAO实现类DAOImpl，具体实现DAO接口中声明的数据库表操作方法。

DAO代码如下：

```java
public interface UserDAO  {    
    public void insert(User user) throws  Exception;    
    public void update(User user) throws  Exception;    
    public void delete(int userid) throws  Exception;    
    public User queryById(int userid) throws  Exception;    
    public List<User> queryAll() throws  Exception;  
}  
```

DAOImpl代码如下：

```java
public class  UserDAOImpl implements UserDAO {       
    @Override    
    public void insert(User user) throws  Exception {      
        // TODO Auto-generated method stub          
    }      
    @Override    
    public void update(User user) throws  Exception {     
        // TODO Auto-generated method stub          
    }       
    @Override    
    public void delete(int userid) throws  Exception {      
        // TODO Auto-generated method stub          
    }       
    @Override    
    public User queryById(int userid) throws  Exception {      
        // TODO Auto-generated method stub             
    }       
    @Override    
    public List<User> queryAll() throws  Exception {      
        // TODO Auto-generated method stub        
    }  
```

实际的工程项目有多个数据库表，例如高校图书管理系统中有图书基本信息表Book，教师信息表Teacher，学生信息表Student，用户表User，出版社信息表Publishinghe 图书分类信息表Category等，这些基本信息表对应Java的实体类，每个实体类的DAO都包含CRUD操作。

如果每个实体类都写一个DAO接口和实现类，这样使得代码冗余度较高。

## 6.DAO层使用泛型

### 1). 使用泛型实现DAO层

使用泛型可以解决代码复用问题。对于各个实体类的DAO，可以将公共的CRUD方法提取到BaseDAO中，这样提高了代码的复用，简化了代码。

BaseDAO使用了泛型接口和泛型方法，BaseDAOImpl使用了泛型类和泛型方法，里面封装了实体类相同的操作。当需要操作不同表的时候，将T换成相对应的实体类，即User或者是Teacher或者是其他的实体类就可以了。抽取原理图如图4-2所示：

![image-20240705112319220](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/Java/image-20240705112319220.png)

从抽取原理图可以看出：

```
BaseDAO中定义CRUD操作，包括add()、delete()、update()、queryAll()等方法；
BookDAO、StudentDAO、TeacherDAO继承BaseDAO；
BaseDAOImpl实现BaseDAO；
BookDAOImpl继承BaseDAOImpl、实现BookDAO；
StudentDAOImpl继承BaseDAOImpl、实现StudentDAO；
TeacherDAOImpl继承BaseDAOImpl、实现TeacherDAO。
```

### 2). 使用泛型编写通用型DAO层的步骤

```java
1）创建DAO的基接口。
public  interface BaseDAO<T> {      
    public void  insert(T t);    
    public void  update(T t);    
    public void  delete(int id);    
    public T  queryById(int userid);    
    public  List<T> queryAll();  
}  

2）创建DAO的通用实现类。
public class  BaseDAOImpl<T> implements BaseDAO<T>{     }  

3）创建具体实体类的DAO接口。
public interface BookDAO extends BaseDAO<Book>{     }  
public interface  TeacherDAO extends BaseDAO<Teacher> {     }  

4）创建具体实体类DAO的实现类。
public class  BookDAOImpl extends BaseDAOImpl<Book> implements BookDAO{     
}  
public class  TeacherDAOImpl extends BaseDAOImpl<Teacher > implements TeacherDAO {   }  
public class  StudentDAOImpl extends BaseDAOImpl<Student> implements StudentDAO{     }  
```

# 四、序列化技术

## 1.概念

### 1).应用场景

```
在分布式环境下，当进行远程通信时，彼此需要发送Java对象。因为在网络上传输的数据都会以二进制的形式，所以发送方需要把Java对象转换为字节序列，才能在网络上传送；接收方则需要把字节序列再恢复为Java对象。这就需要把Java对象进行序列化处理。

序列化常应用于以下场景：
    1）永久性保存对象，保存对象的字节序列到本地文件或者数据库中 
    2）通过序列化以字节流的形式使对象在网络中进行传递和接收
    3）通过序列化在进程间传递对象
```

### 2). Java序列化概念

```
Java序列化是指把Java对象转换为字节序列的过程
Java反序列化是指把字节序列恢复为Java对象的过程
```

### 3). Java序列化的几种方式

```
						比较常见的方式有两种：
Java对象序列化。Java类通过实现Serializable接口来实现该类对象的序列化
JSON序列化。JSON 序列化就是将数据对象转换为 JSON 字符串。

						其他的序列化方式：
ProtoBuf序列化
protocol buffers是一个用于对结构化数据进行序列化的协议，适合网络传输，可用于C++、java和Python语言的序列化，适用范围很广。但不支持太多的数据类型，也不支持二维数组和STL容器（set、list、map等）序列化。

Hessian 序列化
Hessian 序列化是一种支持动态类型、跨语言、基于对象传输的网络协议。它的优点在于，比Java原生的序列化更快，序列化出来的数据更小。但没有Java序列化可靠，而且也不如Java序列化支持的全面。
```

## 2.使用Serializable接口实现Java对象序列化和反序列化

### 1). Serializable接口

```
Serializable接口表示一个对象的序列化由实现该接口的类启用，未实现此接口的类将不会使任何状态序列化或反序列化。Serializable接口是一个标记接口，没有成员方法和变量，仅用于标识可序列化的语义。

一个类要想序列化就必须继承java.io.Serializable接口，同时它的子类也可以序列化。

序列化只能保存对象的非静态成员变量，不能保存任何的成员方法和静态的成员变量，而且序列化保存的只是变量的值，对于变量的任何修饰符都不能保存。记住序列化是保存对象的状态。
```

### 2). Java对象序列化

```java
1.定义一个实体类，并实现Serializable 接口
public class Employee **implements  Serializable** {  }  

2.创建该类的对象
Employee employee = new  Employee();  

3.创建逻辑文件
File file=new File(“物理文件”);  

4.创建文件输出流
FileOutputStream fos=new FileOutputStream(file);  

5.创建对象输出流，负责将对象写入字节流
ObjectOutputStream oos =  new ObjectOutputStream(fos);  

6.通过对象输出流写入对象
oos.writeObject(employee);  

7.最后关闭流
oos.close();  fos.close();  
```

### 3). Java对象反序列化

```java
1.定义一个实体类，并实现Serializable 接口
public class Employee **implements  Serializable** {  }  

2.创建该类的对象
Employee employee = new Employee();  

3.创建逻辑文件
File file=new File(“物理文件”);  

4.创建文件输入流
FileInputStream fis=new FileInputStream(file);  

5.创建对象输出流，负责将对象写入字节流
ObjectInputStream iis =  new ObjectInputStream(fis);   

6.通过对象输出流读出对象并处理该对象
employee=iis.readObject(employee);  System.out.println(employee);  

7.最后关闭流
iis.close();  fis.close();  
```

### 4). 补充

#### a.serialVersionUID

```
Java类实现Serializable接口时会声明一个serialVersionUID， serialVersionUID是用来辅助对象的序列化与反序列化的，原则上序列化后的数据当中的serialVersionUID与当前类当中的serialVersionUID一致，那么该对象才能被反序列化成功。

serialVersionUID的取值是Java运行时环境根据类的内部细节自动生成的。如果对类的源代码作了修改，再重新编译，新生成的类文件的serialVersionUID的取值有可能也会发生变化。

类的serialVersionUID的默认值完全依赖于Java编译器的实现，对于同一个类，用不同的Java编译器编译，有可能会导致不同的serialVersionUID，也有可能相同。一般给serialVersionUID赋予明确的值。

当通过网络传输，因serialVersionUID不一致的时候就会报InvalidClassException。

实际上serialVersionUID都不是必须的，没有它同样可以正常的实现序列化操作。
```

#### b.transient关键字

```
当某些变量不想被序列化，同是又不适合使用static关键字声明，那么此时就需要用transient关键字来声明该变量。（不会再反序列化的时候被获取数据，只会取得初始值，如 int 型的是 0，对象型的是 null。）
```

## 3.使用Externalizable接口实现Java对象序列化和反序列化

### 1). Externalizable接口

```
Java语言还提供了另外一种方式来实现对象持久化，Externalizable接口，即外部序列化。Externalizable接口继承自 Serializable接口，实现Externalizable接口的类完全由自身来控制序列化的行为，即Externalizable接口中的方法必须由开发人员实现。

与实现Serializable接口的方法相比，使用Externalizable编写程序的难度更大，但是由于控制权交给了开发者，在编程时有更多的灵活性，对需要持久化的那些属性可以进行控制，可以提高程序的性能。
```

### 2). 使用Externalizable接口实现序列化和反序列化

Externalizable接口定义了两个抽象方法：writeExternal()与readExternal()，通过这些方法指定序列化哪些属性、不序列化哪些属性。

首先声明实体类，其实现Externalizable接口，重写writeExternal()与readExternal()方法。

```java
public class UserInfo implements Externalizable {         
    private int  age;      
    private  String name;         
    public int  getAge() {         
        return  age;      
   }         
    public void  setAge(int age) {         
        this.age  = age;      
    }         
    public  String getName() {         
        return  name;      
    }         
    public void  setName(String name) {         
        this.name  = name;      
    }         
    @Override      
    public void  writeExternal(ObjectOutput out) throws IOException {         		    out.writeObject(name);         
    	out.writeInt(age);     
    }         
    @Override      
    public void  readExternal(ObjectInput in) throws IOException,ClassNotFoundException {         
        name  = (String) in.readObject();         
        age  = in.readInt();      
    }         
    @Override      
    public  String toString() {         
        return  "name='" + name + '\'' + ", age=" + age;      
    }  
}  

然后实现序列化：
public static void serializeTest(){         
    UserInfo  userInfo = new UserInfo();         
    userInfo.setAge(23);         
    userInfo.setName("Tom");         
    System.out.println(userInfo);         
    ObjectOutput  objectOutput = null;         
    try  {             
        objectOutput  = new ObjectOutputStream(new FileOutputStream("D:\\user_info.ser")); 
        objectOutput.writeObject(userInfo);             
        objectOutput.flush();         
    }  catch (IOException e) {             
        e.printStackTrace();         
    }  finally {             
        if  (objectOutput!=null) {                
            try  {                    
                objectOutput.close();                
            }  catch (IOException e) {                    
                e.printStackTrace();                
            }             
        }         
    }     

再实现反序列化：
public static void deserialize(){         
    ObjectInput  objectInput = null;         
    try{             
        objectInput  = new ObjectInputStream(new FileInputStream("D:\\user_info.ser"));             
        UserInfo  userInfo = (UserInfo) objectInput.readObject();             
        System.out.println(userInfo);   }  
    catch (Exception e) {             
        e.printStackTrace();         }  
    finally {             
        if  (objectInput!=null) {                
            try  {                    
                objectInput.close();                
            }  catch (IOException e) {                    
                e.printStackTrace();                
            }              
        }         
    }      
}     
```

**注意：实现Externalizable接口的类可以不设置serialVersionUID常量，但必须要求序列化前后的两个类完全相同，为了编程更显灵活，推荐设置serialVersionUID常量**

### 3). Serializable接口与Externalizable接口比较

```
1）Serializable反序列化时不会调用默认构造方法，而Externalizable反序列化时会调用默认构造器方法

2）Serializable反序列化时构造方法可以是任意访问权限的控制符，而Externalizable反序列化时只能是public

3）Serializable序列化时，static或transient修饰的属性不会被序列化，而Externalizable序列化时只能通过writeExternal()和readExternal()方法指定序列化哪些属性不序列化哪些属性，不能使用transient修饰符
```

# 五、线程机制

```
1、程序（Program）
	为了实现一个功能，完成一个任务而选择一种编程语言编写的一组指令的集合。
2、进程（Process）
    程序的一次运行。操作系统会给这个进程分配资源（内存）。
    进程是操作系统分配资源的最小单位。
    进程与进程之间的内存是独立，无法直接共享。
    最早的DOS操作系统是单任务的，同一时间只能运行一个进程。后来现在的操作系统都是支持多任务
    的，可以同时运行多个进程。进程之间来回切换。成本比较高。
3、线程（Thread）
    线程是进程中的其中一条执行路径。一个进程中至少有一个线程，也可以有多个线程。有的时候也把
    线程称为轻量级的进程。
    同一个进程的多个线程之间有些内存是可以共享的（方法区、堆），也有些内存是独立的（栈（包括
    虚拟机栈和本地方法栈）、程序计数器）。
    //无参构造
    public 自定义异常名(){
    }
    //有参构造
    public 自定义异常名(String message){
    super(message);
    }
    线程之间的切换相对进程来说成本比较低。
4、并行： 多个处理器同时可以执行多条执行路径。
5、并发：多个任务同时执行，但是可能存在先后关系。
```

## 1.线程的定义、创建和启动方法

### 1). 线程的定义

线程的定义有两种方式：通过**继承Thread类**来和通过**实现Runnable接口**来定义。

```java
1）继承Thread类定义线程类
定义一个继承Thread类的子类，并重写该类的run()方法。
class MyThead extends  Thread  
{   
	public void  run()  
	{       //do something here       
	}   
}  

2）实现Runnable接口定义线程类
定义Runnable接口的实现类，并重写该接口的run()方法。
class MyRunnable  implements  Runnable  {    
public  void run()  
{     
	//do something here     
	}   
}  
```

**两种方式的比较：**

```
使用继承Thread方式，
    编程简单
    不能再继承其他类

实现Runnable接口的方式，
    代码复杂
    还可以继承其他的类
    多个线程之间共享一个实例，适合多个线程来处理同一份资源
```

### 2). 线程的创建

```java
1）使用线程类的子类创建线程实例对象
MyThread oneThread = new MyThread();  

2）使用实现Runnable接口的类创建线程实例对象
Runnable twoRunnable = new  MyRunnable();   Thread twoThread=new Thread(twoRunnable);  

该方法中，首先创建 Runnable实现类的实例，再以此实例作为Thread的构造函数里的target参数来创建Thread对象，该Thread对象才是真正的线程对象
```

### 3). 线程的启动

```java
调用线程的start()方法启动线程。

oneThread.start();  
twoThread.start();  

创建 Runnable实现类的实例并不是真正的线程对象，不能调用start方法启动线程。所以，这里假如使用twoRunnable调用start方法则出错。
```

## 2.线程的生命周期、状态及状态之间的转换 

### 1). 线程的生命周期

线程是一个动态的概念，有创建的时候，也有运行和变化的时候，当然也有消亡（死亡）的时候，所以从生到死就是一个生命周期。

![image-20240705115606707](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/Java//image-20240705115606707.png)

### 2). 线程的状态

```
JDK中用Thread.State类定义了线程的6种状态，包含NEW、RUNNABLE、BLOCKED、WAITING、TIMED_WAITING、TERMINATED。一个线程在给定时刻有且仅有其中的一种状态，RUNNABLE状态包括了操作系统线程状态中的Running和Ready，这些状态是不反映任何操作系统线程状态的虚拟机状态。
```

### 3). 线程状态间的转换

线程启动后，它不能一直处于运行状态，线程是会在不同的状态间进行转换。线程的状态转换如图6-2所示。

![image-20240705115709542](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/Java/image-20240705115709542.png)

**线程的状态转换如下：**

```
1.NEW（新建状态）
线程对象被创建后就进入了新建状态。如：Thread myThread = new Thread();处于新生状态的线程有自己的内存空间。通过调用start方法进入可运行状态（runnable）。

2.RUNNABLE（可运行状态和运行状态）。
通过调用start方法进入可运行状态（runnable）。处于可运行状态的线程已经具备了运行条件，但还没有分配到CPU，进入线程就绪队列，等待系统为其分配CPU。处于可运行状态的线程，如果获得了CPU的调度，就会从可运行状态变为运行状态，执行run()方法中的任务。
处于运行状态的线程最为复杂，它可以变为可运行状态、阻塞状态、等待状态、超时等待状态和终止状态。
正在运行的线程调用了yield()方法或时间片用完，则失去CPU资源，就会从运行状态变为可运行状态，重新等待系统分配资源。
当调用线程的wait()方法，让线程等待某工作的完成，此时线程由运行状态转为等待状态。
线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，它会进入阻塞状态。
当线程调用了自身的sleep()方法或其他线程的join()方法或发出了I/O请求时，进程让出CPU，线程就会进入到超时等待状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行状态。
当线程的run()方法执行完，或者被强制性地终止，例如出现异常，或者调用了stop()、desyory()方法等等，就会从运行状态转变为终止状态。

3.BLOCKED（阻塞状态）
阻塞状态是线程等待锁的状态。当线程刚进入可运行状态（注意，还没运行），发现将要调用的资源被synchronized（同步），获取不到锁标记，将会立即进入锁池状态，等待获取锁标记进入同步代码块/方法或调用wait()方法后重新进入需要竞争锁。一旦线程获得锁标记后，就转入可运行状态，等待OS分配CPU时间片。线程从阻塞状态只能进入就绪状态，无法直接进入运行状态。

4.WAITING（等待状态）
一个线程在等待另一个线程执行动作时处于该状态。调用以下方法线程进入该状态：Object.wait(),Object.join(),LockSupport.park()。处于该种状态的线程是不会自动唤醒的，必须等待另一个线程调用notify()或notifyAll()方法才能唤醒。

5.TIMED_WAITING（超时等待状态）
线程等待指定时间,进入超时等待状态。调用以下方法进入该状态:Thread.sleep(long)、Object.wait(long)、Thread.join(long)、LockSupport.parkNanos()、LockSupport.parkUntil()。
该状态即停止当前线程，但并不释放所占有的资源即调用sleep ()函数后，线程不会释放它的“锁标志”。 当sleep()结束或join()结束后，该线程进入可运行状态，继续等待OS分配CPU时间片。

6.TERMINATED（终止状态）
当线程的run()方法执行完，或者被强制性地终止，线程就进入终止状态。线程一旦结束或终止，就不能复生。如果在一个终止的线程上调用start()方法，会抛出java.lang.IllegalThreadStateException异常。
```

## 3.线程的优先级

```
每个线程执行时都有一定的优先级，优先级高的获得较多的执行机会，优先级低的线程获得较少的执行机会。
每个线程默认的优先级都与创建它的父线程具有相同的优先级，在默认情况下，main的优先级是5，由main创建的线程的优先级也是5。
Thread类提供了setPriority（int i）和getPriority（int i）方法来设置和获得优先级。其中setPriority方法的参数可以是一个整数，也可以是Thread类的三个静态常量。常量包括：
    MAX_PRIORITY:其值是10
    MIN_PRIORITY:其值是1
    NORM_PRIORITY:其值是5
```

## 4.多线程的同步机制

```
当处理一个比较大的耗时任务时，可以开启多个线程同时处理这些小的任务。但当多个线程要同时访问A（如数据的增删改查）一个共享变量、同一个对象或同一个对象的方法时，这些线程中既有读又有写操作，将会导致数据不准确，相互之间产生冲突。多线程同步就是要解决这个问题。
```

### 1).多线程同步的概念

```
多线程同步，就是多线程间在一些关键点上可能需要互相等待与互通消息，这种相互制约的等待与互通信息称为多线程同步。

在多线程编程里面，一些较为敏感的数据是不允许被多个线程同时访问的，具有排他性，即互斥。在互斥的基础上，通过同步机制实现访问者对资源的有序访问，确保数据在任何时刻最多只有一个线程访问，保证数据的完整性。

多线程同步是为了确保线程安全，所谓线程安全指的是多个线程对同一资源进行访问时，有可能产生数据不一致问题，如果多线程程序运行结果和单线程运行的结果是一样的，且相关变量的值与预期值一样，则是线程安全的。
```

### 2).Java多线程的同步机制

```
Java多线程同步机制，是使用一些关键字、接口和类以及常用调度方法来实现多线程的同步。多线程的同步方法大体分为以下几种：
使用同步关键字（synchronized）
使用重入锁类（ReentrantLock）
使用特殊域变量关键字(volatile)
使用局部变量（ThreadLocal）
使用原子变量(AtomicInteger)
使用阻塞队列（BlockingQueue）
```

##  5.使用synchronized关键字实现多线程同步

### 1).  synchronized关键字

```
synchronized关键字，是比较常用的用来控制线程同步的关键字，可以保证在同一个时刻，只有一个线程可以执行某个方法或者某个代码块（主要是对方法或者代码块中存在共享数据的操作），以确保数据的完整性。

synchronized机制是给共享资源上锁，只有拿到锁的线程才可以访问共享资源，这样就可以强制使得对共享资源的访问都是顺序的。synchronized是一种独占的加锁方式，使用synchronized修饰的代码具有原子性和可见性，在需要线程同步的程序中使用的频率非常高，可以满足一般的线程同步要求。
```

### 2). synchronized关键字的使用

synchronized关键字一般用在代码块和方法（实例方法和静态方法）上。

#### a.同步代码块

即用synchronized关键字修饰代码块，亦称为同步代码块。被该关键字修饰的语句块会自动被加上内置锁，从而实现同步

```java
synchronized(a1) {    // 操作  }  
```

#### b.同步实例方法

即用synchronized关键字修饰类的实例方法。Java的每个对象都有一个内置锁，当用此关键字修饰方法时，内置锁会保护整个方法。在调用该方法前，需要获得内置锁，否则就处于阻塞状态。

```java
  public synchronized void increase() {      i++;  }  
```

#### c.同步静态方法

即用synchronized 修饰静态方法。由于静态成员不专属于任何一个实例对象，是类成员，因此如果调用该静态方法，将会锁住整个类。

```java
  public static synchronized void increase()  {      i++;  }  
```

**需要注意几点：**

```
1.synchronized锁的是括号里的对象，而不是代码。当synchronized锁住一个对象之后，别的线程如果想要获取锁对象，那么就必须等这个线程执行完释放锁对象之后才可以，否则一直处于等待状态。

2.对于非静态的synchronized方法，锁的是对象本身也就是this。

3.同步是一种高开销的操作，因此应该尽量减少同步的内容。缩小synchronized的使用范围，减小锁粒度也是一种削弱多线程锁竞争的一种有效手段。
```

## 6.使用volatile关键字实现多线程同步

### 1). volatile关键字

Java语言提供了一种稍弱的同步机制，即volatile关键字。作为Java中的关键字，它表示被修饰的变量的值容易变化（被其他线程修改），因此不稳定。

```
一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：
    1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。
    2）禁止进行指令重排序
```

### 2). 使用volatile关键字的场景

synchronized关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而volatile关键字在某些情况下性能要优于synchronized，但是要注意volatile关键字是无法替代synchronized关键字的，因为volatile关键字无法保证操作的原子性。

通常来说，使用volatile必须具备以下2个条件：

```
1）对变量的写操作不依赖于当前值
2）该变量没有包含在具有其他变量的不变式中
```

被写入 volatile 变量的这些有效值独立于任何程序的状态，包括变量的当前状态。

这2个条件需要保证操作是原子性操作，才能保证使用volatile关键字的程序在并发时能够正确执行。

### 3). volatile关键字的使用

使用volatile关键字修饰共享变量

```java
public class Bank {       
    private volatile int count = 0;// 账户余额           
    
    // 存钱       
    public void addMoney(int money) {           
        count += money;         
        System.out.println(System.currentTimeMillis() + "存进：" + money);         
    }          
    
    // 取钱       
    public void subMoney(int money) {          
        if (count - money < 0) {           
            System.out.println("余额不足");           
            return;         
        }         
        count -= money;         
        System.out.println(+System.currentTimeMillis() + "取出：" + money);         }          
    
    // 查询       
    public void lookMoney() {         
        System.out.println("账户余额："  + count);       
    }   
}
```

其中count变量使用volatile关键字修饰。在访问volatile修饰的变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此volatile修饰的变量是一种比synchronized关键字更轻量级的同步机制。

volatile关键字有如下特性：

```
    volatile关键字为域变量的访问提供了一种免锁机制
    使用volatile修饰域相当于告诉虚拟机该域可能会被其他线程更新
    每次使用该域就要重新计算，而不是使用寄存器中的值
    volatile不会提供任何原子操作，它也不能用来修饰final类型的变量
```

## 7.使用Lock接口实现多线程同步 

### 1). Lock接口

在JDK5中，Java引入了一个概念Lock，即“锁”。功能与synchronized类似。Lock接口中的方法lock()是用来获取锁的。unLock()方法是用来释放锁的。如果锁已被其他线程获取，则线程等待。

在**java.util.concurrent.locks**包下有Lock接口及其实现类。

ReentrantLock类是Lock接口的实现类，一个可重入互斥锁，具有与使用synchronized方法和语句相同的基本行为和语义，还具有扩展功能，诸如可响应中断锁、可轮询锁请求、定时锁等避免多线程死锁的方法。

### 2). 使用Lock接口实现多线程同步

##### 实现步骤如下：

```
创建 Lock 对象
调用 lock()方法上锁 
调用 unlock()方法解锁
```

##### 实例代码如下：

```java
  private **Lock** lock = new  ReentrantLock(); // ReentrantLock是Lock的实现类     private void method(Thread thread){     **lock.lock();**  // 获取锁对象      try {        System.out.println("线程名："+thread.getName()  + "获得了锁");         // Thread.sleep(2000);       }catch(Exception e){        e.printStackTrace();       } finally {        System.out.println("线程名："+thread.getName()  + "释放了锁");        **lock.unlock();** // 释放锁对象       }  }  
```

**ReentrantLock与synchronized的区别**

```
ReentrantLock通过方法lock()与unlock()来进行加锁与解锁操作，与synchronized会被JVM自动解锁机制不同，ReentrantLock加锁后需要手动进行解锁
为了避免程序出现异常而无法正常解锁的情况，使用ReentrantLock必须在finally控制块中进行解锁操作
```

### 3. Lock与synchronized比较

```
在并发量较小的多线程应用程序中，ReentrantLock与synchronized性能相差无几，但在高并发量的条件下，synchronized性能会迅速下降几十倍，而ReentrantLock的性能却能依然维持一个水准。因此我们建议在高并发量情况下使用ReentrantLock

Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现

synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁

Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断

Lock可以提高多个线程进行读操作的效率。
```

# 六、网络编程技术

## 1.Java基于TCP网络编程的相关类

```
面向连接
可靠的
有序的
以字节流的方式发送数据
```

TCP/IP协议是在通信的两端各建立一个Socket，从而在通信的两端之间形成网络虚拟链路。一旦建立了虚拟网络链路，两端的程序就可以通过虚拟链路进行通信。

Socket即为套接字，是两个进程或两台机器之间通信链路的端点，通常用来实现客户机和服务器的连接。Socket本身并不是协议，是应用层与TCP/IP协议栈通信的中间软件抽象层，它是一组接口，是对TCP/IP协议的封装，它把复杂的TCP/IP协议族隐藏在Socket接口后面，使得程序员更方便地使用TCP/IP协议栈。

一个Socket套接字与**主机地址和端口地址**相关联。即一个Socket =IP地址+端口号

Java对基于TCP协议的网络通信提供了良好的封装， 在java.net包下有两个类Socket和ServerSocket，分别用来实现双向安全连接的客户端和服务端，Java基于TCP通信有时也称为Java基于Socket通信。

### 1). Socket类

Socket是客户端套接字，其作用是**用于向服务端发送请求，通过IP和port请求建立连接**

#### a. Socket类构造函数

| *Socket(String host, int port)*                              | 创建一个流套接字并将其连接到指定主机上的指定端口号。         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| *Socket(InetAddress  address, int port)*                     | 创建一个流套接字并将其连接到指定 IP 地址的指定端口号。       |
| *Socket(String host,  int port, InetAddress localAddr, int localPort)* | 创建一个套接字绑定到本地提供的地址和端口，并将其连接到指定远程地址上的指定远程端口。 |
| *Socket(InetAddress  address, int port, InetAddress localAddr, int localPort)* | 创建一个套接字绑定到本地提供的地址和端口，并将其连接到指定远程地址上的指定远程端口。 |

```java
// 打开一个套接字，发送连接请求  
Socket socket = new Socket(InetAddress.getLocalHost(),  5678);            
```

#### a.Socket类常用方法

| *getInetAddress()*  | 返回此套接字连接到的远程地址 |
| ------------------- | ---------------------------- |
| *getPort()*         | 返回此套接字连接到的远程端口 |
| *getLocalAddress()* | 返回此套接字所绑定的本地地址 |
| *getLocalPort()*    | 返回此套接字绑定到的本地端口 |
| *getInputStream()*  | 返回此套接字的输入流         |
| *getOutputStream()* | 返回此套接字的输出流         |
| close()             | 关闭此套接字                 |
| isBound()           | 返回套接字的绑定状态         |
| isClosed`()`        | 返回套接字的关闭状态         |
| isConnected()       | 返回套接字的连接状态         |

```java
//从socket建立输入流  
InputStream in =  socket.getInputStream();                   
// 从socket建立输出流  OutputStream out = socket.getOutputStream();   
```

### 2). ServerSocket类

ServerSocket类用来描述网络服务端，其**作用是创建一个网络服务，等待客户端连接**。

#### a.ServerSocket类构造函数

| ServerSocket(int port)                                     | 创建绑定到指定端口的服务器套接字                             |
| ---------------------------------------------------------- | ------------------------------------------------------------ |
| *ServerSocket(int  port, int backlog)*                     | 创建服务器套接字并将其绑定到指定的本地端口号，并指定请求进入连接队列的最大长度 |
| ServerSocket(int port,  int backlog, InetAddress bindAddr) | 创建服务器套接字并将其绑定到指定的本地端口号和本地IP地址绑定，并指定请求进入连接队列的最大长度 |
| ServerSocket()                                             | 创建未绑定的服务器套接字                                     |

```java
// 创建一个服务端套接字，并指定本地端口   
ServerSocket server = new  ServerSocket(5678);            
```

#### b.ServerSocket类常用方法

| accept()           | 侦听要连接到此套接字并接受它 |
| ------------------ | ---------------------------- |
| *getInetAddress()* | 返回此服务器套接字的本地地址 |
| *getLocalPort()*   | 返回此套接字正在侦听的端口号 |
| isBound()          | 返回ServerSocket的绑定状态。 |
| isClosed()         | 返回ServerSocket的关闭状态。 |
| close()            | 关闭此套接字                 |

```java
//只有当有客户端请求并建立了连接，函数才会返回，返回Socket对象，否则一直阻塞  
Socket socket =  server.accept();                          
//从socket建立输入流  
InputStream istream =  socket.getInputStream();                
//从socket建立输出流  
OutputStream  ostream =  socket.getOutputStream();      
```

## 2.Java基于TCP网络编程的步骤

### 1). Java基于Socket通信

![image-20240705122108269](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/Java/image-20240705122108269.png)

基于Socket的通信过程：

```
1. 创建服务端ServerSocket，绑定指定的监听端口(在这个端口接收客户端发来的消息)。
2. ServerSocket调用accept()方法，如果客户端有一个Socket连接到服务端，那么服务端通过accept方法可以与客户端进行连接。使之处于阻塞状态。
3. 创建客户端Socket，并设置服务端的IP及端口。
4. 客户端发出连接请求。
5. 如果连接成功，分别取得服务端和客户端的InputStream和OutputStream。
6. 然后利用InputStream和OutputStream进行数据传输。
7. 最后关闭流及Socket。
```

### 2). Java基于TCP的编程步骤

Java基于TCP的编程一般分为服务端程序和客户端程序。其编程步骤通常按照Socket通信模型的步骤进行。

**服务端**

```java
// 创建服务端Serversocket的对象并绑定指定端口  
ServerSocket serverSocket =new  ServerSocket(9999);     
// 调用accept方法，进行监听，接受客户端的连接请求。  
Socket socket = serverSocket.accept();     
// 调用客户端Socket的getInputStream()方法，获取字节输入流。因网络传输的是字节流，需转换为字符流。这里使用了InputStreamReader类和BufferedReader类     
InputStream is= socket.getInputStream();  
InputStreamReader isr=new  InputStreamReader(is);  
BufferedReader bufferedReader=new  BufferedReader(isr);     
// 循环读取数据  
String str = bufferedReader.readLine();     
// 输出打印  
System.out.println(str);     
// 关闭流和socket
socket  bufferedReader.close();  
socket.close();     
```

**客户端**

```java
// 创建客户端Socket对象，指定服务端IP和端口，并请求服务端连接  
Socket socket =new Socket("127.0.0.1",9999);     
// 调用客户端socket的getOutputStream()方法，获取字节输出流。因网络传输的是字节流，需转换为字符流。这里使用了OutputStreamWriter类和BufferedWriter类。     
OutputStream os=socket.getOutputStream();  
OutputStreamWriter osw=new OutputStreamWriter(os); 
BufferedWriter bufferedWriter =new BufferedWriter(osw);     
// 设置字符串  
String str="你好!";     
// 向输出流中写入字符串 
bufferedWriter.write(str);     
// 关闭流和socket  
bufferedWriter.close();  
socket.close();     
```

**说明**

```
socket通信是阻塞的，它会在以下两个地方进行阻塞：
    第一个是accept方法，调用这个方法后，服务端一直阻塞在那里，直到有客户端连接进来。
    第二个是InputStream上的read方法，调用read方法也会进行阻塞。
```

在实际应用中，程序可能不想让执行网络连接、读取数据的进程一直阻塞，而是希望当网络连接、读取操作超过合理时间之后，系统自动认为操作失败，这个合理时间就是超时时长。

可以通过设置超时时长来解决。如果超时超时，则引发

java.net.SocketTimeoutException。

```java
//第一种是链接超时.
Socket s = new Socket();  s.connect(new InetSocketAddress (host，port),10000);  

该段程序中，首先创建一个无连接的Socket，再通过该Socket的connect方法设置连接超时。这里设置10秒，如果10秒未连接则超时。

//第二种是读写超时。
Socket s = new Socket("127.0.0.1", 30000);  s.setSoTimeouut(10000);   

该段程序中，首先创建Socket对象，然后通过该对象的setSoTimeout（int timeout）方法来设置超时时长。这里设置10秒。 超时为零则为无限超时。
```

## 3.Java基于UDP网络编程的相关类

UDP（User Datagram Protocol）称为用户数据报协议。用它传输的信息叫数据报（Datagram），数据报是通过网络传输的数据的基本单元。

UDP协议在通信实例的两端各建立一个Socket，但在两个Socket之间并没有虚拟链路，这两个Socket只是发送、接收数据报的对象。

由于UDP协议是面向无连接的协议，没有建立连接的过程，因此它的通信效率很高；也正是因为如此，它的可靠性不如TCP协议。

Java对基于UDP协议的网络通信有很好的支持，JDK提供了两个类：**DatagramSocket和DatagramPacket**

### 1). DatagramSocket类

DatagramSocket类，用来发送和接收数据报包。

#### a.DatagramSocket类构造函数

| DatagramSocket()                             | 构造数据报套接字并将其绑定到本地主机上的任何可用端口。 |
| -------------------------------------------- | ------------------------------------------------------ |
| DatagramSocket(int port)                     | 构造数据报套接字并将其绑定到本地主机上的指定端口。     |
| DatagramSocket(int port,  InetAddress laddr) | 创建一个数据报套接字，绑定到指定的本地地址和端口。     |

通过上面三个构造器中的任意一个即可创建一个DatagramSocket实例，之后，就可以通过send、receive两个方法来接收和发送数据。

当程序使用UDP协议时，实际上并没有明显的服务器端和客户端，因为双方都需要先建立一个DatagramSocket对象，用来接收或发送数据报，然后使用DatagramPacket对象作为传输数据的载体。如果是定义接收端，则需指定端口，如果是定义发送端可以不指定端口，这时Java会随机分配一个可用的端口。

#### b.DatagramSocket类常用方法

| send(DatagramPacket p)    | 从该套接字发送数据报数据包。DatagramPacket包含指示要发送的数据、数据长度、远程主机的IP地址以及远程主机上的端口号的信息。 |
| ------------------------- | ------------------------------------------------------------ |
| receive(DatagramPacket p) | 从该套接字接收数据报数据包。当此方法返回时，DatagramPacket的缓冲区将填充所接收的数据。数据报包还包含发送方的IP地址和发送方机器上的端口号。 |

### 2). DatagramPacket类

DatagramPacket类表示数据报包，用来封装UDP传输的数据。

#### a.DatagramPacket类构造函数

| DatagramPacket(byte[] bs, int length)                        | 构造一个 DatagramPacket用于接收长度为length的数据报包。      |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| DatagramPacket(byte[] bs, int  length,InetAddress addr, int port) | 构造一个数据报包，用于将长度为length的数据报包发送到指定主机上的指定端口号。 |
| DatagramPacket(byte[] buf, int offset, int  length)          | 构造用于接收长度为length的数据包，指定缓冲区中的偏移量。     |
| DatagramPacket(byte[] buf, int offset, int  length, InetAddress address, int port) | 构造一个数据报包，用于将具有offset偏移量的数据包发送到指定主机上的指定端口号 |

DatagramPacket类构造方法的使用有两种情况：

```java
第一种情况，如果是接收数据，应该采用上面的第①个或第③个构造器生成一个DatagramPacket对象，给出接收数据的字节数组及其长度。然后调用DatagramSocket 的receive()方法接收数据报包，receive()将一直等待（即阻塞调用该方法的线程），直到收到一个数据报为止。
    例如如下代码：
DatagramPacket dPacket=new DatagramPacket(buf,  256);   socket.receive(dPacket);  

第二种情况，如果是发送数据，调用第②个或第④个构造器创建DatagramPacket对象，此时的字节数组里存放了想发送的数据。除此之外，还要给出完整的目的地址，包括IP地址和端口号。发送数据是通过DatagramSocket的send()方法实现的，send()方法根据数据报的目的地址来寻址以传送数据报。
    例如如下代码：
DatagramPacket packet = new  DatagramPacket(buf, length, address, port);     socket.send(packet);   
```

#### c.DatagramPacket类常用方法

| getData()    | 返回数据缓冲区。                                             |
| ------------ | ------------------------------------------------------------ |
| getLength()  | 返回要发送的数据的长度或接收到的数据的长度。                 |
| getAddress() | 返回该数据报发送或接收数据报的计算机的IP地址。               |
| getPort()    | 返回发送数据报的远程主机上的端口号，或从中接收数据报的端口号。 |

## 4.Java*基于*UDP网络编程的步骤

![image-20240705123057994](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/Java/image-20240705123057994.png)

接收端程序的基本步骤：

```
1）通过DatagramSocket(int port)创建接收端的数据报套接字对象，并绑定指定端口
2）通过DatagramPacket(byte[]buf,int length)创建接收端的数据报包对象，指定字节数组和长度用于接收数据报包
3）调用DatagramSocket的receive(DatagramPacket p)方法，接收数据报包
4）调用DatagramPacket类对象的getData()方法解析数据报包
5）关闭DatagramSocket
```

发送端程序的基本步骤：

```
1）通过DatagramSocket()或DatagramSocket(int port)创建发送端的数据报套接字对象。
2）通过DatagramPacket(byte[]buf, int length,InetAddress address,int port)创建数据报包对象，即要发送的数据报包，包含：数据、长度、接收端的IP地址和端口号。
3）调用DatagramSocket的send(DatagramPacket p)方法发送数据报包。
4）关闭数据报套接字。
```

# 七、数据库技术

## 1.JDBC技术 

### 1). JDBC常用类和接口

JDBC（Java Data Base Connectivity，Java数据库连接）是Java语言中用来规范客户端程序访问数据库的应用程序接口。JDBC提供了一系列的类和接口，用于编程开发，方便地进行数据访问和处理。这些类和接口位于java.sql包中。其描述见表8-1所示。

表8-1 JDBC常用类和接口表

| 类和接口        | 描述                                                         |
| --------------- | ------------------------------------------------------------ |
| Driver接口      | 一种规范，规范了作为Java开发人员该怎么去访问数据库。但这只是一个接口，具体接口的实现，是数据库厂商以驱动程序的形式实现的。 |
| DriverManager类 | 驱动程序管理器类，负责管理各种不同的驱动程序。驱动程序加载后，可通过该类的静态方法getConnection(URL)连接到一个数据库，并返回一个Connection对象。 |
| Connection接口  | 该接口的对象，表示与指定数据库的连接。只有连接成后，才能执行后续有关数据库的所有操作。 |
| Statement接口   | 将SQL语句传送给数据库并返回结果。即使用Connection连接到数据库，由Statement创建和执行SQL语句。 |
| ResultSet接口   | 针对有返回结果的SQL语句，ResultSet接口用来处理结果。         |

### 2). Driver接口

Driver接口处理与数据库服务器通信。很少直接直接使用驱动程序（Driver）对象，一般使用DriverManager中的对象，它用于管理此类型的对象。它也抽象与驱动程序对象工作相关的详细信息。

### 3). DriverManager类

DriverManager 类用来管理数据库中的所有驱动程序。他是JDBC的管理层，作用于用户和驱动程序之间，跟踪可用的驱动程序，并在数据库的驱动程序之间建立连接。如果通过 getConnection() 方法可以建立连接则经连接返回，否则抛出异常。

| **方法**                                                 | **功能描述**                                                 |
| -------------------------------------------------------- | ------------------------------------------------------------ |
| getConnection(String url, String user  ,String password) | 指定3个入口参数（依次是连接数据库的url，用户名，密码）来获取与数据库的连接 |
| setLoginTimeout()                                        | 获取驱动程序试图登入到某一数据库时可以等待的最长时间，以秒为单位 |
| println(String message)                                  | 将一条消息打印到当前JDBC日志流中                             |

### 4). Connection接口

Connection 接口代表与特定的数据库的连接，在连接上下文中执行SQL语句并返回结果。

| **方法**                                                     | **功能描述**                                                 |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| createStatement()                                            | 创建Statement对象                                            |
| createStatement(int resultSetType, int resultSetConcurrency) | 创建一个Statement对象，该对象将生成具有给定类型，并发性和可保存性的ResultSet对象 |
| preparedStatement()                                          | 创建预处理对象preparedStatement                              |
| isReadOnly()                                                 | 查看当前Connection  对象的读取模式是否为只读形式             |
| setReadOnly()                                                | 设置当前Connection  对象的读写模式，默认是非只读模式         |
| commit()                                                     | 使所有上一次提交/回滚后进行更改成为持久更改，并释放此Connection 对象当前持有的所有数据库锁 |
| roolback()                                                   | 取消当前事务中进行的所有更改，并释放此Connection 对象当前持有的所有数据库锁 |
| close()                                                      | 立即释放此Connection  对象的数据库和JDBC资源，而不是等待他们被自动释放 |

### 5). Statement接口

Statement 接口用于在已经建立连接的基础上向数据库发送SQL语句。在JDBC中有3种Statement 对象，分别是Statement ，PreparedStatement 和 CallableStatement。Statement 对象用于执行不带参数的简单SQL语句，PreparedStatement 继承了 Statement ，用来执行动态的SQL语句，CallableStatement 继承了 PreparedStatement ，用于执行对数据库的储存过程的调用。

| **方法**                          | **功能描述**                                                 |
| --------------------------------- | ------------------------------------------------------------ |
| setInt(int index , int k)         | 将指定位置的参数设置为int值                                  |
| setFloat(int index , float f)     | 将指定位置的参数设置为float值                                |
| setLong(int index , long l)       | 将指定位置的参数设置为long值                                 |
| setDouble(int index , double d)   | 将指定位置的参数设置为double值                               |
| setBoolean(int index , boolean b) | 将指定位置的参数设置为boolean 值                             |
| setDate(int index , date date)    | 将指定位置的参数设置为date值                                 |
| setString(int index , String s )  | 将指定位置的参数设置为对应的String值                         |
| setNull(int index , intsqlType)   | 将指定位置的参数设置为SQL NULL                               |
| executeQuery()                    | 在此 PreparedStatement 对象中执行SQL查询，并返回该查询生成的 ResultSet 对象 |
| executeUpdate()                   | 执行前面包含的参数的动态INSERT,UPDATE 或 DELETE 语句         |
| clearParameters()                 | 清除当前所有参数的值                                         |

### 6). ResultSet接口

ResultSet 接口类似于一个临时表，用来暂时存放数据库查询操作所获得的结果集。ResultSet 实例具有指向当前数据行的指针，指针开始的位置在第一条记录的前面，通过next()方法可将指针向下移动。

| **方法**            | **功能描述**                                                 |
| ------------------- | ------------------------------------------------------------ |
| geInt()             | 以int形式获取此ResultSet 对象当前行的指定列值。如果列值是NULL，则返回0 |
| getFloat()          | 以float形式获取此ResultSet 对象当前行的指定列值。如果列值是NULL，则返回0 |
| getDate()           | 以data形式获取此ResultSet 对象当前行的指定列值。如果列值是NULL，则返回null |
| getBoolean()        | 以boolean形式获取此ResultSet 对象当前行的指定列值。如果列值是NULL，则返回null |
| getString()         | 以String形式获取此ResultSet 对象当前行的指定列值。如果列值是NULL，则返回null |
| getObject()         | 以Object形式获取此ResultSet 对象当前行的指定列值。如果列值是NULL，则返回null |
| first()             | 将指针移到当前记录的第一行                                   |
| last()              | 将指针移到当前记录的最后一行                                 |
| next()              | 将指针向下移一行                                             |
| beforeFirst()       | 将指针移到集合的开头（第一行位置）                           |
| afterLast()         | 将指针移到集合的尾部（最后一行位置）                         |
| absolute(int index) | 将指针移到ResultSet 给定编号的行                             |
| isFrist()           | 判断指针是否位于当前ResultSet 集合的第一行。如果是返回true，否则返回false |
| isLast()            | 判断指针是否位于当前ResultSet 集合的最后一行。如果是返回true，否则返回false |
| updateInt()         | 用int值更新指定列                                            |
| updateFloat()       | 用float值更新指定列                                          |
| updatelLong()       | 用指定的long值更新指定列                                     |
| updateString()      | 用指定的String值更新指定列                                   |
| updateObject()      | 用Object值更新指定列                                         |
| updateNull()        | 将指定的列值修改为NULL                                       |
| updateDate()        | 用指定的date值更新指定列                                     |
| updateDouble()      | 用指定的double值更新指定列                                   |
| getrow()            | 查看当前行的索引号                                           |
| insertRow()         | 将插入行的内容插入到数据库                                   |
| updateRow()         | 将当前行的内容同步到数据库                                   |
| deleteRow()         | 删除当前行，但并不同步到数据库中，而是在执行close()方法后同步到数据库 |

## 2.使用JDBC访问数据库的步骤

访问数据库就是对数据库进行增加(Create)、检索(Retrieve)、更新(Update)和删除(Delete)等操作，简称CRUD操作，JDBC抽象了数据库进行交互的过程。

![image-20240705131738992](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/Java/image-20240705131738992.png)

```java
1）加载驱动。
加载驱动程序的方法是使用Class.forName()方法显式加载一个驱动程序，假如要加载MySQL驱动，代码如下：
  Class.forName("com.mysql.jdbc.Driver");  

2）建立连接。
采用DriverManager类中的getConnection方法实现与url所指定的数据源建立连接并返回一个Connection类的对象，以后对这个数据源的操作都是基于该Connection类对象。
    代码如下：
String  url = "jdbc:mysql://localhost:3306/bms";  
connection  conn = DriverManager.getConnection(url,”root”,”123456”);  

3）发送SQL
要执行SQL可以使用Statement或PreparedStatement，通过该对象向数据库发送SQL命令，实现增删改查操作。
如果对数据库系统发送SELECT语句，使用executeQuery()方法，查询成功则以Resultset对象的形式返回查询结果。
    代码如下：
Statement  stmt = conn.createStatement();      
String sql  = “SELECT * FROM book”;      
ResultSet  rs = stmt. executeQuery(sql);  
如果对数据库系统发送INSERT、UPDATE和DELETE不需要返回查询结果的SQL语句，则采用executeUpdate()方法。该方法返回类型为int,表示数据库表收到INSERT、UPDATE和DELETE语句影响的数据行数。
    代码如下：
Statement  stmt = conn.createStatement();  
String  sql = “DELETE FROM book WHERE bNo = 2”;  
int ret  = stmt.executeUpdate(sql);   

4）处理结果集。
对ResultSet对象进行处理后，可以将查询结果显示给用户。ResultSet对象包括一个包含所有查询结果的表。最初，游标位于结果集的第一行的前面，可以用next方法使指针下移一行以便对结果进行逐行处理，并用get方法获取记录的字段值。
    代码如下：
while(rs.next()){  //当游标指到最后一个的后面时，返回false      
    int bNo = rs.getInt("bNo");      S
        String title =  rs.getString("title");      
    String author =  rs.getString("author");      
    String bType =  rs.getString("bType");      
    int number = rs.getInt("number");  
}  

5）关闭查询语句及数据库连接。
在程序结束前应依次关闭Statement对象和Connection对象，使用close()方法。
    代码如下：
stmt.close();   conn.close();  
```

## 3.Java对数据库表执行CRUD操作

操作数据库是指对数据库进行增加(Create)、检索(Retrieve)、更新(Update)和删除(Delete)等操作，简称CRUD操作。创建BookDAO类，其中封装CRUD方法，添加图书addBook(BookInfo book)、查询图书queryByBookName(String bname)、删除图书delBookById(int id)、修改图书update(BookInfo book)。

### 1). 添加图书

```java
/**  * 添加图书  *   * @param book  * @return 布尔类型值  */  
public boolean  addBook(BookInfo book) {         
    boolean flag = false;         
    conn = DBManager.getConn();         
    String sqlString = "insert into  bookinfo(bookNo,bookname,author,publisher,price,publishtime,ISBN,amount)  values(?,?,?,?,?,?,?,?)";         
    try {             
        ps = conn.prepareStatement(sqlString);             
        ps.setString(1, book.getBookNo());             
        ps.setString(2, book.getBookname());             
        ps.setString(3, book.getAuthor());             
        ps.setString(4, book.getPublisher());             
        ps.setDouble(5, book.getPrice());             
        ps.setString(6, book.getPublishtime());             
        ps.setString(7, book.getISBN());             
        ps.setInt(8, book.getAmount());             
        flag = ps.executeUpdate() != 0 ? true : false;         
    } catch (Exception e) {             
        e.printStackTrace();         
    }         
    return flag;  
}  

首先使用insert  into语句并提供占位符构建插入记录的sql字符串，
然后为每个占位符设置值，即Java对象的相对应的属性值，
再通过PrepareStatement对象传递SQL命令，最后调用该对象的executeUpdate()方法完成插入操作
```

### 2). 查询图书

```java
/**  * 根据图书名查询  *   * @param bname  * @return 图书列表  */  
public List<BookInfo>  queryByBookName(String bname) {         
    List<BookInfo> bookList = new  ArrayList<BookInfo>();         
    conn = DBManager.getConn();         
    String sqlString = "select * from bookinfo where  bookname like ?";         
    try {             
        ps = conn.prepareStatement(sqlString);             
        bname = "%" + bname + "%";             
        ps.setString(1, bname);             
        ResultSet rs = ps.executeQuery();             
        while (rs.next()) {                
            int bookId = rs.getInt("ID");                
            String bookNo =  rs.getString("bookNo");                
            String bookname =  rs.getString("bookname");                
            String author =  rs.getString("author");                
            String publisher =  rs.getString("publisher");                
            String publishtime =  rs.getString("publishtime");                
            double price =  rs.getFloat("price");                
            String ISBN =  rs.getString("ISBN");                
            int amount =  rs.getInt("amount");                
            BookInfo book = new BookInfo(bookNo,  bookname, author);                
            book.setId(bookId);                
            book.setPublisher(publisher);                
            book.setPublishtime(publishtime);                
            book.setISBN(ISBN);                
            book.setPrice(price);                
            book.setAmount(amount);                
            bookList.add(book);             
        }         
    } catch (SQLException e) {             
        // TODO Auto-generated catch block             
        e.printStackTrace();         
    }         
    return bookList;      
}  

首先使用select from where 语句并提供占位符构建查询记录的sql字符串，
然后为每个占位符设置值，这里使用模糊查询bname = "%" + bname + "%";
再通过PrepareStatement对象传递SQL命令，调用该对象的executeQuery ()方法完成查询操作，返回结果集给rs。最后对rs进行解析，转换为Java对象，添加到bookList集合中并从该方法带回
```

### 3). 删除图书

```java
/**  * 根据图书的ID删除图书  *   * @param id  * @return  */  
public boolean **delBookById**(int id) {         
    boolean  flag = false;         
    conn  = DBManager.getConn();         
    String  sql = "delete from bookinfo where ID=?";         
    try  {             
        ps  = conn.prepareStatement(sql);             
        ps.setInt(1,  id);             
        if  (ps.execute()) {                
            flag  = true;             
        }  else {                
            flag  = false;             
        }         
    }  catch (SQLException e) {            
        //  TODO Auto-generated catch block             
        e.printStackTrace();         
    }         return  flag;  
}  

首先使用delete from 语句并提供占位符构建删除记录的sql字符串，
然后为每个占位符设置值，这里使用id。
再通过PrepareStatement对象传递SQL命令，调用该对象的execute ()方法完成删除操作。
```

### 4). 修改图书

```java
/**  * 根据图书进行修改其信息  *   * @param book  * @return  */  
public boolean **update**(BookInfo  book) {         
    boolean flag = false;         
    conn = DBManager.getConn();         
    String sql = "update bookinfo set bookNo =  ?,bookname = ?,author=?,publisher=?,price=?,publishtime=?,ISBN=?,amount=?  where ID=?";         
    try {             
        ps = conn.prepareStatement(sql);             
        ps.setString(1, book.getBookNo());             
        ps.setString(2, book.getBookname());             
        ps.setString(3, book.getAuthor());             
        ps.setString(4, book.getPublisher());             
        ps.setDouble(5, book.getPrice());             
        ps.setString(6, book.getPublishtime());             
        ps.setString(7, book.getISBN());             
        ps.setInt(8, book.getAmount());             
        ps.setInt(9, book.getId());             
        flag = ps.executeUpdate() > 0 ? true :  false;         
    } catch (Exception e) {             
        e.printStackTrace();         
    }         
    return flag;  
}  

首先使用update set 语句并提供占位符构建更新记录的sql字符串，
然后为每个占位符设置值，即为给定Java对象的相对应的属性值,
再通过PrepareStatement对象传递SQL命令，调用该对象的executeUpdate ()方法完成删除操作
```

## 2.第三方组件

### 1). 第三方组件的概念

```
第三方组件是针对某种软件在应用功能上的不足或缺陷，而由软件编制方以外的其他公司、组织或个人开发的相关组件。第三方组件一般是自定义组件或者用户组件，它们继承自Java中的某些基类，重写或者扩展了一些方法和属性，从而能实现某些新的功能，同时它们有较大的可定制性，可以根据使用者的需要设置不同的特性，从而完全适应特定项目的需求，比如一些日期组件，数据组件等。
```

### 2). 一些常用的第三方组件

```
第三方组件的范围很广，简单的第三方组件，如按钮、文本框等，复杂的第三方组件，可以包括报表组件、表格组件和文字处理组件等。也会有一些组件套包，它是由一系列组件组成，通常包括表格、报表、图表、菜单、工具栏、数据输入验证等。这里列出了一些较为常用的组件。
    1）Commons Math，Apache上一个轻量级自容器的数学和统计计算方法包，包含大多数常用的数值算法。
    2）Apache Log4j，一个日志开源项目，可以控制每一条日志的信息级别、生成过程、输出方式、输出格式。
    3）Jackson，用来处理JSON格式数据的Java类库，可以将Java对象转换成json对象和xml文档，同样也可以将json、xml转换成Java对象。
    4）JFreeChart，Java平台上的一个开放的图表绘制类库。它完全使用Java语言编写，是为applications、applets、servlets以及JSP等使用所设计的。
    5）C3P0，一个开源的JDBC连接池，它实现了数据源和JNDI绑定，支持JDBC3规范和JDBC2的标准扩展。
    6）TensorFlow，一个机器学习框架，是一个使用数据流图进行数值计算的开源软件库。
```

### 3). 第三方组件的使用方法

```
1）下载第三方组件相应的依赖包jar包文件。
2）将jar包导入到Java工程项目中。
3）引用jar包的接口、类、方法等编写应用程序
```

## 3.DBCP技术

### 1). 数据库连接池的概念

```
池(Pool)，是一个资源的集合，当使用的时候按照需要去取，使用完了就回收。池技术在一定程度上可以明显优化服务器应用程序的性能、提高程序执行效率和降低系统资源开销，被广泛应用在服务器端软件的开发上。广义的池有：数据库连接池、线程池、内存池、对象池等。

数据库连接池（Connection Pool）技术的核心思想是：连接复用，通过建立一个数据库连接池以及一套连接使用、分配、管理策略，使得该连接池中的连接可以得到高效、安全的复用，避免了数据库连接频繁建立、关闭的开销。

Java中常用的数据库连接池有：DBCP、C3P0、Druid。 还有其他的如：BoneCP、Proxool、DDConnectionBroker、DBPool、XAPool、Primrose、SmartPool、MiniConnectionPoolManager等。
```

### 2). DBCP数据库连接池

DBCP是使用最多的开源的数据库连接池，其配置方便，很多开源和tomcat应用例子都是使用的这个连接池。

```
其相关依赖包包含以下三个jar包：
    commons-collections-3.1.jar
    commons-dbcp-1.2.1.jar
    commons-pool-1.2.jar
```

DBCP参数说明表

| 参数            | 说明                                                |
| --------------- | --------------------------------------------------- |
| username        | 传递给JDBC驱动的用于建立连接的用户名                |
| password        | 传递给JDBC驱动的用于建立连接的密码                  |
| url             | 传递给JDBC驱动的用于建立连接的URL                   |
| driverClassName | 使用的JDBC驱动的完整有效的Java 类名                 |
| initialSize     | 连接池启动时创建的初始化连接数量                    |
| maxActive       | 连接池在同一时间能够分配的最大活动连接的数量        |
| maxIdle         | 连接池中容许保持空闲状态的最大连接数量              |
| minIdle         | 连接池中容许保持空闲状态的最小连接数量,低于这个数量 |
| maxWait         | 当没有可用连接时,连接池等待连接被归还的最大时间     |

### 3). Java使用DBCP

#### a.导入DBCP的jar包到项目中

首先下载DBCP所需的jar包，然后导入jar包到工程中。在项目名上右击，依次选择【Build Path】-->【Configure Build Path...】-->【Java Build Path】 -->【Libraries】-->【Add External Jars...】找到下载的jar包，点击【打开】。

#### b.编程实现

```java
首先准备数据库、表，这里以MySQL数据库为例。数据源配置定义在包config下的dbcp.properties属性文件里。
    dbcp.properties代码如下：
########DBCP\u914D\u7F6E\u6587\u4EF6##########  
#\u9A71\u52A8\u540D  
driverClassName=com.mysql.jdbc.Driver  
#url  
url=jdbc:mysql://127.0.0.1:3306/test  
#\u7528\u6237\u540D  
username=root  
#\u5BC6\u7801  
password=123456  
#\u521D\u8BD5\u8FDE\u63A5\u6570  
initialSize=30  
#\u6700\u5927\u6D3B\u8DC3\u6570  
maxTotal=30  
#\u6700\u5927idle\u6570  
maxIdle=10  
#\u6700\u5C0Fidle\u6570  
minIdle=5  
#\u6700\u957F\u7B49\u5F85\u65F6\u95F4(\u6BEB\u79D2)  
maxWaitMillis=1000 #\u7A0B\u5E8F\u4E2D\u7684\u8FDE\u63A5\u4E0D\u4F7F\u7528\u540E\u662F\u5426\u88AB\u8FDE\u63A5\u6C60\u56DE\u6536(\u8BE5\u7248\u672C\u8981\u4F7F\u7528removeAbandonedOnMaintenance\u548CremoveAbandonedOnBorrow)  
#removeAbandoned=true  
removeAbandonedOnMaintenance=true  
removeAbandonedOnBorrow=true #\u8FDE\u63A5\u5728\u6240\u6307\u5B9A\u7684\u79D2\u6570\u5185\u672A\u4F7F\u7528\u624D\u4F1A\u88AB\u5220\u9664(\u79D2)(\u4E3A\u914D\u5408\u6D4B\u8BD5\u7A0B\u5E8F\u624D\u914D\u7F6E\u4E3A1\u79D2)  removeAbandonedTimeout=1  

然后封装DBCPConnPool类，用于使用DBCP连接池连接MySQL数据库。该类用于配置数据源、从连接池中获取一个连接。
    DBCPConnPool类代码如下：
public class DBCPConnPool {      
    private  static Properties properties = new Properties();      
    private  static DataSource dataSource;         
    // 加载DBCP配置文件      
    static {         
        try  {             
            FileInputStream  is = new FileInputStream("config/dbcp.properties");   
            properties.load(is);         
        }  
        catch (IOException e) {             
            e.printStackTrace();         
        }            
        try  {             
            dataSource  = BasicDataSourceFactory.createDataSource(properties);       
        }  catch (Exception e) {                      
         e.printStackTrace();         
            }      
       }         
	// 从连接池中获取一个连接      
    public  static Connection getConnection() {         
        Connection  connection = null;         
        try  {             
            connection  = dataSource.getConnection();         
        }  catch (SQLException e) {             
            e.printStackTrace();         
        }         
        try  {             
            connection.setAutoCommit(false);         
        }  catch (SQLException e) {             
            e.printStackTrace();         
        }         
        return  connection;      
    }  
}   

再封装DAO类，其中定义对数据库表的CRUD操作方法，需要使用DBCP连接池连接数据库。例如，public List<Book> findAll()方法，是查询所有图书。
    代码如下：
/**       
* 查询所有的图书          
* @return 图书结果集       
*/      
 public List<Book> findAll() {         
    List<Book> bookList = new  ArrayList<Book>();         
    conn = DBCPConnPool.*getConnection*();         
    String sql = "select * from  Book";         
    try {             
        ps =  conn.prepareStatement(sql);             
        rs = ps.executeQuery();               
        while (rs.next()) {                
            Book book = new  Book();                
            book.setId(rs.getInt(1));               
            book.setBookNo(rs.getString(2));           
            book.setBookname(rs.getString(3));                
            book.setAuthor(rs.getString(4));               
            book.setPublisher(rs.getString(5));                
            book.setPrice(rs.getDouble(6));                
            book.setPublishtime(rs.getString(7));                
            book.setISBN(rs.getString(8));                
            book.setAmount(rs.getInt(9));                
            bookList.add(book);             
        }         
    } catch (SQLException e) {             
        // TODO Auto-generated  catch block             
        e.printStackTrace();         
    }         
    return bookList;         
}  

最后使用JUnit测试findAll()方法。
    代码如下：
@Test      
public void testfindAll(){         
    List<Book> bookList=new  ArrayList<>();         
    BookDAOWithDBCPConnPool bp=new BookDAOWithDBCPConnPool();         
    bookList=bp.findAll();         
    for(Book b:bookList){             
        System.*out*.println(b.toString());         
    }      
}  
```

## 4.JSON技术

### 1). JSON概念

JSON(JavaScript Object Notation, JS 对象简谱) 是一种轻量级的数据交换格式。易于阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。JSON本质是一个字符串，可用于表示对象和数组。

JSON对象是由花括号括起来的逗号分割的成员构成，成员是字符串键和值由逗号分割的键值对组成

```json
例如：
{      
    "name":"John Doe",      
    "age":18,      
    "address":{        
        "country":"china",        
        "zip-code":"10000"    
    }  
}  

JSON数组是由方括号括起来的一组值构成，例如：
[    
    {      
        "name":"张三 ",      
        "age":18    },    
    {      
        "name":"李四",      
        "age":19    },    
    {      
        "name":"王五",      
        "age":17    
    }  
]  
```

### 2). 第三方JSON库GSON

```
目前对于Java开源的JSON类库有很多种，其中主流的JSON主要有：json-lib、Jackson、Gson和FastJson等。

Gson是一个开源的基于Java的类库，用于将Java对象序列化为JSON表示，也可用于将JSON字符串转换为等效的Java对象。Gson可以处理任意Java对象。Gson易于使用、性能优、无依赖性，其支持泛型、支持复杂的内部类。Gson依赖包是gson-2.8.6.jar
```

### 3). Java使用JSON处理查询结果

#### a.导入GSON的jar包到项目中

```
先下载Gson所需的jar包gson-2.8.6.jar，然后导入jar包到工程中。在项目名上右击，依次选择【Build Path】-->【Configure Build Path...】-->【Java Build Path】 -->【Libraries】-->【Add External Jars...】找到下载的jar包，点击【打开】。
```

#### b.编程实现

```java
Gson提供了toJson()方法将Java对象转换成JSON字符串。

Java对象转JSON字符串如下所示：
Gson gson = new  Gson();  
Person person=new  Person() ;  
String str = gson.toJson(person);  

List对象转JSON字符串如下所示：
Gson gson = new  Gson();  
List<Person>  persons = new ArrayList<Person>();  
for (int i = 0; i <  10; i++) {  
    Person p = new Person();  
    p.setName("name" + i);  
    p.setAge(i * 5);  
    persons.add(p);  
}  
String str = gson.toJson(persons);  

Gson提供了fromJson()方法来实现从Json字符串到Java实体对象的方法。
JSON字符串转Java对象类型如下所示：
String  str=” [{"name":"name0","age":0}]” ; 
Person person = gson.fromJson(str, Person.class);  

JSON格式的字符串转List列表类型如下所示：
List<Person> ps  = gson.fromJson(str, new TypeToken<List<Person>>(){}.getType());  for(int i = 0; i <  ps.size() ; i++){    
    Person p = ps.get(i);     
    System.out.println(p.toString());  
}  
其中TypeToken是Gson提供的数据类型转换器，可以支持各种数据集合类型转换。
```

## 5.JFreeChar技术

### 1). 数据可视化

```
数据可视化是根据数据的特性，如时间信息和空间信息等，以合适的可视化方式，例如图表(Chart)、图(Diagram)和地图(Map)等，将数据直观地展现出来，以帮助人们理解数据。数据可视化是软件项目生命周期中的最后一步，也是最重要的一步。数据可视化的框架主要有D3、ECharts及其他小框架JFreeChart等。
```

### 2). JFreeChart

```
JFreeChart是开源项目，它主要用来可视化各种各样的图表，包括：饼图、柱状图(普通柱状图以及堆栈柱状图)、线图、区域图、分布图、混合图、甘特图以及一些仪表盘等等。

JFreeChart主要由chart和data组成，其中chart与图形本身有关，data与图形显示的数据有关。核心类主要有：
    org.jfree.chart.JFreeChart：图表对象，任何类型的图表的最终表现形式都是在该对象进行一些属性的定制。JFreeChart引擎本身提供了一个工厂类用于创建不同类型的图表对象。
    org.jfree.data.category.XXXDataSet:数据集对象，用于提供显示图表所用的数据。根据不同类型的图表对应着很多类型的数据集对象类。

JFreeChart需要2个jar依赖包:jcommon-版本号.jar、jfreechart-版本号.jar
```

### 3). Java使用JFreeChart显示查询结果

#### a.导入JFreeChart依赖包到项目中

首先下载JFreeChart依赖包。然后将需要的2个jar依赖包导入到工程项目中。在项目名上右击，依次选择【Build Path】-->【Configure Build Path...】-->【Java Build Path】 -->【Libraries】-->【Add External Jars...】找到下载的jar包，点击【打开】。

#### b.编程实现

```java
第一步，建立DataSet数据源。使用CategoryDataset的子类org.jfree.data.defaultCategoryDataset创建数据集dataset，再用addValue（）方法把数据库查询的结果集加入到dataset中，建立包含数值的二维阵列，addValue中包含三个参数：数据、图例和轴向名称。			代码如下：
public  static CategoryDataset createDataSet() {         
    // 实例化DefaultCategoryDataset对象         
    DefaultCategoryDataset dataSet =  new DefaultCategoryDataset();        
    // 向数据集合中添加数据         
    BookService bookService = new  BookService();         
    Map<String, Integer> map =  new HashMap<String, Integer>();         
    // 获取查询数据         
    map =  bookService.statisticAmountByPublisher();         
    for (String s : map.keySet()) {             
        dataSet.addValue(map.get(s),  s, s);         
    }         
    return dataSet;         
}  

第二步，创造JFreeChart。使用ChartFactory工厂类来创造一个JFreeChart实例。其中，指定数据集，并设置图形显示的属性，包括：柱到图上下边的距离、每个柱的颜色、标题字体等等。
			代码如下：
public  static JFreeChart createChart() {            
    // 通过ChartFactory创建JFreeChart         
    StandardChartTheme  standardChartTheme = new StandardChartTheme("CN"); // 创建主题样式
    standardChartTheme.setExtraLargeFont(new  Font("隶书", Font.*BOLD*, 20)); // 设置标题字体  
    standardChartTheme.setRegularFont(new  Font("宋体", Font.*PLAIN*, 15)); // 设置图例的字体
    standardChartTheme.setLargeFont(new  Font("宋体", Font.*PLAIN*, 15)); // 设置轴向的字体
    ChartFactory.*setChartTheme*(standardChartTheme);//  设置主题样式         
    // 通过ChartFactory创建JFreeChart         
    JFreeChart chart = ChartFactory.*createBarChart3D*(               
        "图书库存统计",  // 图表标题                
        "出版社",  // 横轴标题                
        "库存量（本）",  // 纵轴标题                
        reateDataSet),  // 数据集合                
        PlotOrientation.*VERTICAL*,  // 图表方向                 
        true,  // 是否显示图例标识                
        false, // 是否显示tooltips                
        false);// 是否支持超链接         
        return chart;         
}     

第三步，创建显示图形的容器ChartFrame。
			代码如下：
// 本地测试      
public static void main(String[] args)  {         
    ChartFrame cf = new ChartFrame("图书库存统计", *createChart*());         
    cf.pack();         
    cf.setVisible(true);      
}  
```

# 八、模式设计

## 1.设计模式

### 1). Java设计模式概述

1995年，GoF（Gang of Four，四人组）合作出版了《设计模式：可复用面向对象软件的基础》一书，共收录了 23 种设计模式，从此树立了软件设计模式领域的里程碑，人称“GoF设计模式”。23种Java设计模式

| 范围\目的 | 创建型模式                   | 结构型模式                         | 行为型模式                                                   |
| --------- | ---------------------------- | ---------------------------------- | ------------------------------------------------------------ |
| 类模式    | 工厂方法                     | 适配器                             | 模板方法  解释器                                             |
| 对象模式  | 单例  原型  抽象工厂  建造者 | 代理  桥接  装饰  外观  享元  组合 | 策略  命令  职责链  状态  观察者  中介者  迭代器  访问者  备忘录 |

### 2). Java设计模式概念

有关软件设计模式的定义很多，有些从模式的特点来说明，有些从模式的作用来说明。本教程给出的定义是大多数学者公认的，从以下几个方面来理解。

Java软件设计模式（Software Design Pattern），又称Java设计模式，**是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。**它描述了在软件设计过程中的一些不断重复发生的问题，以及该问题的解决方案。也就是说，它是解决特定问题的一系列套路，是前辈们的代码设计经验的总结，具有一定的普遍性，可以反复使用。**其目的是为了提高代码的可重用性、代码的可读性和代码的可靠性。**

设计模式使人们可以更加简单方便的复用成功的设计和体系结构。将已证实的技术表述成设计模式也会使新系统开发者更加容易理解其设计思路。

### 3). Java设计模式的意义

设计模式的本质是面向对象设计原则的实际运用，是对类的封装性、继承性和多态性以及类的关联关系和组合关系的充分理解。正确使用设计模式具有以下优点。

```
可以提高程序员的思维能力、编程能力和设计能力
使程序设计更加标准化、代码编制更加工程化，使软件开发效率大大提高，从而缩短软件的开发周期
使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强
```

当然，软件设计模式只是一个引导。在具体的软件开发中，必须根据设计的应用系统的特点和要求来恰当选择。对于简单的程序开发，可能写一个简单的算法要比引入某种设计模式更加容易。但对大项目的开发或者框架设计，用设计模式来组织代码显然更好

### 4). 软件设计模式的原则

```
开闭原则
里氏替换原则
依赖倒置原则
单一职责原则
接口隔离原则
迪米特法则
合成复用原则
```

### 5). Java设计模式的基本要素

软件设计模式使人们可以更加简单方便地复用成功的设计和体系结构，它通常包含以下几个基本要素：模式名称、别名、动机、问题、解决方案、效果、结构、模式角色、合作关系、实现方法、适用性、已知应用、例程、模式扩展和相关模式等，其中最关键的元素包括以下 4 个主要部分。

**a.模式名称**

```
每一个模式都有自己的名字，通常用一两个词来描述，可以根据模式的问题、特点、解决方案、功能和效果来命名。模式名称（PatternName）有助于我们理解和记忆该模式，也方便我们来讨论自己的设计
```

**b.问题**

```
问题（Problem）描述了该模式的应用环境，即何时使用该模式。它解释了设计问题和问题存在的前因后果，以及必须满足的一系列先决条件
```

**c.解决方案**

```
模式问题的解决方案（Solution）包括设计的组成成分、它们之间的相互关系及各自的职责和协作方式。因为模式就像一个模板，可应用于多种不同场合，所以解决方案并不描述一个特定而具体的设计或实现，而是提供设计问题的抽象描述和怎样用一个具有一般意义的元素组合（类或对象的 组合）来解决这个问题
```

**d.效果**

```
描述了模式的应用效果以及使用该模式应该权衡的问题，即模式的优缺点。主要是对时间和空间的衡量，以及该模式对系统的灵活性、扩充性、可移植性的影响，也考虑其实现问题。显式地列出这些效果（Consequence）对理解和评价这些模式有很大的帮助
```

### 6).常见Java设计模式及其应用场景

#### a.创建型

```
在创建对象的过程中尽量隐藏创建细节，不直接使用new。 

1. 单例（Singleton）模式：保证一个类仅有一个实例并提供一个全局访问点，从而方便对实例的个数控制并节约系统资源。
其应用场景是：
如果希望在系统中某个类的对象只能存在一个；创建一个对象需要消耗过多的资源，比如IO和数据库连接等，单例模式是最好的解决方案。

2. 工厂方法（Factory Method）模式：定义一个用于创建产品的接口，由子类决定生产什么产品。
其应用场景是：
在编码时不能预见需要创建哪种类的实例；系统不应依赖于产品类实例如何被创建、组合和表达的细节。

3. 抽象工厂（AbstractFactory）模式：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。
其应用场景是：
程序需要处理不同系列的相关产品，但是又不希望它依赖于这些产品的具体类时，可以使用抽象工厂。

4. 建造者（Builder）模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。
其应用场景是：
一般用在构建流程或者组成部件固定的场合，将这些部件分开构建成为组件对象，再将这些组件对象整合成为目标对象。
```

#### b.结构型

```
将几个对象组织成一个结构，主要关注类和对象的继承、组合。

1. 代理（Proxy）模式：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。
其应用场景是：
一个对象，比如很大的一张图像，加载前可以用一个占位的图像来替代；一个过程计算需要等待很长时间，并且需要再计算过程中展示结果；一个存在于远程的对象，通过网络载入需要较长的时间；验证用户对对象的访问权限。

2. 桥接（Bridge）模式：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。
其应用场景是：
当一个类存在两个独立变化的维度，且这两个维度都需要进行扩展时；当一个系统不希望使用继承或因为多层次继承导致系统类的个数急剧增加时；当一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性时。

3. 外观（Facade）模式：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。
其应用场景是：
对分层结构系统构建时，使用外观模式定义子系统中每层的入口点可以简化子系统之间的依赖关系；当一个复杂系统的子系统很多时，外观模式可以为系统设计一个简单的接口供外界访问；当客户端与多个子系统之间存在很大的联系时，引入外观模式可将它们分离，从而提高子系统的独立性和可移植性。
```

#### c.行为型

```
关注对象之间的通信。 

1. 观察者（Observer）模式：又称发布/订阅模式，定义了对象间一对多关系，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。
其应用场景是：
对一个对象状态的更新，需要其他对象同步更新，而且其他对象的数量动态可变；对象仅需要将自己的更新通知给其他对象而不需要知道其他对象的细节。

2. 策略（Strategy）模式：定义了一系列算法，分别封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。
其应用场景是：
一件事情有很多方案可以实现，可以在任何时候决定采用哪一种实现，未来可能增加更多的方案，方案的变化不会影响到使用方案的客户。
```

## 2.建造者模式

### 1). 建造者模式的概念

建造者模式(Builder Pattern)是将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。建造者模式是一种对象创建型模式。

任何一种软件设计模式的最终目标都是实现软件的高内聚、低耦合，实现易扩展、易维护。建造者设计模式的实质是解耦组装过程和创建具体部件，使得不用去关心每个部件是如何组装的，只需要知道各个部件是干什么的（实现什么功能）。建造者模式使得产品内部的结构表现可以独立变化，客户端不需要知道产品内部结构的组成细节。

### 2). 建造者模式的适用场合

```
1）需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员属性。

2）需要生成的产品对象的属性相互依赖，需要指定其生成顺序。

3）对象的创建过程独立于创建该对象的类。在建造者模式中通过引入了指挥者类，将创建过程封装在指挥者类中，而不在建造者类和客户类中。

4）隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品。
```

### 3). 建造者设计模式的结构

建造者设计模式的类图如图9-1所示。

![image-20240705124347637](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/Java/image-20240705124347637.png)

```
建造者设计模式主要包括以下四个角色：
1）产品（Product）：它是包含多个组成部件的复杂对象，由具体建造者来创建其各个部件。

2）抽象建造者（Builder）：它是一个包含创建产品各个子部件的抽象方法的接口，通常还包含一个返回复杂产品的方法 getResult()。

3）具体建造者(Concrete Builder）：实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。

4）指挥者（Director）：它调用建造者对象中的部件构造与装配方法完成复杂对象的创建，在指挥者中不涉及具体产品的信息。
```

建造者模式包含两个很重要的部分：Builder接口和Director。Builder定义了如何构建各个部件，也就是知道每个部件功能如何实现，以及如何装配这些部件到产品中去；Director是指导如何组合来构建产品，也就是说Director负责整体的构建算法，而且通常是分步骤地来执行。不管如何变化，建造模式都存在这么两个部分，建造模式的重心在于分离构建算法和具体的构造实现，从而使得构建算法可以重用。

### 4).Java建造者设计模式的实现过程

建造者设计模式的关键过程是，Client创建 Director 对象并配置它所需要的 Builder 对象；Director负责通知 Builder建造 Product 的部件；Builder处理 Director 的请求，构造Product 的部件并返回给Director；Client从Director 处获得Product。

因此，建造者设计模式的编程实现过程如下：

```java
						1. 定义产品类Product
一般一个较为复杂的产品对象是由一系列部件组成。在本类图中，产品类是一个具体的类，
                            其典型代码如下：
//Product类，由多个部件组成。  
public class Product {   
    private  String partA; 
    //可以是任意类型   
    private  String partB;   
    private  String partC;   
    //partA的Getter方法和Setter方法省略   
    //partB的Getter方法和Setter方法省略   
    //partC的Getter方法和Setter方法省略  
}  

						2. 定义抽象建造者Builder。
Builder角色在这里使用接口Builder，一般而言，此接口独立于应用程序的商业逻辑。
                            其典型代码如下：
public interface Builder  {    
	public void buildPartA();  
	public void buildPartB();  
    public void buildPartC();    
    public Product getResult() ;  
}  
引入抽象建造者的目的是为了将建造的具体过程交于它的子类或实现类来实现，这样更容易扩展。其有两种抽象方法，一个用来建造产品(buildPart)，一个是用来返回产品(getResult)
模式中直接创建产品对象的是具体建造者 (ConcreteBuilder)角色。一般来说，产品所包含的零件数目与建造方法的数目相符。换言之，有多少零件，就有多少相应的建造方法。

						3. 定义具体建造者ConcreteBuilder。
ConcreteBulider类是实现抽象类或接口的所有未实现的方法，具体来说一般是两项任务：组建产品和返回组建好的产品。一般有多少个产品就有多少个具体建造者。
                            其典型代码如下：
public class  ConcreteBuilder1 implements Builder{       
    private Product product=new Product();      
    @Override    
    public void buildPartA() {             
    }       
    @Override    
    public void buildPartB() {              
    }     
    @Override    
    public void buildPartC() {              
    }      
    @Override    
    public Product getResult() {            
        return product;    
    }     
}  

						4. 定义**指挥者类**Director**。**
指挥者类Director的作用主要有两个：一方面它隔离了客户与生产过程；另一方面它负责控制产品的生成过程。 
                            其典型代码如下：
public class Director{         
    private Builder builder;        
    //1 构造方法的方式注入builder对象      
    public Director(Builder builder)      {         
        this.builder=builder;      }        
    //2 set方法注入builder对象      
    public void setBuilder(Builder builder)      
    {         
        this.builder=builer;     
    }            
    public Product construct()      
    {         
        builder.buildPartA();         
        builder.buildPartB();         
        builder.buildPartC();         
        return builder.getResult();      
    }  
}   
指挥者角色是与客户端打交道的角色，指挥者将客户端创建产品的请求划分为对各个零件的建造请求，再将这些请求委派给具体建造者角色。指挥者类一般不与产品类发生依赖关系，与指挥者类直接交互的是建造者类，需要注入builder对象。有两种注入方式。构造注入和set注入。指挥者还有一个方法construct() 用于建造产品，委派给具体建造者角色，即通过builder的buildPartA()方法来建造。其控制构建各部分组件的顺序。

						5. 定义客户端Client
客户需要什么样的产品，交给Director，Director类注入Builder，由director的construct()方法返回产品给客户。具体建造产品的过程是construct()方法，其是通过调用concretebuilder的方法buildPartA()方法来建造产品。客户不需要知道具体的建造过程。其典型代码如下：
public class Client {       
    //客户不需要知道具体的建造过程。   
    public static void main(String[] args) {      
        // TODO 自动生成的方法存根        
        Director director=new Director();        
        Builder builder=new ConcreteBuilder1();      
        //指挥者调用concretebuilder的方法来建造产品。     
        director.setBuilder(builder);      
        Product p1= director.construct();      
        p1.show();             
        Builder builder2=new ConcreteBuilder2();   
        director.setBuilder(builder2);      
        Product p2= director.construct();      
        p2.show();        
        System.out.println("==========");    
    }  
}  
```

## 3.抽象工厂模式

### 1). 抽象工厂设计模式的概念

抽象工厂模式（Abstract Factory Pattern），提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。该设计模式属于创建型模式。 

为了更清晰地理解抽象工厂模式，需要先引入两个概念，如图所示：

![image-20240705124950214](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/Java/image-20240705124950214.png)

```
产品等级结构：即产品的继承结构。如一个抽象类是电视机，其子类有海尔电视机、海信电视机、TCL电视机，则抽象电视机与具体品牌的电视机之间构成了一个产品等级结构。

产品族：指由同一个工厂生产的，位于不同产品等级结构中的一组产品。如海尔电器工厂生产的海尔电视机、海尔电冰箱。
```

使用抽象工厂模式一般要满足以下条件：

```
系统中有多个产品族，每个具体工厂创建同一族但属于不同等级结构的产品。
系统一次只可能消费其中某一族产品，即同族的产品一起使用。
```

### 2）. 抽象工厂模式的适用场合

```
在以下情况下可以使用抽象工厂模式：
1）一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是重要的。
2）系统中有多于一个的产品族，而每次只使用其中某一产品族。
3）属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来。
4）系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。
```

### 3). 抽象工厂设计模式的结构

![image-20240705125100378](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/Java/image-20240705125100378.png)

抽象工厂模式主要包含以下四个角色：

```
1）抽象工厂（Abstract Factory）：提供了创建产品的接口，它包含多个创建产品的方法 createProduct()，可以创建多个不同等级的产品。

2）具体工厂（Concrete Factory）：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。有多个具体工厂。

3）抽象产品（Abstract Product）：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。

4）具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间是多对一的关系。
```

### 5).Java抽象工厂模式的实现过程

```
创建抽象工厂接口，声明具体工厂的公共接口；
创建具体工厂类（实现抽象工厂接口），定义创建对应具体产品实例的方法；
创建抽象产品接口，定义抽象产品的公共接口；
创建具体产品类（实现抽象产品接口），定义具体产品的公共接口；
创建客户端类，客户端通过实例化具体的工厂类，并调用其创建不同目标产品的方法创建不同具体产品类的实例。
```

具体过程如下：

```java
1）抽象工厂：提供了产品的生成方法。
interface AbstractFactory {
	public AbstractProductA createProductA();
	public AbstractProductB createProductB();
}

2）具体工厂：实现了产品的生成方法。

class ConcreteFactory1 implements AbstractFactory {
    public AbstractProductA createProductA1() {
        System.out.println("具体工厂 1生成-->具体产品 A1...");
        return new ConcreteProductA1();
    }
    public AbstractProductB createProductB1() {
        System.out.println("具体工厂 1 生成-->具体产品 B1...");
        return new ConcreteProductB1();
    }
}
class ConcreteFactory2 implements AbstractFactory {
    public AbstractProductA createProductA2() {
        System.out.println("具体工厂 2生成-->具体产品 A2...");
        return new ConcreteProductA2();
    }
    public AbstractProductB createProductB2() {
        System.out.println("具体工厂 2 生成-->具体产品 B2...");
        return new ConcreteProductB2();
    }
}

3）抽象产品接口。
public interface AbstractProductA {``public void show();``}
public interface AbstractProductB {``public void show();``}

4）具体产品。
public class ConcreteProductA1 implements AbstractProductA {
    public void show(){}
}
public class ConcreteProductA2 implements AbstractProductA {
    public void show(){}
}
public class ConcreteProductB1 implements AbstractProductB {
    public void show(){}
}
public class ConcreteProductB2 implements AbstractProductB {public void show(){}
}

5）客户端类。
public static void main(String[] args) {
	// TODO Auto-generated method stub
	AbstractFactory af1, af2;
    AbstratcProductA pa1,pa2;
    AbstractProductB pb1, pb2;
    af1 = new ConcreteFactory1 ();
    af2 = new ConcreteFactory2 ();
    // 具体工厂生产不同种类不同等级产品
    // 具体工厂1生产产品
    pa1 = af1. createProductA1();
    pb1 = af1. createProductB1();
    System.*out*.println("具体工厂1生产：");
    pa1.show();``pb1.show();
    System.*out*.println("----------");
    // 具体工厂2生产产品
    pa2 = af2. createProductA2();
    pb2 = af2. createProductA2();
    System.*out*.println("具体工厂2生产：：");
    pa2.show();
    pb2.show();
}
```

# 九、软件工程

## 1.软件工程模型

### 1). 软件生命周期

根据我国国家标准《计算机软件开发规范》（GB8566—8），软件生命周期包含：软件定义、软件开发、软件运行维护三个时期，并可以细分为可行性研究、项目计划、需求分析、概要设计、详细设计、编码实现与单元测试、系统集成测试、系统确认验证、系统运行与维护等几个阶段。这是软件生命周期的基本构架，在实际软件项目中，根据所开发软件的规模、种类，软件开发机构的习惯做法，以及软件开发中所采用的技术方法等，可以对各阶段进行必要的合并、分解或补充。

#### a.软件定义期

软件定义是软件项目的早期阶段，主要由软件系统分析人员和用户合作，针对有待开发的软件系统进行分析、规划和规格描述，确定软件是什么，为今后的软件开发做准备。这个时期往往需要分阶段地进行以下几项工作。

```
1）软件任务立项
软件项目往往开始于任务立项，并需要以“软件项目立项报告”的形式针对项目的名称、性质、目标、意义和规模等作出回答，以此获得对准备着手开发的软件系统的最高层描述。

2）项目可行性分析
在软件任务立项报告被批准以后，接着需要进行项目可行性分析。可行性分析是针对准备进行的软件项目进行的可行性风险评估。因此，需要对准备开发的软件系统提出高层模型，并根据高层模型的特征，从技术可行性、经济可行性和操作可行性这三个方面，以“可行性研究报告”的形式，对项目作出是否值得往下进行的回答，由此决定项目是否继续进行下去。

3)制定项目计划
在确定项目可以进行以后，接着需要针对项目的开展，从人员、组织、进度、资金、设备等多个方面进行合理的规划，并以“项目开发计划书”的形式提交书面报告。

4)软件需求分析
软件需求分析是软件规格描述的具体化与细节化，是软件定义时期需要达到的目标。需求分析要求以用户需求为基本依据，从功能、性能、数据、操作等多个方面，对软件系统给出完整、准确、具体的描述，用于确定软件规格。其结果将以“软件需求规格说明书”的形式提交。在软件项目进行过程中，需求分析是从软件定义到软件开发的最关键步骤，其结论不仅是今后软件开发的基本依据，同时也是今后用户对软件产品进行验收的基本依据。
```

#### b.软件开发期

在对软件规格完成定义以后，接着可以按照“软件需求规格说明书”的要求对软件实施开发，并由此制作出软件产品。这个时期需要分阶段地完成以下几项工作。

```
1）软件概要设计
概要设计是针对软件系统的结构设计，用于从总体上对软件的构造、接口、全局数据结构和数据环境等给出设计说明，并以“概要设计说明书”的形式提交书面报告，其结果将成为详细设计与系统集成的基本依据。模块是概要设计时构造软件的基本元素，因此，概要设计中软件也就主要体现在模块的构成与模块接口这两个方面上。结构化设计中的函数、过程，面向对象设计中的类、对象，它们都是模块。概要设计时并不需要说明模块的内部细节，但是需要进行全部的有关它们构造的定义，包括功能特征、数据特征和接口等。在进行概要设计时，模块的独立性是一个有关质量的重要技术性指标，可以使用模块的内聚、耦合这两个定性参数对模块独立性进行度量。

2）软件详细设计
设计工作的第二步是详细设计，它以概要设计为依据，用于确定软件结构中每个模块的内部细节，为编写程序提供最直接的依据。详细设计需要从实现每个模块功能的程序算法和模块内部的局部数据结构等细节内容上给出设计说明，并以“详细设计说明书”的形式提交书面报告。

3）编码和单元测试
编码是对软件的实现，一般由程序员完成，并以获得源程序基本模块为目标。编码必须按照“详细设计说明书”的要求逐个模块地实现。在基于软件工程的软件开发过程中，编码往往只是一项语言转译工作，即把详细设计中的算法描述语言转译成某种适当的高级程序设计语言。为了方便程序调试，针对基本模块的单元测试也往往和编码结合在一起进行。单元测试也以“详细设计说明书”为依据，用于检验每个基本模块在功能、算法与数据结构上是否符合设计要求。

4）系统集成测试
所谓系统集成也就是根据概要设计中的软件结构，把经过测试的模块，按照某种选定的集成策略，例如渐增集成策略，将系统组装起来。在组装过程中，需要对整个系统进行集成测试，以确保系统在技术上符合设计要求，在应用上满足需求规格要求。

5）系统确认验证
在完成对系统的集成之后，接着还要对系统进行确认验证。系统确认验证需要以用户为主体，以需求规格说明书中对软件的定义为依据，由此对软件的各项规格进行逐项地确认，以确保已经完成的软件系统与需求规格的一致性。为了方便用户在系统确认期间能够积极参入，也为了系统在以后的运行过程中能够被用户正确使用，这个时期往往还需要以一定的方式对用户进行必要的培训。在完成对软件的验收之后，软件系统可以交付用户使用，并需要以“项目开发总结报告”的书面形式对项目进行总结。
```

#### c.软件运行与维护期

```
软件系统的运行是一个比较长久的过程，跟软件开发机构有关的主要任务是对系统进行经常性的有效维护。软件的维护过程，也就是修正软件错误，完善软件功能，由此使软件不断进化升级的过程，以使系统更加持久地满足用户的需要。因此，对软件的维护也可以看成为对软件的再一次开发。在这个时期，对软件的维护主要涉及三个方面的任务，即改正性维护、适应性维护和完善性维护。 
```

### 2). 瀑布模型

瀑布模型诞生于20世纪70年代，是最经典的并获得最广泛应用的软件过程模型。图2-1是传统瀑布模型的图样表示。

![image-20240705130027646](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/Java/image-20240705130027646.png)                   

瀑布模型中的“瀑布”是对这个模型的形象表达，即山顶倾泻下来的水，自顶向下、逐层细化。其中，自顶向下中的顶，可以理解为软件项目初期对软件问题的模糊认识，需要经过需求分析，才能使软件问题逐步清晰，而获得对软件规格的明确定义，由此使软件项目由定义期过渡到开发期，并经过软件开发而最终得到需要实现的软件产品这个最底层结果。瀑布模型中的逐层细化，其含义则是对软件问题的不断分解而使问题不断具体化、细节化，以方便问题的解决。

#### a.瀑布模型的特点

```
1）线性化模型结构
瀑布模型所考虑的软件项目是一种稳定的线性过程。项目被划分为从上至下按顺序进行的几个阶段，阶段之间有固定的衔接次序，并且前一阶段输出的成果被作为后一阶段的输入条件。

2）各阶段具有里程碑特征
瀑布模型中的阶段只能逐级到达，不能跨越。每个阶段都有明确的任务，都需要产生出确定的成果。

3）基于文档的驱动
文档在瀑布模型中是每个阶段的成果体现，因此，文档也就成为了各个阶段的里程碑标志。由于后一阶段工作的开展是建立在前一阶段所产生的文档基础之上，因此，文档也就成为了推动下一阶段工作开展的前提动力。

4）严格的阶段评审机制
在某个阶段的工作任务已经完成，并准备进入到下一个阶段之前，需要针对这个阶段的文档进行严格的评审，直到确认以后才能启动下一阶段的工作。
```

#### b.瀑布模型的作用

```
瀑布模型是一种基于里程碑的阶段过程模型，它所提供的里程碑式的工作流程，为软件项目按规程管理提供了便利，例如，按阶段制定项目计划，分阶段进行成本核算，进行阶段性评审等；并对提高软件产品质量提供了有效保证。瀑布模型的作用还体现在文档上。每个阶段都必须完成规定的文档，并在每个阶段结束前都要对所完成的文档进行评审。这种工作方式有利于软件错误的尽早发现和尽早解决，并为软件系统今后的维护带来了很大的便利。应该说，瀑布模型作为经典的软件过程模型，为其他过程模型的推出提供了一个良好的拓展平台。
```

#### c.带有信息反馈环的瀑布模型

```
在实际的软件项目中存在着许多不稳定因素。例如，开发中的工作疏漏或通信误解；在项目实施中途，用户可能会提出一些新的要求；开发者也可能在设计中遇到某些未曾预料的实际困难，希望在需求中有所权衡等。考虑到许多实际项目中阶段之间有通信的需要，也就有了一种经过改进的，跟实际开发环境更加接近的瀑布模型，如图2-2所示。改进后的瀑布模型带有信息反馈环，能够逐级地将后续阶段的意见返回，并在问题解决之后，再逐级地将修正结果下传。

需要注意的是，为了确保文档内容的一致性，信息反馈过程中任何有关影响文档变更的行为，只能在相邻阶段之间逐级地进行。
```

#### d.瀑布模型的局限

```
瀑布模型是一种线性模型，要求项目严格按规程推进，必须等到所有开发工作全部作完以后才能获得可以交付的软件产品。应该讲，通过瀑布模型并不能对软件系统进行快速创建，对于一些急于交付的软件系统的开发，瀑布模型有操作上的不便。瀑布模型主要适合于需求明确，且无大的需求变更的软件开发，例如，编译系统、操作系统等。但是，对于那些分析初期需求模糊的项目，例如那些需要用户共同参加需求定义的项目，瀑布模型也有使用上的不便。
```

## 2.面向对象分析的三个模型

 用面向对象方法开发软件，通常需要建立3种形式的模型，它们分别是：

```
对象模型：
	描述系统数据结构
动态模型：
	描述系统控制结构
功能模型：
	描述系统功能
```

#### a.建立对象模型

```
面向对象分析首要的工作，是建立问题域的对象模型。对象模型描述了现实世界中的“类与对象”以及它们之间的关系，表示了目标系统的静态数据结构。在面向对象方法开发中，类图是构建对象模型的核心工具

复杂问题（大型系统）的对象模型可以由下面五个层次组成：
	主体层,类与对象层
	结构层,属性层,服务层

基本的工作步骤是：
	首先确定对象类和关联（因为它们影响系统整体结构和解决问题的方法），对于大型复杂问题还要进一步划分不同主题；
	然后给类和关联添加属性，目的为进一步描述它们；
	接下来利用适当的继承关系进一步合并和组织类。
而对类中操作的最后确定，则需要等建立了动态模型和功能模型之后，因为这两个子模型更准确地描述了对类中提供的服务的需求。
```

####  b.建立动态模型

动态模型描述系统的动态结果和对象之间的交互，表示瞬时的、行为化的系统的“控制”特性。在面向对象方法中，常用状态图、顺序图、协作图、活动图等构建系统的动态模型。

```
其步骤如下：
　　第一步，编写典型交互行为的脚本。虽然脚本中不可能包括每个偶然事件，但是，至少必须保证不遗漏常见的交互行为。
　　第二步，从脚本中提取出事件，确定触发每个事件的动作对象以及接受事件的目标对象。
　　第三步，排列事件发生的次序，确定每个对象可能有的状态及状态间的转换关系，并用状态图描绘它们。
　　最后，比较各个对象的状态图，检查它们之间的一致性，确保事件之间的匹配。
　　
在建立动态模型的过程中，“脚本”是指系统在某一执行期间内出现一系列事件。
```

#### c.建立功能模型

```
功能模型表达系统的详细需求，为软件的进一步分析和设计打下基础，其表明了系统中数据之间的依赖关系，以及有关的数据处理功能。在面向对象分析中，由用例图、场景描述以及功能树结构组成。其中的处理功能可以用IPO图（或表）、伪码等多种方式进一步描述。通常在建立对象模型和动态模型之后再建立功能模型。
```

## 3.面向对象分析中的三种类

```
在面向对象分析和设计中，类可以分为三种类型：

Ø 实体类（Entityclass）

Ø 边界类（boundaryclass）

Ø 控制类（controlclass）
```

### 1).实体类

```
实体类是应用领域中的核心类，一般用于保存系统中的信息以及提供针对这些信息的相关处理行为。

实体类映射需求中的每个实体，实体类保存需要存储在永久存储体中的信息，例如，在线教育平台系统可以提取出学员类和课程类，它们都属于实体类。实体类通常都是永久性的，它们所具有的属性和关系是长期需要的，有时甚至在系统的整个生存期都需要。

实体类是对用户来说最有意义的类，通常采用业务领域术语命名，一般来说是一个名词，在用例模型向领域模型的转化中，一个参与者一般对应于实体类。

通常可以从数据库表（需要持久存储）对应的名词着手来找寻实体类。通常情况下，实体类一定有属性，但不一定有操作。
```

### 2).边界类

```
边界类是系统内的对象和系统外的参与者的联系媒体，外界的消息只能通过边界类的对象实例才能发送给系统。

边界类用于封装在用例内、外流动的信息或数据流。边界类位于系统与外界的交接处，包括所有窗体、报表、打印机和扫描仪等硬件的接口，以及与其他系统的接口。要寻找和定义边界类，可以检查用例模型，每个参与者和用例交互至少要有一个边界类，边界类使参与者能与系统交互。

边界类是一种用于对系统外部环境与其内部运作之间的交互进行建模的类。常见的边界类有窗口、通信协议、打印机接口、传感器和终端等。实际上，在系统设计时，产生的报表都可以作为边界类来处理。边界类用于系统接口与系统外部进行交互，边界对象将系统与其外部环境的变更（例如，与其他系统的接口的变更、用户需求的变更等）分隔开，使这些变更不会对系统的其他部分造成影响。通常情况下，边界类可以既有属性也有方法。
```

### 3).控制类

```
控制类是从控制对象中归纳和抽象出来的，用于协调系统内边界类和实体类之间的交互。

控制类是用于控制用例工作的类，一般是由动宾结构的短语（“动词+名词”或“名词+动词”）转化来的名词，例如，用例“身份验证”可以对应于一个控制类“身份验证器”，它提供了与身份验证相关的所有操作。

控制类用于对一个或几个用例所特有的控制行为进行建模，控制对象（控制类的实例）通常控制其他对象，因此，它们的行为具有协调性。

控制类将用例的特有行为进行封装，控制对象的行为与特定用例的实现密切相关，当系统执行用例的时候，就产生了一个控制对象，控制对象经常在其对应的用例执行完毕后消亡。通常情况下，控制类没有属性，但一定有方法。
```
