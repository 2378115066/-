# 1.为什么要持久化

**redis 作为一个键值对内存数据库(NoSQL),数据都存储在内存当中，在处理客户端请求时，所有操作都在内存当中进行，**如下所示:

![image-20240526191539486](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/image-20240526191539486.png)

**这样做有什么问题**？

```
其实，只要稍微有点计算机基础知识的人都知道，存储在内存当中的数据，只要服务器关机(各种原因引起的)，内存中的数据就会消失了，不仅服务器关机会造成数据消失，Redis 服务器守护进程退出，内存中的数据也一样会消失。
```

![image-20240526191713875](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/image-20240526191713875.png)

# 2持久化的两种方式之一 RDB 持久化

**Redis 提供了 RDB 和 AOF 两种不同的数据持久化方式**

```
RDB
RDB 是一种快照存储持久化方式，具体就是将Redis某一时刻的内存数据保存到硬盘的文件当中，默认保存的文件名为 dump.rdb，而在 Redis 服务器启动时，会重新加载 dump.rdb 文件的数据到内存当中恢复数据。

开启 RDB持久化方式很简单，客户端可以通过向Redis 服务器发送 save 或 bgsave 命令让服务器生成rdb 文件，或者通过服务器配置文件指定触发 RDB 条件。1.save 命令
save 命令是一个同步操作。
```

## 1.save命令

**save命令是一个同步操作**

![image-20240526191934335](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/image-20240526191934335.png)

当客户端向服务器发送 save 命令请求进行持久化时，服务器会**阻塞** save 命令之后的其他客户端的请求，直到数据同步完成。

如果数据量太大，同步数据会执行很久，而这期间 Redis 服务器也无法接收其他请求，所以，最好**不要在生产环境**使用save 命令。

## 2.bgsave

**与save 命令不同，bgsave,命令是一个异步操作**

![image-20240526192111528](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/image-20240526192111528.png)

当客户端发服务发出bgsave命令时，Redis 服务器主进程会 forks 一个子进程来数据同步问题，在将数据保存到rdb 文件之后，子进程会退出。

所以，与save 命令相比，Redis 服务器在处理bgsave采用子线程进行IO写入，而主进程仍然可以接收其他请求，但forks 子进程是同步的，所以 forks 子进程时，一样不能接收其他请求，这意味着，如果 forks 一个子进程花费的时间太久(一般是很快的)，bgsave命令仍然有**阻塞**其他客户的请求的情况发生。

## 3.服务器配置自动解决

```
除了通过客户端发送命令外，还有一种方式，就是在 Redis 配置文件中的 save 指定到达触发RDB 持久化的条件，比如[多少秒内至少达到多少写操作]就开启RDB数据同步。

例如我们可以在配置文件 redis.conf 指定如下的选项:

#900s内至少达到一条写命令
save 900 1

# 300s 内至少达至 10 条写命令
save 300 10

# 60s 内至少达到 10000条写命令
save 60 10000

之后在启动服务器时加载配置文件，

#启动服务器加载配置文件
redis-server redis.conf
```

```
这种通过服务器配置文件触发 RDB的方式，与bgsave命令类似，达到触发条件时，会fork一个子进程进行数据同步，不过最好不要通过这方式来触发RDB持久化，因为设置触发的时间太短，则容易频繁写入rdb文件，影响服务器性能，时间设置太长则会造成数据丢失前面介绍了三种让服务器生成rdb 文件的与式，无论是由主过程生成还是子进程来生成，过程如下:
		生成临时rdb文件，并写入数据
		完成数据写入，用临时文代替代正式rdb文件
		删除原来的 rdb 文件。
```

RDB 默认生成的文件名为dump.rdb，当然，我可以通过配胃文件进行更加详细配置，比如在单机下启动多个redis 服务器进程时，可以通过端口号配置不同的rdb 名称。

```
#是否压缩rdb 文件
rdbcompression yes

#rdb 文件的名称
dbfilename redis-6379.rdb
# rdb 文件保存目录 dir ~/redis/
```

## 4.RDB优点

```
1. 与AOF方式相比，通过rdb文件恢复数据比较快。
2. rdb 文件非常紧凑，适合于数据备份。
3. 通过 RDB进行数据备，由于使用子进程生成，所以对Redis服务器性能影响较小。
```

## 5.RDB 的几个缺点

```
如果服务器宕机的话，采用RDB的方式会造成某个时段内数据的丢失，比如我们设置10分钟同步一次或5分钟达到1000次写入就同步一次,那么如果还没达到触发条件服务器就死机了，那么这个时间段的数据会丢失。
使用save 命令会造成服务器阻寒，直接数据同步完成才能接收后续请求。
使用 bgsave 命令在 forks 子进程时，如果数据量太大,forks 的过程也会发生阻塞，另外,forks 子进程会耗费内存。
```

#### 修改配置文件(dbfilename和dir)

![image-20240526192929506](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/image-20240526192929506.png)

```
保存配置文件
停止原来的 reids-server 的服务
Ps -eflgrep redis
Kil -9

重新启动redis的服务 
./redis-server ../redis.conf &

进入 redis
./redis-cli
增加几个键值对
Set name "xinjing"
Set age "30"
Set sex
Save

执行 save

查看持久化内容
cat redis-dump.rdb
```

# 3.持久化的两种方式之- AOF 持久化

Redis 默认不开启 AOF 持久化方式，我们可以在配置文件中开启并进行更加详细的配置,如下面的 redis.conf 文件:

```
#开启 aof 机制
appendonly yes

#aof 文件名
appendfilename "appendonly.aof"

#写入策略,always 表示每个写操作都保存到 aof文件中,也可以是everysec或no
appendfsync always
```

## 1.三种写入策略

在上面的配置文件中，我们可以通过 appendfsync选项指定写入策略,有三个选项

```
appendfsync always

#appendfsync everysec

#appendfsync no
```

1. always
客户端的每一个写操作都保存到aof文件当，这种策略很安全，但是每个写请注都有IO操作，所以也很慢。

1. everysec
appendfsync的默认写入策略,每秒写入一次 aof 文件,因此,最多可能会丢失 1s 的数据

1. no
Redis 服务器不负责写入 aof，而是交由操作系统来处理什么时候写入 aof 文件。更快，

但也是最不安全的选择，不推荐使用

```
#默认不重写 aof 文件
no-appendfsync-on-rewrite no

AOF 文件重写
AOF 将客户端的每一个写操作都追加到 aof 文件末尾，比如对一个key 多次执行incr命令，这时候，aof保存每一次命令到aof 文件中，aof文件会变得非常大。
iner num 1
incr num 2
incr num 3
iner num 4
incr num 5
incr num 6
...
incr num 100000
```

aof 文件太大，加载 aof 文件恢复数据时，就会非常慢，为了解决这个问题，Redis 支持aof 文件重写，通过重写 aof，可以生成一个恢复当前数据的最少命令集，比如上面的例子中那么多条命令，可以重写为:

```
set num 100000
```

aof 文件是一个二进制文件，并不是像上面的例子一样，直接保存每个命令，而使用 Redis自己的格式，上面只是方便演示。

## 2.两种重写方式

```
通过在 redis.conf 配置文件中的选项 no-appendfsync-on-rewrite 可以设置是否开启重写这种方式会在每次fsync时都重写，影响服务器性以，因此默值为no，不推荐使用。

1.
# 默认不重写 aof 文件 no-appendfsync-on-rewrite no
客户端向服务器发送 bgrewriteaof命令，也可以让服务器进行 AOF 重写。

2.
# 让服务器异步重写追加 aof文件命令
>bgrewriteaof

AOF重写方式也是异步操作，即如果要写入aof文件，则Redis 主进程会forks 一个子进程来处理
```

**如图所示**

![image-20240526194333178](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/image-20240526194333178.png)

### 重写 aof 文件的好处

压缩 aof 文件，减少磁盘占用量。

将 aof的命令压缩为最小命令集，加快了数据恢复的速度。

#保存目录 dir ~/redis

## 3.AOF 的优点

```
AOF只是追加日志文件，因此对服务器性能影响较小，速度比 RDB 要快，消耗的内存较少。
```

## 4.AOF 的缺点

```
AOF方式生成的日志文件太大，即使通过AFO 重写，文件体积仍然很大。
恢复数据的速度比 RDB 慢。
```

## 5.设置adf模式，修改配置文件

#### 1.打开aof持久化

```bash
appendonly yes
```

#### 2.always每次写都写入到aof日志文件中

```
appendfsync always
```

3.关闭redis服务，再重启服务

```bash
kill -9
./redis-server ../redis.conf &         #重新加载修改的配置文件

set key value ...   				#设置键值对
shutdown         					#关闭服务器
./redis-server ../redis.conf &		 #重启redis服务
key *    						    #查看aof装载情况
```

# 6.选择RDB还是AOF？

```
通过上面的介绍，我们了解了RDB与AOF各自的优点与缺点，到底要如何选择呢?
通过下面的表示，我们可以从几个方面对比一下RDB与 AOF,在应用时，要根本自己的实际需求，选择 RDB或者AOF，其实，如果想要数据足够安全，可以两种方式都开启，但两种持久化方式同时进行 I0操作,会严重影响服务器性能,因此有时候不得不做出选择。
```

![image-20240526195323176](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/image-20240526195323176.png)

当RDB与AOF两种方式都开启时，Redis 会优先使用 AOF 日志来恢复数据工，因为 AOF 保存的文件比 RDB 文件更完整。

如果只是单纯把 Redis作为缓存服务器，那么可以完全不用考虑持久化，但是，在如今的大多数服务器架构中，Redis 不单单只是扮演一个缓存服务器的角色，还可以作为数据库，保存我们的业务数据，此时，我们则需要好好了解有关 Redis 持久化策略的区别与选择。