## 一.远程连接

```bash
#远程登录linux系统
ssh  root@192.168.202.136

#断开连接
exit
 
#重启系统
reboot 或者 shutdown -r now

#关机指令
shutdown #默认30秒之后才会关机

#立即关机
shutdown  -h  now

#十分钟之后关机
shutdown  -h  10
```

## 二.文件和目录操作

### 1.操作

\以树状的显示指定目录下的目录和文件的名称 

```bash
tree 
例子1： 
tree /usr/local
```

**新建文件**

```bash
touch
例子1： touch 1.txt  #创建单个文件
例子2： touch test{1..10}.txt #批量创建文件touch test{a..f}.txt
例子3： touch /root/4.txt  #在指定的/root目录下，创建文件4.txt
 # 如果touch的文件名称重复了，不会覆盖原文件
```

**查看文件类型**

```bash
file
例子1：
file 123.zip
```

**查看目录下的文件**

```bash
ls全称list
ls：显示当前目录下的内容
例子1：ls  test09.txt   
例子2：ls  *.txt        
例子3：ls  -1         
例子4：ls  -a  al         
例子5：ls -a -1         
#查看test09.txt是否存在，有会显示文件名称，没有会报错
#查看以txt结尾的所有文件，类似于windows下的*.后缀名搜索
#以一行一个文件的方式显示，注意这是-1，是数字1，不是l昂
#查看所有文件，包括隐藏文件，touch .文件名，.开头的就是隐藏文件
#查看所有文件，以一行一个来显示
例子6：ls -l   #类似于windows的详细列表，这个-l不是数字1
```

**移动、也可以进行重命名**

```bash
mv全称move
例子1：mv 222.txt 123.txt    
例子2：mv 123.txt /opt       
#将222.txt文件重命名为123.txt
#将当前目录下的123.txt移动到/opt目录下
```

**复制**

```bash
cp全称copy，复制有个特点，就是如果复制到的文件夹中有同名的文件，会帮我们改名字并加上副本两个字，linux不会帮我们改名字，我们需要自己指定名字，后缀名尽量不要改。

例子1：cp test01.txt /opt/   #将当前目录下的test01.txt复制到/opt目录下
例子2：cp -a dev04 /opt/     #将目录dev04复制到/opt下，注意，要在dev04的上一级目录来复制
						   它，在它内部是不能复制这个文件夹的
```

**删除**

```bash
#删除，注意Linux和windows不同，没有回收站，删了就是删了
例子1:  rm /opt/123.txt  #将/opt目录下的123.txt文件删除，需要回复y确认删除

例子2： rm -f /opt/test01.txt #将/opt目录下的test01.txt文件删除，不需要回复，强制删除，很多指令都有自己的参数，而且有好多，-f就是强制的意思。

例子3： rm 文件1 文件2 文件3 #删除多个文件
#删除一个目录，linux的参数大部分没有先后顺序
#直接删除文件夹，比如 rm dev，这是不行的，会报错，需要带上r参数

[root@localhost ~]# rm -f -r dev02 
[root@localhost ~]# rm -r -f dev03
[root@localhost ~]# rm -fr dev  # rm的两个参数可以合并到一起
[root@localhost ~]# rm -rf dev01
```

**创建文件夹**

```bash
mkdir 全称make directory 
例子1：mkdir dev

#创建一个dev目录
例子2：mkdir dev{01..10} 

#批量创建多个目录
例子3：mkdir -p 1/2/3/4/5/6  #一次性创建多级子目录
重命名：mv jaden wulaoban # 将jaden目录改名为wulaoban
```

**切换目录**

```bash
cd  #全称change directory
例子1：
cd  local    #切换到local目录中
cd  /usr/local  #切换到目录/usr/local
cd  ..       #切换到上一级目录
cd ../..  # 进入上一级的上一级目录 ，还可以继续../
cd / # 直接切换到根目录
```

**打印当前工作目录**

```bash
pwd
```

**历史指令查询**

```bash
history
```

**目录分隔符**

```bash
目录分隔符：
windows：C:\Users\ls198\Desktop  # 微软故意用\，其他的unix分支系统都是/来分割
linux：/root/jaden/xx
 
linux只有一个盘符，不像windows，可以设置c盘、d盘...
/是根目录
/root 根目录下面的root目录
/root/jaden
/root/jaden/xx
```

**vi**

```bash
#修改文件内容，先体验一下，后面再专门讲vi的功能
#vi编辑器，和windows的记事本工具类似
例子1： vi  test03.txt   
#编辑文件test03.txt
#vi编辑保存文件，需要三种模式切换


常规模式：默认是常规模式，在常规模式中可以使用各种快捷键，帮我们快速编辑文件，比如dd，就是删除当前一行数据

编辑模式：切换英文输入法，然后按ioa三个键中的任意一个键都可以进入编辑模式，这样才能向文件中写内容，写完内容之后，先回到常规模式，在编辑模式中按esc回到常规模式

命令模式：在常规模式时按:(英文的冒号)进入命令模式，命令模式按esc回到常规模式，命令模式下输入q然后回车表示退出文件，wq保存并退出，q!表示强制退出不保存
```

**以查看文件内容**

```bash
#从上往下顺序查看文本内容
cat
例子1：cat  test03.txt  #查看test03.txt的全部内容

#从下往上倒着查看文本内容
tac
例子1：tac  test03.txt  #倒着查看test03.txt的全部内容
```

**查看文件头几行**

```bash
head
例子1： head  test03.txt       #查看文件的前十行，默认
例子2： head  -n 5 test03.txt  #查看文件的前5行
例子3： head  -5  test03.txt   #查看文件的前5行
```

**查看文件倒数几行**

```bash
tail
例子1： tail  test03.txt       #查看文件的倒数十行，默认
例子2： tail  -n 5 test03.txt  #查看文件的倒数5行
例子3： tail  -5  test03.txt   #查看文件的倒数5行
```

### 2.管道

**管道符号：|，可以将前面指令的执行结果，作为后面指令的操作内容。**

```bash
[root@localhost ~]# ip addr
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group 
default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: ens33: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP 
group default qlen 1000
    link/ether 00:0c:29:83:e4:d9 brd ff:ff:ff:ff:ff:ff
    inet 10.0.0.128/24 brd 10.0.0.255 scope global noprefixroute dynamic ens33
       valid_lft 1253sec preferred_lft 1253sec
    inet6 fe80::ffe1:31ed:56dc:d9aa/64 scope link noprefixroute 
       valid_lft forever preferred_lft forever

[root@localhost ~]# ip addr|tail -4
    inet 10.0.0.128/24 brd 10.0.0.255 scope global noprefixroute dynamic ens33
       valid_lft 1224sec preferred_lft 1224sec
    inet6 fe80::ffe1:31ed:56dc:d9aa/64 scope link noprefixroute 
       valid_lft forever preferred_lft forever

[root@localhost ~]# ip addr|tail -4|head -1
    inet 10.0.0.128/24 brd 10.0.0.255 scope global noprefixroute dynamic ens33
 
 [root@localhost ~]# ip addr|tail -4|head -1|cut -c 10-19  
 #cut -c 10-19表示从第10个字符显示到第19个字符，这个指令可以忽略，大致了解一下即可，因为字符长度不固定，切的时候有可能切不准确
 
10.0.0.128


 grep精准匹配-w
```

### 3、文件内容过滤

**统计**

```bash
wc  #全称Word Count，计数
wc -l按行统计，不会单独使用，需要接在管道后面
例子1：
[root@localhost ~]# cat jaden.txt |wc -l
 18  # 共18行

[root@localhost ~]# cat -n jaden.txt # 显示内容的同时，显示行号
	1  sdsdsdsdsdsdsd是的是的
	2  
	3  sdsd
 	4  65656
 	5  sdsd
 	6  sdsd
 	7  sdsd
 	8  33333
 	9  565656565
    10  33333
	11  565656565
	12  33333
 	13  565656565
 	14  33333
	15  565656565
 	16  
	17  
    18  sdssds  ;;;;
    
 wc -c jaden.txt # 统计文件中有多少个字节
# 统计指令执行结果有多少行
例子：ip addr|wc -l

 # 统计bin目录下有多少个命令文件
例子：ls /bin|wc -l
```

**生成数字序列**

```bash
seq # 全称：sequence，序列的意思

例子1：产生一个5到12的序列
[root@localhost ~]# seq 5 12
 5
 6
 7
 8
 9
 10
 11
 12
 
例子2：产生一个5到12等宽的序列
[root@localhost ~]# seq -w 5 110
 05
 06
 07
 08
 09
 10
 11
 12
```

**按列过滤**

```bash
awk #awk其名称得自于它的创始人 Alfred Aho 、Peter Weinberger 和 Brian Kernighan 姓氏的首个字母。

例子1： 取列,$1代表第一列，$2代表第二列，$NF代表最后一列，列是由空格分开的
[root@localhost ~]# cat jaden.txt 
row 1, cell 1   row 1, cell 2
row 2, cell 1   row 2, cell 2
[root@localhost ~]# awk '{print $1}' jaden.txt  # 注意，必须是单引号
row
row
[root@localhost ~]# awk '{print $2}' jaden.txt 
1,
2,

例子2：以逗号,做分隔符
[root@localhost ~]# cat jaden.txt 
row 1, cell 1   row 1, cell 2
row 2, cell 1   row 2, cell 2
[root@localhost ~]# awk -F ','   '{print $1}' jaden.txt 
row 1
row 2
[root@localhost ~]# awk -F ','   '{print $NF}' jaden.txt 
cell 2
cell 2
```

**排序**

```bash
#排序 
sort # 默认排序，先数字后字母
# sort -n # 先字母(先小写字母后大写字母)后数字的排序方式，sort -n -r 反向排序
例子1：
[root@localhost ~]# cat test02.txt
3
 2
 6
 4
 8
 7
 5
 3
 2
 1
 2
 3
 4
 5
 6
 9
 1
 5
 7
 [root@localhost ~]# cat test02.txt|sort -n
 1
 1
 2
 2
 2
 3
 3
 3
 4
 4
 5
 5
 5
 6
 6
 7
 7
 8
 9
```

**统计去重**

```bash
uniq  
#全称：unique，唯一、去重的意思，但是它是将连续的去重，不会间隔去重，所以最好先排序再去重
例子1：
[root@localhost ~]# cat test02.txt|sort -n
 1
 1
 2
 2
 2
 3
 3
 3
 4
 4
 5
 5
 5
 6
 6
 7
 7
 8
 9
 
[root@localhost ~]# cat test02.txt|sort -n|uniq 
[root@localhost ~]# cat test02.txt|sort -n|uniq -c  # -c显示重复次数
2 1
 3 2
 3 3
 2 4
 3 5
 2 6
 2 7
 1 8
 1 9
```



## 三.目录结构

### 1.目录结构介绍

```bash
路径分隔符：
linux系统都是斜杠：也叫做正斜杠，/，linux下，每个目录后面其实默认都有个/，切换目录: cd 
jaden或者cs jaden/ 是一样的
	windows系统是反斜杠：\
     G:\jadenwangan\
     /etc/abr
```

![image-20240525130913104](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E5%AD%A6%E6%A0%A1/Hadoop/image-20240525130913104.png)

各个内置目录说明，目前先简单记忆一下即可，后面学习中都会详细说到，linux系统一切皆文件

```
 /bin    
#存放二进制的可执行文件，也就是命令，其实每个命令基本都是一个可执行代码文件，特别重要，不能删除! # window的命令文件都是exe结尾的，linux的命令文件是没有后缀名的，如果删除了某个命令文件，那么这个命令就不能用了 
 
/boot    
#开机启动需要的文件， 特别重要，不要动里面的文件。 

/dev
#dev全称：Devices，硬件设备控制文件，特别重要，千万不要动! 

/etc
#存放系统的各种配置文件，相当于windows的注册表，也就是超大的配置文件，特别重要，不 能删除! # 比如改密码什么的，其实都是修改的etc下面的某个配置文件(shadow文件)中的配置，还有安装的各 种软件配置文件，一般也是放到这个目录，也可以放到其他目录，但是一般都是放到这里。

/home    
#所有普通用户的家目录就在这个home目录下，每个用户目录中都有自己的桌面等目录， windows都是放到了Users目录下 


/root    #root用户的专属家目录，特别重要，不能删除! 

/lib     
#library 32位库，一般是so结尾的库文件，特别重要，不能删除!
#so结尾的库文件，类似于windows下的系统的dll动态链接库文件。千万不要尝试删除，试试就逝世。如果有快照的话你可以试试。 

/lib64   
#library 64位库，一般是so结尾的库文件，特别重要，不能删除! 

/media
#多媒体文件目录(音乐、视频、文档等)，是一个不重要的目录，只是linux的作者希望用户能 够按照对应目录来存放内容，这个目录普通用户是没有权限删除的，root用户可以删除它 

/mnt     
#全称：mount，挂载的意思，一般是用来挂载光盘，U盘，也就是插入U盘、关盘等，打开之后 一般都是在这个mnt目录下，这个目录也是可以删除的 

/opt    
#部分软件安装存储目录，安装的某些软件的时候，如果默认安装，那么它可能会将自己的程序安 装到这个目录下，如果你不用这个目录，那么也是可以删除的目录 

/proc    
#全称：process，是进程的意思，每个进程编号一个目录。通过ps -ef指令可以查看到进程编号， 特别重要，不能删除!  

/sbin    
#全称：super bin，是超级用户才能使用的命令 ，特别重要，不能删除!  shutdown   reboot 
# 比如普通用户是没有关机(shutdown)、重启(reboot)等危害比较大的指令，这些命令文件在sbin 目录中 

/srv    
#之前用来存放软件源代码文件的，这个目录也没啥用。源代码-->编译-->打包-->软件包，软件包在windows下叫做可执行文件，linux下叫做命令文件。其实叫啥都行，明白它是啥即可。 

/sys        
#全称：system，是系统功能目录，特别重要，不能删除! 

/tmp
#全称：temporary，临时的意思，用来存放临时文件的目录，这里面的文件如果长时间没用的话，会被系统自动清除。 
# windows下也有很多这样的临时目录，多数都是隐藏目录，比如C:\Users\用户名\AppData\Local\Temp,好多清理系统垃圾的软件，其实都是删除了一些临时文件。 

/run    
#运行，程序运行的时候产生的文件，多数也是临时文件，但是这里的文件不会被系统自动清除。 

/usr    
#用户级的目录，usr全称是UNIX software resource，主要存放的是一些软件程序以及这些 程序所需要使用的库，当然也会保存一些程序需要的资源文件，特别重要，不能删除!usr目录下面的文件夹种类和/根目录下很像，比如都有bin目录，linux作者这样的设计是想告诉用户，系统的命令文件放到根目录 的bin下，用户自己安装的某些软件的命令文件，放到/usr/bin下面。 


/var    
#全称是variable，用来存放一些经常变动的文件，比如日志文件、网页文件、缓存等，特别重 要，不能删除! 
# 这个目录下我们安全人员一般只关注log日志目录。比如用户登录系统、什么时候登录的、登陆了几次 等等，都会在log目录下产生日志记录，这个我们后期会做演示.   
```

### 3、相对路径和绝对路径  

```bash
相对路径：从当前所在目录开始数的不完整的路径 
绝对路径：从根开始的数的完整路径 这是两种路径形式，主要是为了方便用户操作的，到底哪个更方便，这个视实际情况而定。 


示例：
创建目录： 
	相对路径： 
		mkdir jaden mkdir ../jaden 
	绝对路径：
		mkdir /jaden 

找寻目录： 
	cd /usr/share/i18n/locales/ 
	当前位置：/usr/share/i18n/locales/ 
	目标位置：/etc/ 
	绝对路径： 
		cd /etc/ 
	相对路径： 
		cd ../../../../etc/ 
	这么看就绝对路径方便一些。 
	
	
但是如果下面的情况： 
	当前位置：/usr/share/i18n/locales/ 
	目标位置：/usr/share/i18n/ 
	绝对路径： 
		cd /usr/share/i18n/ 
	相对路径： 
		cd .. 或者如下情况 
	当前位置：/usr/share/i18n/ 
	目标位置：/usr/share/i18n/locales/ 
	绝对路径： 
		cd /usr/share/i18n/locales/ 
	相对路径： 
		cd locales 

这么看就是相对路径方便一些。 也就是说，如果目标在上一级或者下一级，离着比较近，相对路径操作就方便，如果目标目录没有和当前 目录在一个路径分支上，离着比较远，那么用绝对路径方便一些。
```

## 四.用户和用户组管理

```
windows专业版，管理-->用户和用户组，来进行用户和用户组管理。
用户和用户组的关系，说到关系就三种情况：一对一、一对多、多对多。
用户和用户组属于多对多的关系。
```

#### 1、用户管理

**创建用户**

```bash
useradd 
#创建一个用户
例子1：useradd  test1
```

**设置密码**

```bash
passwd
例子1：passwd  test1
#用root用户给普通用户修改密码
[root@localhost ~]# passwd test1
更改用户 test1 的密码 。
新的 密码：123456
无效的密码： 密码是一个回文
重新输入新的 密码：123456
 passwd：所有的身份验证令牌已经成功更新。

#普通用户自己修改密码
[test1@localhost ~]$ passwd  # 给当前登录用户修改密码，root用户修改密码不需要输入旧密码，
普通用户需要输入旧密码
更改用户 test1 的密码 。
为 test1 更改 STRESS 密码。
（当前）UNIX 密码：
新的 密码：
无效的密码： 密码少于 8 个字符
新的 密码：
无效的密码： 密码少于 8 个字符
新的 密码：
无效的密码： 密码未通过字典检查 - 过于简单化/系统化
passwd: 已经超出服务重试的最多次数
# 一般linux的密码是有复杂度要求的，比如下面这种密码就可以通过：大小写组合、数字、特殊字符组合起来超过8位。
jaden666@qq.COM
jaden666@WSX

例子3：
#免交互修改密码，这样不需要输入两次密码确认。echo是打印的意思，有结果输出给passwd命令来修改
test1用户的密码
echo 123456|passwd --stdin test1
# 这种一般同时改多个Linux服务器系统的密码时比较方便。
```

**检查用户是否存在**

```bash
#检查用户是否存在
id
例子1: 
#用户存在，系统的返回结果
[root@localhost ~]# id test1
uid=1000(test1) gid=1000(test1) 组=1000(test1)

#用户不存在，系统的返回结果
[root@localhost ~]# id test2
id: test2: no such user
```

**删除用户**

```bash
userdel
例子1：
#被删除的用户还在登录状态，是不能删除的
[root@localhost ~]# userdel test1
userdel: user test1 is currently used by process 2356
#被删除的用户，退出登录之后，可以正常删除
[root@localhost ~]# userdel test1

linux删除用户之后，/home/目录下对应的用户文件夹还在，如果还想加回来这个用户，那么会提示家目录存在，不会从样板目录(skel)中复制任何文件了，通过ls -a /etc/skel，可以看到skel目录下的内容了。
还提示邮箱文件已经存在，ls /var/spool/mail下面
windows删除用户之后，c:\Users目录下的用户文件夹也还在
注意：删除之后的用户，再次创建出来，密码是需要重新设置的

[root@localhost ~]# userdel -r test1  # 删除用户，并删除用户相关目录
```

**修改用户信息，修改属性**

```bash
usermod # modify 它有很多选项(参数)，-L是锁定用户，通过命令 -h(或者--help，一个-后面一般跟一个字母即可，两个-后面一般跟完整单词)，可以查看命令的各种选项的意思，比如usermod -h

#锁定用户(和windows的禁用用户一个意思)
例子1：
[root@localhost ~]# usermod -L test1  #被锁定的用户，下次就登录不上系统了。
[root@localhost ~]# usermod -U test1  #解锁用户
[root@localhost ~]# lchage -l test1 # 查看用户详细信息
帐号被锁。
至少: 0
至多: 99999
警告: 7
不活跃：    从不
最后一次改变： 2021年07月20日
密码过期：   从不
密码不活跃：  从不
帐号过期：   从不

#禁止用户登录(这个后面再说)
 [root@localhost ~]# usermod -s /sbin/nologin test2
 [root@localhost ~]# grep -w 'test2' /etc/passwd
 test2:x:1001:1001::/home/test2:/sbin/nologin
```

**查看用户详细信息**

```bash
lchage
例子1：
[root@localhost ~]# lchage -l test1
帐号没被锁。
至少: 0
至多: 99999
警告: 7
不活跃：    从不
最后一次改变： 2021年07月20日
密码过期：   从不
密码不活跃：  从不
帐号过期：   从不
```

所有的用户信息存储在/etc/passwd文件中，每创建一个用户该文件就会多一行记录

```bash
root:x:0:0:root:/root:/bin/bash
# 下面的用户都是系统自带用户，不用管它
bin:x:1:1:bin:/bin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin
adm:x:3:4:adm:/var/adm:/sbin/nologin
lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin
sync:x:5:0:sync:/sbin:/bin/sync
shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown
halt:x:7:0:halt:/sbin:/sbin/halt
mail:x:8:12:mail:/var/spool/mail:/sbin/nologin
 
operator:x:11:0:operator:/root:/sbin/nologin
games:x:12:100:games:/usr/games:/sbin/nologin
ftp:x:14:50:FTP User:/var/ftp:/sbin/nologin
nobody:x:99:99:Nobody:/:/sbin/nologin
systemd-network:x:192:192:systemd Network Management:/:/sbin/nologin
dbus:x:81:81:System message bus:/:/sbin/nologin
polkitd:x:999:998:User for polkitd:/:/sbin/nologin
tss:x:59:59:Account used by the trousers package to sandbox the tcsd 
daemon:/dev/null:/sbin/nologin
abrt:x:173:173::/etc/abrt:/sbin/nologin
sshd:x:74:74:Privilege-separated SSH:/var/empty/sshd:/sbin/nologin
postfix:x:89:89::/var/spool/postfix:/sbin/nologin
chrony:x:998:996::/var/lib/chrony:/sbin/nologin
# 下面这个是我们自己创建的用户
test1:x:1000:1000::/home/test1:/bin/bash
```

**文件解释**

```bash
#passwd文件解释
root:x:0:0:root:/root:/bin/bash
test1:x:1000:1000::/home/test1:/bin/bash
test2:x:1001:1001::/home/test2:/sbin/nologin
test3:x:1002:1000::/home/test3:/sbin/nologin
haha:x:1004:1004:putong user:/home/haha:/bin/bash
第一列：用户名
第二列：x
第三列：uid  # root用户的uid是0，我们自己创建的用户uid是1000及之后的数值。
第四列：gid
第五列：注释，一般为空
第六列：家目录的位置
第七列：使用shell的名称，默认使用/bin/bash
```

所有的用户密码信息存储/etc/shadow，设置了密码的长度比较长。密码是两层加密的，基本无法破 解。但是如果黑客权限比较高，它可以用知道密码的shadow文件来替换这个文件，或者修改这个文件 下某个用户的密码，只有root用户才有权力修改这个文件。

```bash
[root@localhost ~]# cat /etc/shadow
root:$6$QM3AHtFflOvGbCnt$2wTYZrnO8c66vycaxprE79G.I7hiy8EqXntG86FXxqlSawjtKoTjAnAa9xFA3ad1QpFskJRPt0QeDPBnZZAdx0::0:99999:7:::
bin:*:18353:0:99999:7:::
daemon:*:18353:0:99999:7:::
adm:*:18353:0:99999:7:::
lp:*:18353:0:99999:7:::
sync:*:18353:0:99999:7:::
shutdown:*:18353:0:99999:7:::
halt:*:18353:0:99999:7:::
mail:*:18353:0:99999:7:::
operator:*:18353:0:99999:7:::
games:*:18353:0:99999:7:::
ftp:*:18353:0:99999:7:::
nobody:*:18353:0:99999:7:::
systemd-network:!!:18827::::::
dbus:!!:18827::::::
polkitd:!!:18827::::::
tss:!!:18827::::::
abrt:!!:18827::::::
sshd:!!:18827::::::
postfix:!!:18827::::::
chrony:!!:18827::::::
test1:$6$7PLnhlcr$4SCHINbWrameVSn6rxYgDOeUBwvYOHVbEOIudtNxWXIl5ULSt1Om8FvK6R3s9fI0qNef1vq8NhVMNJwudmfkM1:18828:0:99999:7:::
```

**登录主机的两种方式**

```bash
本地登录：直接在主机上输入用户名和密码登录
远程登录：ssh远程登录
```

- windows默认只能同时一个用户登录，登录另外一个用户，前一个用户就会自动下线。 linux支持多个用户在多个地方同时登录一个系统，每个用户都有一个终端来控制操作系统。终端的意思 就是连接窗口。

 **查看当前登录了几个用户，或者打开了几个终端**

 w 结果：下面表示2个终端登录了 12:15:42 up 21 min,  2 users,  load average: 0.00, 0.01, 0.03 USER   TTY    FROM       LOGIN@  IDLE  JCPU  PCPU WHAT root   tty1            root   pts/0   12:15   192.168.61.1    11:55   # tty1表示本地登录的、pts/0表示远程登录的 2、用户组管理  命令28： 6.00s  0.00s  0.00s -bash 6.00s  0.02s  0.01s w

### 2.用户组管理

**新建组和查看组**

```bash
新建组和查看组:
     groupadd 组名
例子：
	[root@localhost tmp]# groupadd test
 	[root@localhost tmp]# cat /etc/group  # 查看有哪些组
```

**指定组来创建用户，如果没有指定组，那么创建用户的时候，linux会自动创建一个与用户名同名的组。**

```bash
例子： 组的英文是group
[root@localhost tmp]# useradd  -g test1  test3  #-g 是指定主组
[root@localhost tmp]# id test3
uid=1002(test3) gid=1000(test1) 组=1000(test1)
gid表示用户的属组的主组
组=表示用户的属组，用户可以属于多个组，一个主组，多个其他组
```

**删除组**

```bash
groupdel 组名
例子：
[root@localhost tmp]# groupdel test #如果组内有用户，会报错，需要先删除主组属于这个组的所有用户(userdel -r 用户名)，或者将用户移到其他的组之后在删除组。

# 修改组名
groupmod -n jaden wulaoban # 将wulaoban组名改为jaden
```

**修改用户所属的主组**

```bash
usermod -g 组名
例子：
[root@localhost tmp]# usermod -g test jaden #将jaden用户的主组改为test
[root@localhost tmp]# groupdel jaden # 就可以将jaden组删除了。

# 将用户添加到多个其他组中
usermod -G
[root@localhost tmp]# usermod -G test wulaoban # 将wulaoban用户也添加到test组
```

## 五.权限管理

### 1、权限介绍和示例

```bash
#文件属性
[root@localhost ~]# ls -l /tmp/123.txt
-rw-r--r--. 1 root root 0 7月  20 23:17 /tmp/123.txt
#第一段的第一个字符，表示文件类型 -文件、d目录、l软链接(对应着windows快捷方式)、b块设备(ls /dev，可以看到硬盘sda等)
 #第一段第2-4字符，表示该文件所属用户的权限
#第一段第5-7字符，表示该文件所属用户组的权限
#第一段第8-10字符，表示其他用户对该文件的权限

r 4 代表读权限 read
w 2 代表写权限 write
x 1 代表可执行权限 executable  
- 0 空权限位，表示没有这个权限，9位权限不能少，没有的权限就用-代替。

权限值表
0 --
1 --x
2 -w
3 -wx
4 r-
5 r-x
6 rw
7 rwx

 ugo权限体系:
    rw-   r--    r-- 
    user  group  other
```

```bash
创建三个用户并设置密码：lisi、wangwu、zhaoliu
[root@localhost ~]# useradd lisi
[root@localhost ~]# passwd lisi
更改用户 lisi 的密码 。
新的 密码：
无效的密码： 密码少于 8 个字符
重新输入新的 密码：
passwd：所有的身份验证令牌已经成功更新。
[root@localhost ~]# useradd wangwu
[root@localhost ~]# passwd wangwu
更改用户 wangwu 的密码 。
新的 密码：
无效的密码： 密码少于 8 个字符
重新输入新的 密码：
passwd：所有的身份验证令牌已经成功更新。
[root@localhost ~]# 
[root@localhost ~]# useradd zhaoliu
[root@localhost ~]# passwd zhaoliu
更改用户 zhaoliu 的密码 。
新的 密码：
无效的密码： 密码少于 8 个字符
重新输入新的 密码：
passwd：所有的身份验证令牌已经成功更新。
```

使用lisi来登录，并创建个文件，将文件权限全部去掉，修改权限用chmod指令，全称change mode：

```bash
# 例如：chomd -r,就是去掉r权限，chomd +r就是加上读权限，chmod +wr就是加读写权限，chmod 
u+r，就是给文件属主用户添加读权限等
[lisi@localhost ~]$ touch 1.txt
[lisi@localhost ~]$ vi 1.txt
[lisi@localhost ~]$ ls -l
总用量 4
-rw-rw-r--. 1 lisi lisi 12 3月  20 09:07 1.txt
[lisi@localhost ~]$ chmod -rw 1.txt 
[lisi@localhost ~]$ ls -l
总用量 4
----------. 1 lisi lisi 12 3月  20 09:07 1.txt
```

现在这个文件是没有任何权限的，但是文件是lisi创建的，文件属主还是lisi，虽然显示lisi也没有权限， 但是实际上lisi是可以修改文件权限的，其他用户(除了root)是没有权力修改这个文件权限的。

**读权限的作用：**

```bash
lisi用户： 
[lisi@localhost ~]$ chmod -rw 1.txt 
[lisi@localhost ~]$ ls -l
	总用量 4
	----------. 1 lisi lisi 12 3月  20 09:07 1.txt
[lisi@localhost ~]$ cat 1.txt
cat: 1.txt: 权限不够
[lisi@localhost ~]$ chmod u+r 1.txt
[lisi@localhost ~]$ ls -l
	总用量 4
	-r--------. 1 lisi lisi 12 3月  20 09:07 1.txt
[lisi@localhost ~]$ cat 1.txt
hello jaden1
为了方便其他用户查看，我们先将1.txt放到/tmp目录下。
[lisi@localhost ~]$ mv 1.txt /tmp/
[lisi@localhost ~]$ ls /tmp/1.txt          

wangwu用户：
[wangwu@localhost ~]$ cd /tmp/
[wangwu@localhost tmp]$ cat 1.txt
cat: 1.txt: 权限不够
[wangwu@localhost tmp]$ chmod o+r 1.txt
chmod: 更改"1.txt" 的权限: 不允许的操作
切换到lisi：给o加上r权限，再看效果
[lisi@localhost ~]$ chmod o+r /tmp/1.txt
[lisi@localhost ~]$ ls -l /tmp/
总用量 8-r-----r--. 1 lisi lisi  12 3月  20 09:07 1.txt
再切换到wangwu来查看文件内容：
[wangwu@localhost tmp]$ cat 1.txt
hello jaden
```

**写权限的作用：**

```bash
但是wangwu想编辑文件，也是没有权限的。可以vi打开，但是编辑之后不能保存。
再切换到lisi，给o一个w权限，wangwu就可以编辑保存了。    
	[lisi@localhost ~]$ chmod o+w /tmp/1.txt
    [lisi@localhost ~]$ ls -l /tmp/
总用量 8-r-----rw-. 1 lisi lisi  12 3月  20 09:07 1.txt
wangwu编辑保存一下，查看内容：
	[wangwu@localhost tmp]$ vi 1.txt
    [wangwu@localhost tmp]$ cat 1.txt
    hello jaden
    hello wangwu
```

可执行权限的作用：这个需要我们创建一个命令文件才能看效果，我复制某个命令文件过来，谁复制过 来的，这个文件的属主就是谁，如下

```bash
. 代表当前目录
.. 代表上一级目录
切换到lisi用户来复制ls文件到/tmp目录下，并将执行权限去掉，去掉执行权限的文件显示位白色，有执行权限的显示为绿色。
    [lisi@localhost ~]$ cd /tmp/
    [lisi@localhost tmp]$ cp /bin/ls .
    [lisi@localhost tmp]$ ls -l
	总用量 124
	-r-----rw-. 1 lisi lisi 25 3月  20 09:24 1.txt
	-rwx------. 1 root root 836 3月  15 20:14 ks-script-ed2ODG
	-rwxr-xr-x. 1 lisi lisi 117608 3月  20 09:29 ls
    [lisi@localhost tmp]$ chmod -x ls
    [lisi@localhost tmp]$ ls -l
	总用量 124
	-r-----rw-. 1 lisi lisi 25 3月  20 09:24 1.txt    
	-rwx------. 1 root root  836 3月  15 20:14 ks-script-ed2ODG
	-rw-r--r--. 1 lisi lisi 117608 3月  20 09:29 ls

切换到wangwu来执行一下ls这个文件：  注意，不能直接ls，直接ls还是调用系统/bin/ls文件，需要写./ls才是使用当前目录下的ls文件，或者写这个文件的绝对路径/tmp/ls，或者将它放到某个特定目录下，就可以直接使用对应指令而不用管路径了，这个我在下面有补充说明。
[wangwu@localhost tmp]$ ./ls-bash: ./ls: 权限不够
[wangwu@localhost tmp]$ /tmp/ls-bash: /tmp/ls: 权限不够
```

### 2.可执行程序特殊目录说明

通过echo $PATH可以看到，类似于windows的环境变量中的PATH。反式放到这个目录中的命令程序， 我们可以在任意目录下通过这个命令程序名称来直接调用命令来执行： 例如：

```bash
[lisi@localhost tmp]$ echo $PATH  # 下面这几个就是环境变量路径存放位置
/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/lisi/.local/bin:/home/lisi/bin

[lisi@localhost tmp]$ cp ./ls /home/lisi/bin/
[lisi@localhost tmp]$ ls /home/lisi/bin/
ls

[lisi@localhost tmp]$ mv /home/lisi/bin/ls /home/lisi/bin/xxx  # 为了不和系统默认的ls冲突，我们改名为xxx
[lisi@localhost tmp]$ ls /home/lisi/bin/
xxx
[lisi@localhost tmp]$ xxx
[lisi@localhost tmp]$ xxx  # 命令可以在任意目录下直接执行
1.txt   vmware-root_552-2957583561                                 
ls  

```

### 3.权限值

```bash
权限值：
r 4 
w 2 
x 1 
- 0 

权限值表
0 --
1 --x
2 -w
3 -wx
4 r-
5 r-x
6 rw
7 rwx
```

修改权限举例

```bash
如果我们想将某个文件的：rwxr-xr-x权限改为--x-w-r--，如果按照前面我们chmod指定字母的形式来修改，就比较麻烦，直接使用权限对应的数字改就很方便：

rwxr-xr-x  对应的值为：755
--x-w-r--  对应的值为：124

[lisi@localhost tmp]$ chmod 124 1.txt
[lisi@localhost tmp]$ ls -l
总用量 144---x-w-r--. 1 lisi   lisi  25 3月  20 09:24 1.txt
别人再问你，某个文件的权限是多少的时候，我们一般都是直接报数字值，比如它的权限是755
```

**改变文件的权限**

```bash
例如：chomd -r,就是去掉r权限，chomd +r就是加上读权限
chmod
例子1：
#修改权限之前
[test1@localhost tmp]$ ls -l
总用量 4
-rw-rw----. 1 test1 test1 8 7月  20 17:20 test1.txt

#修改权限
[test1@localhost tmp]$ chmod u+x test1.txt 

#修改权限之后
[test1@localhost tmp]$ ls -l
总用量 4
-rwxrw----. 1 test1 test1 8 7月  20 17:20 test1.txt

例子2：
同时修改多个权限
[test1@localhost tmp]$ chmod u-x,g-x,o+x test1.txt 
[test1@localhost tmp]$ ls -l
总用量 4
-rw-rw---x. 1 test1 test1 8 7月  20 17:20 test1.txt

例子3：数字修改更方便
[test1@localhost tmp]$ chmod 777 test1.txt 
[test1@localhost tmp]$ ls -l
总用量 4
-rwxrwxrwx. 1 test1 test1 8 7月  20 17:20 test1.txt
```

### 4.修改文件所属

**chown，全称Change Owner，改变拥有者**

```bash
#修改文件的所属,普通用户是不能修改其他用户文件的所属的，需要root用户，所以先切换到root用户来操作
chown
例子1：修改所属用户和用户组，test2:test2，前面的test2表示用户，后面的test2是组
[root@localhost tmp]# chown test2:test2 ls
[root@localhost tmp]# ls -l
总用量 404
-rwxr-xr-x. 1 test2 test2 159024 7月  20 17:43 grep
-rwxr-xr-x. 1 test2 test2 117608 7月  20 17:38 ls
-rwxr-xr-x. 1 test1 test1 130360 7月  20 17:43 mv
-rw-rw-rw-. 1 test1 test1  14 7月  20 17:38 test1.txt
 
 # 修改所属用户
[root@localhost tmp]# chown test1 ls
[root@localhost tmp]# ls -l
总用量 404
-rwxr-xr-x. 1 test2 test2 159024 7月  20 17:43 grep
-rwxr-xr-x. 1 test1 test2 117608 7月  20 17:38 ls
-rwxr-xr-x. 1 test1 test1 130360 7月  20 17:43 mv
-rw-rw-rw-. 1 test1 test1  14 7月  20 17:38 test1.txt

# 修改目录权限和所属
例子3：文件夹(目录权限)
用root用户创建一个文件夹，文件夹默认所属用户和组为root:root，那么普通用户是没全限制在这个目录中创建文件的。
[root@localhost ~]# cd /tmp/
[root@localhost tmp]# mkdir jaden
[root@localhost tmp]# ls -l
drwxr-xr-x. 2 root   root  6 3月  20 11:36 jaden

普通用户，比如lisi想在里面创建文件：
[lisi@localhost tmp]$ cd jaden/
[lisi@localhost jaden]$ touch 2.txt
touch: 无法创建"2.txt": 权限不够
如何让lisi有创建文件的权限呢？创建文件的权限就是目录写权限
首先要切换到root用户，然后用root用户修改目录权限，或者直接将目录的所属修改为lisi
修改权限：
    [root@localhost tmp]# chmod o+w jaden
    [root@localhost tmp]# ls -l
    drwxr-xrwx. 2 root   root    6 3月  20 11:36 jaden
切换到lisi，创建文件：
[lisi@localhost jaden]$ touch 2.txt
    [lisi@localhost jaden]$ ls 2.txt
修改所属：
[root@localhost tmp]# chmod o-w jaden
[root@localhost tmp]# ls -l
drwxr-xr-x. 2 root   root    19 3月  20 11:39 jaden
[root@localhost tmp]# chown lisi:lisi jaden
[root@localhost tmp]# ls -l 
drwxr-xr-x. 2 lisi   lisi    19 3月  20 11:39 jaden
切换到lisi：    
[lisi@localhost jaden]$ touch 3.txt
[lisi@localhost jaden]$ ls
 2.txt  3.txt
lisi也可以修改目录的权限了，因为它完全属于的lisi：
[lisi@localhost tmp]$ chmod o+w jaden
[lisi@localhost tmp]$ ls -l
drwxr-xrwx. 2 lisi   lisi    32 3月  20 11:42 jaden
 
 #使用uid和gid修改文件的所属用户和所属用户组  属主，属组
例子2：
[root@localhost tmp]# ls -l
总用量 404
-rwxr-xr-x. 1 test2 test2 159024 7月  20 17:43 grep
-rwxr-xr-x. 1 test1 test2 117608 7月  20 17:38 ls
-rwxr-xr-x. 1 test1 test1 130360 7月  20 17:43 mv
-rw-rw-rw-. 1 test1 test1   14 7月  20 17:38 test1.txt

[root@localhost tmp]# id test1
uid=1000(test1) gid=1000(test1) 组=1000(test1)
[root@localhost tmp]# id test2
uid=1001(test2) gid=1001(test2) 组=1001(test2)
[root@localhost tmp]# useradd  -g test1  test3
[root@localhost tmp]# id test3
uid=1002(test3) gid=1000(test1) 组=1000(test1)
[root@localhost tmp]# chown 1001:1001 test1.txt 
[root@localhost tmp]# ls -l 
总用量 404
-rwxr-xr-x. 1 test2 test2 159024 7月  20 17:43 grep
-rwxr-xr-x. 1 test1 test2 117608 7月  20 17:38 ls
-rwxr-xr-x. 1 test1 test1 130360 7月  20 17:43 mv
-rw-rw-rw-. 1 test2 test2  14 7月  20 17:38 test1.txt
```

**文件权限和目录权限的解释说明：**

```
文件权限： rwx 读写执行
目录的权限： rwx，r表示可以查看目录下有哪些文件  x表示可以cd切换到该目录  w表示可以在目录中创建、修改、删除文件等操作

为了安全操作：
文件权限默认： 644权限、狠一点就给600权限
目录权限默认： 755权限、狠一点就给700权限
```

### 5、文件属性详解

```bash
#文件属性
[root@localhost ~]# ls -l -rw-rw-rw-. 1 lisi   lisi     0 3月  20 16:00 222.txt
#第一段的第一个字符，表示文件类型 -文件、d目录、l软链接(对应着windows快捷方式)、b块设备(ls /dev，可以看到硬盘sda等)
#第一段第2-4字符，表示该文件所属用户的权限
#第一段第5-7字符，表示该文件所属用户组的权限
#第一段第8-10字符，表示其他用户对该文件的权限

#第一段的第11个字符. ，表示开启selinux的状态下创建的，也证明selinux是开启状态的。
# 看到.表示这个文件受到selinux的保护，selinux：https://baike.baidu.com/item/SELinux/8865268?fr=aladdin，这个东西很安全，但是有了它变得很麻烦，安全和便利一般是冲突的。主要是红帽系的系统(redhat\centos\阿里的龙蜥\华为的欧拉)有这个机制。我们一般上来就是关闭它，安全方面我们通过其他方法来控制。查看selinux的指令：
# 查看状态
[lisi@localhost tmp]$ sestatus
    SELinux status:                 enabled  # enabled表示开启状态，disabled表示禁用
状态
    SELinuxfs mount:                /sys/fs/selinux
    SELinux root directory:         /etc/selinux
    Loaded policy name:             targeted
    Current mode:                   enforcing
    Mode from config file:          enforcing
    Policy MLS status:              enabled
    Policy deny_unknown status:     allowed
    Max kernel policy version:      
   # 关闭和开启selinux，需要root权限才能修改
[root@localhost tmp]# ls -l /etc/selinux/config -rw-r--r--. 1 root root 543 3月  15 20:11 /etc/selinux/config
[root@localhost tmp]# vi /etc/selinux/config 
把7行改为： SELINUX=disabled  #然后保存退出，并且重启系统才会生效。
# 然后再登录创建文件，查看文件信息，就看不到.了
[root@localhost ~]# touch 1.txt
[root@localhost ~]# ls -l
总用量 16
-rw-r--r--  1 root root  0 3月  20 13:32 1.txt


#第二段的数字，表示该文件的硬链接数量，其实这个和我们的安全没有太大关系，运维人员需要学习，ln是创建硬链接的指令。我们不提了
#第三段的字符串，表示该文件所属用户
#第四段的字符串，表示该文件所属用户组
#第五段的数字，表示该文件的大小，默认单位为B，如果想按照KB来显示，那么可以通过ls -lh指令来查看。h是human的意思，以人类可读的方式显示，会自动按照文件大小来设定显示单位。
#第六段到倒数第二段，都是该文件的修改时间，只要改动了文件内容，这个时间就会自动变为修改文件时的时间。

#其实linux系统会记录三个时间：
# 访问时间(access time) 文件被打开时自动变化这个时间
# 修改时间(modify time) 文件内容发生变化时自动改变这个时间，ls -l 显示的就是这个时间。
# 改变时间(change time) 文件属性发生变化时自动改变这个时间，文件大小也是文件的属性，所以修改文件内容导致大小变化的时候，这个时间也会自动改变。
#windows系统也会记录三个时间：访问时间、创建时间、修改时间
#linux下通过stat指令来查看：
[root@localhost ~]# stat 1.txt
文件："1.txt"
大小：0          块：0          IO 块：4096   普通空文件
设备：801h/2049d   Inode：67108933    硬链接：1
权限：(0644/-rw-r--r--)  Uid：(    0/    root)   Gid：(      0/    root)
最近访问：2023-03-20 13:32:34.333042228 +0800
最近更改：2023-03-20 13:32:34.333042228 +0800
最近改动：2023-03-20 13:32:34.333042228 +0800


创建时间：
# 我们改一下文件权限，然后再看时间
[root@localhost ~]# chmod 777 1.txt
        [root@localhost ~]# stat 1.txt
文件："1.txt"
大小：0          
块：0          IO 块：4096   普通空文件
设备：801h/2049d   Inode：67108933    硬链接：1
权限：(0777/-rwxrwxrwx)  Uid：(    0/    root)   Gid：(    0/    root)
最近访问：2023-03-20 13:32:34.333042228 +0800
最近更改：2023-03-20 13:32:34.333042228 +0800
最近改动：2023-03-20 13:56:43.005634151 +0800  # 改动时间变了
创建时间：-

#最一段，该文件的名称
```

**linux一切皆文件的系统。**



## 六.Linux Shell

### 1、Shell的意思

```
Shell： 蛋壳的意思，是linux中比较重要的一个概念，所有的命令其实都称之为shell命令。


看图解：shell就是内核的一个外壳，用户通过shell来控制内核进而驱动硬件做事情，这是它名字的由
来。Linux下，没有shell的话，就不能控制这个计算机了，因为内核是用户不能直接控制的。
```

![image-20240525135731480](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E5%AD%A6%E6%A0%A1/Hadoop/image-20240525135731480.png)

我们使用的是哪个shell呢？

```bash
# 在/etc/passwd中就可以看到：
wangwu:x:1002:1002::/home/wangwu:/bin/bash
# 后面这个/bin/bash，就是我们目前使用的shell，后面我们还会更换其他shell来玩，后面再说。
chrony:x:998:996::/var/lib/chrony:/sbin/nologin
# 如果指定的是/sbin/nologin这个shell的话，是没有办法登录系统的
```

shell会帮我们检测输入和输出的内容是否正确 

```bash
# 随便输入点东西，回车，shell就检测到你这个指令不对，报错给你看 
[root@localhost ~]# asdf
-bash: asdf: 未找到命令
```

###  2、优化ssh登录速度  

如果你发现你的xshell或者ssh指令连接linux系统的时候很慢，等好久才连接成功，那么就可以按照下面的方式优化一下，目前我们没有遇到，所以这个暂时就不提了。

```
#修改配置文件，先备份
[root@localhost ~]# cp /etc/ssh/sshd_config /tmp/
[root@localhost ~]# vi /etc/ssh/sshd_config 
#直接输入:79回车
	79  GSSAPIAuthentication no
 	115 UseDNS no
输入:wq保存退出

#重启sshd服务
[root@localhost ~]# systemctl restart sshd

#如果修改失败，还原配置文件
[root@localhost ~]# cp  /tmp/sshd_config  /etc/ssh/sshd_config
[root@localhost ~]# systemctl restart sshd
```

### 3、shell提示符

```bash
#root用户提示符
[root@localhost ~]# 

#普通用户test1的提示符
[test1@localhost ~]$ 

#格式：
[用户名@主机名 所在目录]#
# 1、用户名，这个没说啥说的
# 2、主机名：localhost是主机名，windows电脑也有主机名：我的电脑-->属性-->高级系统设置-->计算机名，同一个网络中如果有多台计算机的话，每个计算机都应该有个自己的名字，就是主机名.Linux主机名默认叫做localhost，也是可以修改的
    [root@localhost ~]# hostname jaden
    [root@localhost ~]# logout
退出之后，在重新登录，就看到主机名改好了，如下
    [root@jaden ~]# hostname
    jaden

# 3、所在目录：root登录之后，默认所在目录是/root，此时~表示的/root目录，如果是普通用户登录
的，那么~表示的是用户家目录，cd切换目录的时候，显示的当前所在目录
# root用户：
    [root@jaden ~]# pwd
    /root
# 普通用户：
    [zhangsan@jaden ~]$ pwd
    /home/zhangsan
# 4、提示符号
	#代表当前登录的用户是管理员,$代表的是当前登录用户是普通用户

#提示符格式定制，这个简单理解一下即可，一般都不改
# 原格式：
[root@test ~]# echo $PS1
[\u@\h \W]\$        # \u是用户，\h是主机名，\W是相对路径 
# 临时修改：重新登录就又还原了
[root@test ~]#cd /usr/local/bin/
[root@test bin]#export  PS1='[\u@\h \w]\$'  # \w表示绝对路径
[root@test /usr/local/bin]#

#永久修改
[root@test 10:23:39 /usr/local/bin]#cd
[root@test 10:24:25 ~]#vi .bashrc 
#找个空白的地方，插入一行
export  PS1='[\u@\h \t \w]\$'

#linux PS1可以各种定制：参考https://www.cnblogs.com/Q--T/p/5394993.html
```

 **临时修改主机名**

```bash
hostname
例子1：
[root@localhost ~]# hostname test
#需要重新登录生效
```

**查看主机的信息**

```bash
[root@localhost ~]# hostnamectl 
   Static hostname: localhost.localdomain
         Icon name: computer-vm
           Chassis: vm
        Machine ID: f8a89169114741a8ac6de82954c5fbcb
           Boot ID: dcf65386ccda42e29699d56101af8cf1
    Virtualization: vmware
  Operating System: CentOS Linux 7 (Core)
       CPE OS Name: cpe:/o:centos:centos:7
            Kernel: Linux 3.10.0-1127.el7.x86_64
      Architecture: x86-64

#永久修改主机名
[root@localhost ~]# hostnamectl set-hostname test
#需要重新登录生效
```

**重启系统**

```bash
[root@test ~]# reboot
```

**关闭或者重启**

```bash
shutdown

例子1：
#立即关机
[root@localhost ~]# shutdown -h now

例子2：
#5分钟之后关机，可以使用shutdown -c取消
[root@localhost ~]# shutdown -h 5

例子3：
#5分钟之后重启系统，可以使用shutdown -c取消
[root@localhost ~]# shutdown -r 5
```

### 4.shell基础语法

```bash
不带参数的：
	reboot、pwd、id、ls等都可以不接参数，不多
带参数的：
	命令   参数     目标
	ls   -a -l -h   /opt      # 参数还可以合并为-alh
rm     -rf         /opt/test1
命令   源...   目标
mv    源路径   目标路径
cp    

查看命令的参数： 命令 -h或者--help
[root@test 11:12:02 /opt]#mv --help
用法：mv [选项]... [-T] 源文件 目标文件
	或：mv [选项]... 源文件... 目录
	或：mv [选项]... -t 目录 源文件...
     #格式解释
    [选项] 可选的参数
    ...   可以有多个

我自己简单总结的：
格式1：不带参数的命令：
	reboot、pwd、id、ls等都可以不接参数，不多
格式2：带参数一个参数的指令：
	ls -l
	usermod -h  或者 usermod --help
格式3：带多个参数的指令：
	ls -a -l -h # 参数还可以合并为-alh
格式4：带参数带一个目标的指令
	ls -l /boot
	rm -rf /tmp/jaden   # 注意：千万不要rm -rf /* 这是删除根目录的意思，或者 rm -rf 						/tmp/*,如果tmp目录不存在，也是删除根目录的意思。
格式5：命令带一个目标
    cd /tmp/
    ls /tmp/
     mkdir jaden
     useradd jaden
     ...
格式6：命令带多个源和目标
    cp jaden.txt /tmp/11.txt  # cp 源1  目标1
    cp 1.txt 2.txt 3.txt /tmp  # cp 源1 源2 源3 目标1
格式7：命令带多个参数、多个源和多个目标
	ls -a -l -h /tmp /root /opt
	cp -a -v /root /root2  # -v是显示拷贝过程的，-a 保留原文件属性的前提下复制文件
其他格式就不多说了。 
```

### 5、tab键补全

```bash
补全命令：
#如果预选的特别多
    [root@test 11:25:24 ~]#
    Display all 1400 possibilities? (y or n)
 #如果预选少
 [root@test 11:25:24 ~]#cha
 chacl   chage   chattr 

补全路径：
#如果预选的特别多
    [root@test 11:25:24 ~]#cd /etc/
    Display all 188 possibilities? (y or n)
 #如果预选少
    [root@test 11:25:24 ~]#cd /usr/src/
    debug/   kernels/ 
# 路径不存在的话就说明路径不存在
```

### 6、快捷键 

```bash
Ctrl + a    #光标跳转至正在输入的命令行的首部
Ctrl + e    #光标跳转至正在输入的命令行的尾部
Ctrl + c    #终止前台运行的程序，比如ping指令
Ctrl + d    #在shell中，ctrl-d表示推出当前shell。
Ctrl + z    #将任务暂停，挂至后台, 执行fg命令继续运行
Ctrl + l    #清屏，和clear命令等效。
Ctrl + k    #删除从光标到行末的所有字符
Ctrl + u    #删除从光标到行首的所有字符
Ctrl + r    #搜索历史命令, 利用关键字搜索
ctrl + w    #光标往前删除一个参数，以空格为分割。
```

### 7、history历史命令

```bash
#历史
history
例子1:
[root@test 14:32:10 ~]#history
 1  exit
 2  ls
 3  head -1 test03.txt 
 4  head -1 test03.txt|cat
 5  head -1 test03.txt|tac
 6  head -2 test03.txt|tac
 7  head -2 test03.txt|cat
 8  ip addr
 9  ip addr|tail -4
 10  ip addr|tail -4|head -1
   ......

例子2：
#使用!调用历史命令
[root@test 14:32:10 ~]#history|head -5
 1  exit
 2  ls
 3  head -1 test03.txt 
 4  head -1 test03.txt|cat
 5  head -1 test03.txt|tac
[root@test 14:32:26 ~]# !3
 head -1 test03.txt 
head: 无法打开"test03.txt" 读取数据: 没有那个文件或目录

#使用!调用mv开头的命令
[root@test 14:42:17 ~]#history 
1  ls -a -l .bash_history 
2  history 
3  ls
4  history 
5  mv aaaaa.txt /tmp/
6  history 
[root@test 14:42:19 ~]#!mv  # 按回车，会自动找最近一次执行的mv开头的指令
mv aaaaa.txt /tmp/
mv: 无法获取"aaaaa.txt" 的文件状态(stat): 没有那个文件或目录

例子4：
#清除历史记录
history -c # 这是清除内存中的历史指令
删除主文件夹下面.bash_history  # 这是清除硬盘中的历史指令，内存中的指令会自动备份到.bash_history中，但是有个延迟，退出登录之后，才会将历史指令同步到硬盘文件中每个用户家目录下都有一个.bash_history，记录的是自己用户的历史指令。
.bash_history默认记录最近的1000条指令，通过echo $HISTSIZE可以查看，可以配置的更大或者更小一些，vi /etc/profile，这个以后再说。

```

### 8、命令别名(花名)

```bash
#别名
alias
# 比如：ls -l 直接可以写ll即可

例子1：
#查看别名
[root@test 15:23:17 ~]#alias 
alias cp='cp -i'
alias egrep='egrep --color=auto'
alias fgrep='fgrep --color=auto'
alias grep='grep --color=auto'
alias l.='ls -d .* --color=auto'
alias ll='ls -l --color=auto'
alias ls='ls --color=auto'
alias mv='mv -i'
alias rm='rm -i'
alias which='alias | /usr/bin/which --tty-only --read-alias --show-dot --show
tilde'

例子2：
#添加别名
[test1@test 15:24:23 ~]$alias rm='rm -i'  # -i是提示警告信息用的
[test1@test 15:27:08 ~]$alias |grep rm
alias rm='rm -i'
或者：[test1@test 15:24:23 ~]$alias rm='echo 禁止使用删除操作' 

例子3：
#取消别名
[test1@test 15:27:13 ~]$unalias ls 
[test1@test 15:27:47 ~]$alias |grep ls
alias别名的优先级高于系统命令
别名一定要是可执行的，不能随便定义别名，比如jaden='aaaaaaa'，执行jaden会报错，没有aaaaaaa这个指令

例子4：
#alias永久生效
[root@localhost ~]# vi .bashrc 
#空白处，增加一行
alias cip='ip addr|tail -4|head -1'
```

## 七.Linux输入输出重定向

输入输出只能对文件进行操作，不能对目录操作。

```bash
输出：
    >  输出重定向， 将命令执行结果不输出到屏幕上，输出到文件里，会清空原文件，所以输出的时候一定要注意，文件名称要看好了。
        [root@localhost ~]# head -20 services > 2.txt
        [root@localhost ~]# cat 2.txt
        [root@localhost ~]# seq 100 > 1.txt
        [root@localhost ~]# echo 123 > 1.txt
        [root@localhost ~]# cat 1.txt
 						123
        [root@localhost ~]#  > 1.txt  # 清空文件内容
        [root@localhost ~]# cat 1.txt
   
   >> 输出追加重定向，不会清空原文件
        [root@localhost ~]# echo aaaaa >> 2.txt
        [root@localhost ~]# cat 2.txt 

#标准正确输出重定向1
#标准错误输出重定向2
        [root@localhost ~]# cat jaden.txt 
        hello jaden 
        what are you nongshalie!
        [root@localhost ~]# cat jadent  # 错误信息默认是打印在屏幕上的，如果我们想记录错
误信息，就可以用到标准错误输出
		
		cat: jadent: 没有那个文件或目录
        [root@localhost ~]# cat jaden.txt 1>1.txt 2>2.txt  # 指令正确会将数据保存到1.txt中
        [root@localhost ~]# cat 1.txt
        hello jaden 
        what are you nongshalie!
        [root@localhost ~]# cat 2.txt
        [root@localhost ~]# cat jade 1>1.txt 2>2.txt  #jade文件不存在，报错信息会进入到2.txt中
        [root@localhost ~]# cat 1.txt
        [root@localhost ~]# cat 2.txt  # 记录了报错信息
						cat: jade: 没有那个文件或目录
输出重定向我们用的很多，输入重定向用的很少，所以简单演示一下即可。







输入：
    <  输入重定向
[root@localhost ~]# cat < jaden.txt > 3.txt  # 将jaden.txt的数据输入过来并写
入3.txt中
        [root@localhost ~]# cat jaden.txt 
    << 输入追加重定向(这个就不演示了，遇到了再说)
	# 标准输入0，支持用户直接输入内容
[root@localhost ~]# cat << 0
        > 1
        > 2
        > 2222
        > 0
1
2
2222
[root@localhost ~]# cat << 0 > 22.txt
        > a
        > b
        > ddd
        > 0
        [root@localhost ~]# cat 22.txt
        a
        b
        ddd
```

八.inux压缩打包

### 1、tar

```bash
# 压缩文件有时候我们也叫做归档文件。但是归档和压缩有一些区别，归档只是将多个文件捆绑成一个文件，并没有压缩，而压缩才是将大小压缩的更小。

#Linux最常用的压缩和解压指令是：
tar：能够解压的文件格式是xx.tar.gz
压缩：tar -zcf 压缩包路径 目标1 目标2 目标3 ...
解压：tar -zxf 解压路径

例子1：压缩和解压文件
[root@localhost ~]# ls
 123.txt  4.txt            a.txt  c.txt         jaden.txt
1.txt    anaconda-ks.cfg  b.txt  jaden.tar.gz  services
[root@localhost ~]# rm -f *
[root@localhost ~]# ls
[root@localhost ~]# cp /etc/services .
[root@localhost ~]# tar -zcf jaden.tar.gz services  #压缩文件
[root@localhost ~]# ls
 		jaden.tar.gz services 
[root@localhost ~]# ls -lh
    -rw-r--r--  1 root root 134K 3月  22 14:51 jaden.tar.gz
    -rw-r--r--  1 root root 655K 3月  22 11:22 services
[root@localhost ~]# rm -f services  # 删除原文件之后就再解压
[root@localhost ~]# tar -zxf jaden.tar.gz   # 解压文件
[root@localhost ~]# ls -lh
    -rw-r--r--  1 root root 134K 3月  22 14:51 jaden.tar.gz
    -rw-r--r--  1 root root 655K 3月  22 11:22 services  #看到和源文件一样的文件，包括文件属性也一样。

例子2：
#归档，但是不压缩
tar -cf
守夜人Jaden-吴老板
[root@localhost ~]# cp /etc/services ./shike  # 再拷贝一个services文件过来
[root@localhost ~]# ls -lh
总用量 14M
-rw-r--r-- 1 root root  13M 3月  22 14:58 2.tar.gz
-rw-r--r-- 1 root root 134K 3月  22 14:56 jaden.tar.gz
-rw-r--r-- 1 root root 655K 3月  22 14:55 services
-rw-r--r-- 1 root root 655K 3月  22 15:04 shike
[root@localhost ~]# tar -cf 3.tar.gz services shike  #归档，但是不压缩
[root@localhost ~]# ls -lh
总用量 15M
-rw-r--r-- 1 root root  13M 3月  22 14:58 2.tar.gz
-rw-r--r-- 1 root root 1.3M 3月  22 15:04 3.tar.gz  #看大小就知道没有压缩大小。
-rw-r--r-- 1 root root 134K 3月  22 14:56 jaden.tar.gz
-rw-r--r-- 1 root root 655K 3月  22 14:55 services
-rw-r--r-- 1 root root 655K 3月  22 15:04 shike


例子3：
#查看压缩包内容
[root@localhost ~]# tar -tf 3.tar.gz 
services
shike
tar这个指令的参数可以不加-，比如tar tf 3.tar.gz
```

 linux系统下解压文件的时候，不同格式的压缩包需要使用不同的命令来解压或者压缩

### 2、gzip

```bash
#打包和压缩
#压缩文件，会自动删除原文件，和tar不同，tar会留着原文件
[root@localhost ~]# gzip services 
[root@localhost ~]# ls -lh
总用量 15M
-rw-r--r-- 1 root root 133K 3月  22 14:55 services.gz
-rw-r--r-- 1 root root 655K 3月  22 15:04 shike

# 解压，会自动删除原压缩包
[root@localhost ~]# gzip -d services.gz 
[root@localhost ~]# ls -lh
总用量 16M
-rw-r--r-- 1 root root 655K 3月  22 14:55 services
-rw-r--r-- 1 root root 655K 3月  22 15:04 shike

#压缩多个文件，每一个文件产生一个单独的压缩包
[root@localhost ~]# gzip services shike 
[root@localhost ~]# ls -lh
总用量 15M
-rw-r--r-- 1 root root 133K 3月  22 14:55 services.gz
-rw-r--r-- 1 root root 133K 3月  22 15:04 shike.gz

#解压缩
[root@localhost ~]# gzip -d services.gz shike.gz 
[root@localhost ~]# ls -lh
总用量 16M-rw-r--r-- 1 root root 655K 3月  22 14:55 services-rw-r--r-- 1 root root 655K 3月  22 15:04 shike
gzip其实感觉并不太好用，但是工作中我们可能会遇到gzip的压缩包。
```

### 3、zip

```bash
#压缩
zip
例子1：
[root@localhost ~]# zip -r 1.zip services shike  #会保留原文件
  adding: services (deflated 80%)
  adding: shike (deflated 80%)
[root@localhost ~]# ls -lh
总用量 16M
-rw-r--r-- 1 root root 267K 3月  22 15:25 1.zip
-rw-r--r-- 1 root root 655K 3月  22 14:55 services
-rw-r--r-- 1 root root 655K 3月  22 15:04 shike

#解压
unzip
例子1： # 解压之前先把原文件删掉，以免冲突
[root@localhost ~]# unzip 1.zip 
[root@localhost ~]# ls -lh
总用量 16M
-rw-r--r-- 1 root root 267K 3月  22 15:25 1.zip
-rw-r--r-- 1 root root 655K 3月  22 14:55 services
-rw-r--r-- 1 root root 655K 3月  22 15:04 shike
```

###  4、关于rar压缩包

```bash
#解压rar包
#需要安装软件
yum install epel-release -y
yum install unar -y
#再进行解压
unar -o 解压路径 被解压文件路径
例如：
unar -o /opt 456.rar


[root@localhost ~]# ls
 1.zip  2.tar.gz  3.tar.gz  jaden.rar  jaden.tar  services  shike
[root@localhost ~]# mkdir xx
[root@localhost ~]# unar -o ./xx jaden.rar 
    jaden.rar: RAR 5
    jaden.txt  (49 B)... OK.
    Successfully extracted to "./xx/jaden.txt".
[root@localhost ~]# ls xx/
 jaden.txt
```

##  八.文件传输

![image-20240525142558462](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E5%AD%A6%E6%A0%A1/Hadoop/image-20240525142558462.png)

### 1、网站下载文件

```bash
#下载文件
curl
例子1：
#下载文件
curl -o 本地存放路径 文件网址
例如：有些网站在后台可能禁了curl下载，导致下载不下来
	curl -o 123.zip https://github.com/nmap/nmap/archive/refs/heads/master.zip

wget 文件网址
# 需要自行安装一下才有这个功能，curl是系统自带的
# yum install -y wget
[root@localhost ~]# wget https://github.com/nmap/nmap/archive/refs/heads/master.zip
 # wget比curl方便，最起码不需要指定文件名，curl如果不指定文件名路径的话会将文件内容打印在屏幕上
 
#使用curl和wget的前提是要有网
#检查网络畅通
ping
例子1：ping www.baidu.com

#如果网不通，重启网络服务
systemctl restart network
```

### 2、scp传输

我们准备两台linux虚拟机来玩：

```bash
#主要用于linux和linux服务器之间传输文件，scp要求接受数据的一方要开启了ssh服务端才行，如果你电脑是苹果电脑mac系统，也可以使用scp来传输，mac默认ssh服务端是没有开启的，可以自行开启，客户端是可以直接使用的。windows往linux上面发送文件也可以用scp，但是只能单向的，因为windows上没有ssh服务端。

#把本地文件推送到远程服务端
# 格式： scp 本地文件路径 远程主机用户@远程主机ip地址:远程主机某个目录
scp typora-setup-x64.exe  root@10.0.0.128:/tmp

#把远端服务文件拉取到本地
# 格式：scp 远程主机用户@远程主机ip地址:远程主机某个文件路径 本地路径
scp root@10.0.0.128:/tmp/typora-setup-x64.exe  
```

win10及以上版本是有scp指令的，win和win之间是不能使用scp互相传文件的，因为windows上默认是 没有ssh的服务端的，只有客户端。

```bash
# windows使用scp给linux上传文件的时候，文件路径和文件名中不允许出现中文和空格。
# 格式和上面一样
scp typora-setup-x64.exe  root@10.0.0.128:/tmp
```

 mac系统也是直接可以使用scp来给linux上传文件的。

### 3、rz和sz

```bash
#上传和下载
rz  #上传
sz  #下载
#需要先安装lrzsz软件包，这个用的比较多
yum  install lrzsz  -y
#上传的例子
如果使用xshell，那么直接鼠标拖拽即可，或者执行rz -E选择要上传的文件
#下载的例子
sz /root/test3.tar.gz  # windows上自行选择存储目录
```

## 九.软件的安装

![image-20240525143058600](D:/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/%E5%AD%A6%E6%A0%A1/Hadoop/image-20240525143058600.png)

### 1、编译安装

我们有时候安装软件，下载下来的是软件源代码，不能直接运行，需要编译之后才能运行，源代码-->编 译-->二进制机器码，才能运行。比如windows的某些软件是从源代码编译打包之后才生成exe程序，平 常我们接触不到，大家安装的软件都是基本别人编译好的。而linux下编译之后会生成二进制的可执行文 件，不是exe程序昂，和windows不同，这种文件没有后缀名。其实linux系统下就没有文件后缀名这个 概念，好多后缀名都是我们人工自己加上去的，为了让自己知道文件是干嘛的，主要是给我们自己看 的，区分作用。

```bash
我们用一个网站服务软件来玩一玩试试：
1.下载源码包
cd /opt/
rm -fr *
curl -o nginx.tar.gz http://nginx.org/download/nginx-1.20.1.tar.gz


2.编译安装
tar xf nginx.tar.gz 
cd nginx-1.20.1/
    [root@localhost nginx-1.20.1]# ls
    auto  CHANGES  CHANGES.ru  conf  configure  contrib  html  LICENSE  man  README  src
    
# 1.配置编译参数
# 这个软件给我们提供了很多功能，我们在编译的过程中可以自己选择哪些功能要，哪些功能不要，所有功能都要就是完整版，好多功能都不要就成了精简版，比如qq精简版，不知道大家听没听过。
./configure --prefix=/usr/local/nginx --without-pcre --without - http_rewrite_module --without-http_gzip_module 
	#我这里禁掉了一些功能，以为这些功能都需要好多依赖包，大家还不知道依赖包是怎么回事儿，所以我就暂时先删除了。--without就是去掉的意思。--prefix=/usr/local/nginx是指定软件的安装目录，目录不存在的话会自动创建。./是用相对路径来执行这个configure文件，用绝对路径也可以执行这个文件。这个指令执行之后，会自动检查各种依赖环境是否满足软件运行的要求，检查通过之后会生成一个叫做Makefile的文件。
[root@localhost nginx-1.20.1]# ls 
    auto     CHANGES.ru  configure  html     Makefile  objs    src   CHANGES  conf        contrib    LICENSE  man       README
#多了两个文件Makefile和objs，刚才的指令主要是为了生成Makefile

# 2.编译
make  #make会找当前目录中的Makefile文件来进行编译，这个编译过程一般是比较长的。到底多长时间呢？1、看CPU性能  2、软件功能复杂度
[root@localhost nginx-1.20.1]# ls  
    auto     CHANGES.ru  configure  html     Makefile  objs    
    CHANGES  conf        contrib    LICENSE  man       README
# 编译之后看上去目录结构和之前一样，但是objs目录里面其实多了好多东西。
[root@localhost nginx-1.20.1]# ls objs/
    autoconf.err  nginx    ngx_auto_config.h   ngx_modules.c  src
    Makefile      nginx.8  ngx_auto_headers.h  ngx_modules.o
# 其中nginx文件就是我们的二进制可执行的命令文件。它是可执行的程序了，比如我们查看一下它的版本
[root@localhost nginx-1.20.1]# ./objs/nginx -v
	nginx version: nginx/1.20.1
	# 到这里只是编译完了，还需要安装，其实安装就是将这个程序的某些文件放到对应的目录中去。其实我们在上面的编译参数中已经指定好了--prefix=/usr/local/nginx，要安装到/usr/local/nginx目录中去。

# 3.安装
make install
 # 查看安装目录，这就是它这个软件安装的所有文件
    [root@localhost nginx-1.20.1]# ls /usr/local/nginx/
    conf  html  logs  sbin
 # 这样看目录结构看着不太清晰，我们可以安装一下tree这个工具，来进行目录查看
[root@localhost nginx-1.20.1]# yum install tree -y
 # 安装完tree之后，我们来看一下目录，看着就清晰多了，树状结构显示。
[root@localhost nginx-1.20.1]# tree /usr/local/nginx/
    /usr/local/nginx/
    ├── conf  
# 该软件的配置文件所在目录
    │   ├── fastcgi.conf
    │   ├── fastcgi.conf.default
    │   ├── fastcgi_params
    │   ├── fastcgi_params.default
    │   ├── koi-utf
    │   ├── koi-win
    │   ├── mime.types
    │   ├── mime.types.default
    │   ├── nginx.conf
    │   ├── nginx.conf.default
    │   ├── scgi_params
    │   ├── scgi_params.default
    │   ├── uwsgi_params
    │   ├── uwsgi_params.default
    │   └── win-utf
    ├── html  
# 网站源代码存放目录，这个nginx其实主要是用来部署网站的，网站的代码可以放到这个
目录中
    │   ├── 50x.html
    │   └── index.html
    ├── logs  
# 这个软件自带日志记录功能，记录的日志存放在这个目录中
    └── sbin
        └── nginx  
# 这个是软件的关键性的启动程序，类似于我们windows安装的qq目录中的QQ.exe
4 directories, 18 files


3.运行
指令：/usr/local/nginx/sbin/nginx，没有配置环境变量，所以要用完整路径来运行
[root@localhost nginx-1.20.1]# /usr/local/nginx/sbin/nginx
[root@localhost nginx-1.20.1]#    #看上去没什么效果，但是已经运行了
# 可以通过浏览器访问这个nginx了，访问之前要关闭一下防火墙。
# 关闭防火墙
systemctl stop firewalld
# 取消防火墙的开机自启
systemctl disable firewalld
# 使用浏览器访问http://<虚拟机的ip地址>
http://192.168.61.132/  就可以看到网站了。
关于nginx这个软件如何使用，我们后面课程中会详细的讲解，这里先简单感受一下编译安装过程即可。

# 打包：就是将我们编译好的程序打包起来，给其他人用的时候，其他人就不用编译了，因为你已经编译好了，我们普通用户使用的软件就是别人编译打包之后的软件。
/usr/local/nginx 这个目录就是我们编译好之后的整个软件的所有运行文件目录，我们打包它即可
# 打包压缩
[root@localhost nginx-1.20.1]# cd /usr/local/
[root@localhost local]# ls
bin  etc  games  include  lib  lib64  libexec  nginx  sbin  share  src
[root@localhost local]# tar -zcf /tmp/nginx_jaden.tar.gz nginx 
[root@localhost local]# ls
bin  etc  games  include  lib  lib64  libexec  nginx  sbin  share  src
[root@localhost local]# ls /tmp/
ks-script-ed2ODG
nginx_jaden.tar.gz
# 推送给另外一台主机
[root@localhost tmp]# scp nginx_jaden.tar.gz root@192.168.61.135:/tmp
# 另外一台主机的操作：解压到/usr/local目录下，然后运行
[root@localhost tmp]# ls
nginx_jaden.tar.gz
[root@localhost tmp]# mv nginx_jaden.tar.gz /usr/local/
[root@localhost tmp]# cd /usr/local/
[root@localhost local]# ls
bin  etc  games  include  lib  lib64  libexec  nginx_jaden.tar.gz  sbin  share  src
[root@localhost local]# tar -zxf nginx_jaden.tar.gz 
[root@localhost local]# ls
bin  etc  games  include  lib  lib64  libexec  nginx  nginx_jaden.tar.gz  sbin share  src
[root@localhost local]# /usr/local/nginx/sbin/nginx
[root@localhost local]# systemctl stop firewalld
```

### 2、rpm安装

```bash
# 刚才我们提到过，编译还是比较繁琐的，为了方便使用者，一般都会编译之后发给使用者，用起来不需要编译，就方便多了。只要有人编译一次，将编译后的程序贡献出来，大家就可以用了。所以这些做系统的厂商也发现这样挺好，所以这些厂商干脆将自己的软件也打包一下，redhat、debian等都做了自己软件的打包工作，将自己的软件打包好之后，供用户下载使用。下载软件需要用到对应系统的包管理工具。

# redhat系打出来的包叫做：rpm包。用yum安装的程序包其实都是rmp包，比如刚才安装的tree。rpm的包我们也可以不使用yum而手动安装。
# debian系打出来的包叫做：deb包。
#rpm全称：redhat package manager包管理器

# 手动安装rpm包示例：不需要编译安装、也不用yum安装。
# 安装wget
yum install wget -y
# 使用wget下载rpm包
wget https://mirrors.tuna.tsinghua.edu.cn/centos/7/os/x86_64/Packages/tree-1.6.0
10.el7.x86_64.rpm

# 如果没有wget，可以先用curl下载：
curl -o wget.rpm 
https://mirrors.tuna.tsinghua.edu.cn/centos/7/os/x86_64/Packages/wget-1.14-18.el7_6.1.x86_64.rpm
# 安装rpm包 #rpm -i是安装，vh是显示安装进度条的意思。
rpm -ivh tree-1.6.0-10.el7.x86_64.rpm 
# 卸载
rpm -e tree
# 升级
rpm -Uvh  xxx.rpm
# 查看已安装的软件
rpm -qa|grep httpd
```

### 3.yum安装

```bash
#自动解决rpm依赖
#yum安装扩展yum仓库
yum install epel-release -y
#yum安装nginx
yum install nginx -y
#yum移除nginx
yum remove nginx -y
#查看仓库rpm的数量
yum repolist
```

## 安装方法总结

```
编译安装：优点： 自由定制  痛点：难度高，步骤繁琐
rpm安装：优点：安装简单   痛点：需要自己解决依赖，不支持定制
yum安装：优点：自动解决依赖，默认安装最新版  痛点：不支持定制
```

# 十.find文件查找

文件查找，我们在windows用的比较多，系统自带的搜索方式、第三方搜索工具everything等。 linux上没有图形化界面，就要借助find指令来查了。

```bash
#文件查找
例子1：普通查询
find /etc   -maxdepth 1  -type f  -name "pa*"
命令   目录...   查找深度     
类型   文件名称包含  
# -type文件类型：f表示文件，不指定类型的话，文件和目录都会查找
# -maxdepth查找深度：目录层级的意思，不指定的话，就按照最大深度来查找
# "pa*"： *表示匹配任意pa开头的内容，*号还可以写在开头
```

```bash
例子2：按照文件大小查找(单位kMG,k要小写，MG要大写，不带单位就按照B单位来查找)
 1.查找大于100M的文件
find / -type f -size +100M 
    [root@localhost tmp]# find / -type f -size +100M 
    /proc/kcore
    find: ‘/proc/1945/task/1945/fdinfo/6’: 没有那个文件或目录  # proc是进程目录，有些进程运行起来之后能看到文件信息，程序运行结束之后，进程文件也消失了，所以看到proc的报错很正常，并且proc的权限很高，不是一般人可以访问的，所以也经常会报权限不够等错误信息，所以以后看到proc的报错直接忽略即可。
    find: ‘/proc/1945/fdinfo/5’: 没有那个文件或目录
    /sys/devices/pci0000:00/0000:00:0f.0/resource1_wc
    /sys/devices/pci0000:00/0000:00:0f.0/resource1
    /var/cache/yum/x86_64/7/updates/gen/primary_db.sqlite
    /usr/lib/locale/locale-archive
[root@localhost tmp]# ll -h /usr/lib/locale/locale-archive   #大小确实超过了100M
-rw-r--r--. 1 root root 102M 3月  15 20:10 /usr/lib/locale/locale-archive

2.查找小于2k的文件
find /root/nginx-1.20.2 -type f -size -2k

3.查找大于50M同时小于100M的文件
find /  -type f  +50M  -and -size -100M
```

```bash
例子3：
忽略大小写查询
find /etc -maxdepth 1  -iname "pa*"  # i是ignore的简写，忽略的意思
```

```bash
例子4：
根据修改时间查找文件  
    [root@localhost ~]# stat 1.txt
	文件："1.txt"
	大小：0        块：0          IO 块：4096   普通空文件
设备：801h/2049d   Inode：67108933    硬链接：1
权限：(0644/-rw-r--r--)  Uid：(   0/    root)   Gid：(   0/    root) 
环境：unconfined_u:object_r:admin_home_t:s0
最近访问：2023-03-23 09:04:35.339235371 +0800 #Access time
最近更改：2023-03-23 09:04:35.339235371 +0800 #Modify time
最近改动：2023-03-23 09:04:35.339235371 +0800 #Change time
创建时间：-

时间参数：atime mtime ctime amin mmin cmin  #(time是按照天来查找，min是按分钟查找)
# 时间单位为天
find /opt -type f -mtime -1   #-1代表一天以内，+1一天以前
# 时间单位为分钟
[root@localhost ~]# find /root -type f -mmin -20
    /root/.bash_history
    /root/ReadMe.txt
    /root/.lesshst
 # 查找1天之前，10天之内，修改过的文件
[root@localhost ~]# find /etc/ -type f -mtime +1 -and -mtime -10
```

```bash
例子5：  取反: !
例子：
    [root@localhost ~]# find /root -type f -name "*.txt" # 找名称以.txt结尾的文件
    /root/1.txt
    /root/学习前准备.txt
    [root@localhost ~]# find /root -type f ! -name "*.txt" # 找名称中不是.txt结尾的文件
    /root/.bash_logout
    /root/.bash_profile
    ...
    
    [root@localhost ~]# mkdir jaden
    [root@localhost ~]# mkdir wulaoban
    [root@localhost ~]# find /root -type f  # 找文件
    /root/.bash_logout
    /root/.bash_profile
 	...
 [root@localhost ~]# find /root ! -type f  # 找文件夹
    /root/jaden
    /root/wulaoban
    ...
```

```bash
例子6：
根据用户来查找文件
    [root@localhost ~]# useradd jaden
    [root@localhost ~]# find / -user jaden  # 查找属于jaden用户的所有目录和文件
    ...
    /var/spool/mail/jaden
    /home/jaden
    /home/jaden/.bash_logout
    /home/jaden/.bash_profile
    /home/jaden/.bashrc
根据用户组来查
    [root@localhost ~]# find / -group jaden
    ...
```

```bash
例子7：
对找出的文件进行处理
# 格式：正常的find语句+操作exec
# 比如我们查找到了一些病毒文件，想直接删除  
# find /tmp -type f -size +10K -exec rm rf {} \;  # {}表示我们找到的那些文件，\;是这样的：正常exec语句最后要分号结尾，但是分号在linux中有特殊的意义，比如一次性执行两个指令可以 ls -lh;id，这样执行，所以要对;进行转义，意思是不要将;作为shell指令的分隔符，\就是转义符号。
例子：
[root@localhost tmp]# find /tmp -name "vm*" -exec rm -rf {} \;
    find: ‘/tmp/vmware-root_560-2957190359’: 没有那个文件或目录
    find: ‘/tmp/vmware-root_555-4282367637’: 没有那个文件或目录
    find: ‘/tmp/vmware-root_631-4021718894’: 没有那个文件或目录
[root@localhost tmp]# ls
    ks-script-ed2ODG
    nginx_jaden.tar.gz
    systemd-private-d38b668730bf4589896221daead5dbea-chronyd.service-be3NkF
    yum.log
下面的例子就不演示了。
find /root -type f -mmin -30  ! -name ".*"  -exec rm {} \;
find /root  -maxdepth 1  -type d  -name "Apa*"   -mmin -30 -exec cp -a {} /tmp \; # 复制到tmp目录中
```

# 十一.进程管理

进程：正在运行的程序

```bash
#查看进程
ps
参数1：ps -ef
```

```bash
#关闭进程
kill
例子1： kill  7851  #使用进程id号，来终止进程
	   kill -9  pid号  #慎用！！！

pkill 
例子1： pkill sleep  #使用进程的命令名称，来终止进程
       pkill -9 sleep
```

```bash
 #查看计算机的cpu，内存，进程等信息(windows任务管理器)
 top
 
#查看内存命令
free -h

#查看硬盘命令
df -h

#查看cpu
lscpu
```

